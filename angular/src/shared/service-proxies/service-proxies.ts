//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.1.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import { DateTime, Duration } from "luxon";

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    isTenantAvailable(body: IsTenantAvailableInput | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IsTenantAvailableOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IsTenantAvailableOutput>;
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resolveTenantId(body: ResolveTenantIdInput | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body: RegisterInput | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterOutput>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendPasswordResetCode(body: SendPasswordResetCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body: ResetPasswordInput | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResetPasswordOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResetPasswordOutput>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendEmailActivationLink(body: SendEmailActivationLinkInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateEmail(body: ActivateEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonateUser(body: ImpersonateUserInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ImpersonateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processImpersonateUser(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    impersonateTenant(body: ImpersonateTenantInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ImpersonateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processImpersonateTenant(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegatedImpersonate(body: DelegatedImpersonateInput | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/DelegatedImpersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processDelegatedImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonateOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonateOutput>;
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    switchToLinkedAccount(body: SwitchToLinkedAccountInput | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchToLinkedAccountOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchToLinkedAccountOutput>;
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AirportsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param airportNameFilter (optional) 
     * @param iATAFilter (optional) 
     * @param cityFilter (optional) 
     * @param categoryFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, airportNameFilter: string | undefined, iATAFilter: string | undefined, cityFilter: string | undefined, categoryFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetAirportForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Airports/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (airportNameFilter === null)
            throw new Error("The parameter 'airportNameFilter' cannot be null.");
        else if (airportNameFilter !== undefined)
            url_ += "AirportNameFilter=" + encodeURIComponent("" + airportNameFilter) + "&";
        if (iATAFilter === null)
            throw new Error("The parameter 'iATAFilter' cannot be null.");
        else if (iATAFilter !== undefined)
            url_ += "IATAFilter=" + encodeURIComponent("" + iATAFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (categoryFilter === null)
            throw new Error("The parameter 'categoryFilter' cannot be null.");
        else if (categoryFilter !== undefined)
            url_ += "CategoryFilter=" + encodeURIComponent("" + categoryFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAirportForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAirportForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAirportForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAirportForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAirportForView(id: string | undefined): Observable<GetAirportForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Airports/GetAirportForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAirportForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAirportForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAirportForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAirportForViewDto>;
        }));
    }

    protected processGetAirportForView(response: HttpResponseBase): Observable<GetAirportForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAirportForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAirportForEdit(id: string | undefined): Observable<GetAirportForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Airports/GetAirportForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAirportForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAirportForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAirportForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAirportForEditOutput>;
        }));
    }

    protected processGetAirportForEdit(response: HttpResponseBase): Observable<GetAirportForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAirportForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditAirportDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Airports/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Airports/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param airportNameFilter (optional) 
     * @param iATAFilter (optional) 
     * @param cityFilter (optional) 
     * @param categoryFilter (optional) 
     * @return Success
     */
    getAirportsToExcel(filter: string | undefined, airportNameFilter: string | undefined, iATAFilter: string | undefined, cityFilter: string | undefined, categoryFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Airports/GetAirportsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (airportNameFilter === null)
            throw new Error("The parameter 'airportNameFilter' cannot be null.");
        else if (airportNameFilter !== undefined)
            url_ += "AirportNameFilter=" + encodeURIComponent("" + airportNameFilter) + "&";
        if (iATAFilter === null)
            throw new Error("The parameter 'iATAFilter' cannot be null.");
        else if (iATAFilter !== undefined)
            url_ += "IATAFilter=" + encodeURIComponent("" + iATAFilter) + "&";
        if (cityFilter === null)
            throw new Error("The parameter 'cityFilter' cannot be null.");
        else if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&";
        if (categoryFilter === null)
            throw new Error("The parameter 'categoryFilter' cannot be null.");
        else if (categoryFilter !== undefined)
            url_ += "CategoryFilter=" + encodeURIComponent("" + categoryFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAirportsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAirportsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAirportsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfAuditLogListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfAuditLogListDto>;
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuditLogListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | undefined, serviceName: string | undefined, methodName: string | undefined, browserInfo: string | undefined, hasException: boolean | undefined, minExecutionDuration: number | undefined, maxExecutionDuration: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (serviceName === null)
            throw new Error("The parameter 'serviceName' cannot be null.");
        else if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&";
        if (methodName === null)
            throw new Error("The parameter 'methodName' cannot be null.");
        else if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&";
        if (browserInfo === null)
            throw new Error("The parameter 'browserInfo' cannot be null.");
        else if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&";
        if (hasException === null)
            throw new Error("The parameter 'hasException' cannot be null.");
        else if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&";
        if (minExecutionDuration === null)
            throw new Error("The parameter 'minExecutionDuration' cannot be null.");
        else if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&";
        if (maxExecutionDuration === null)
            throw new Error("The parameter 'maxExecutionDuration' cannot be null.");
        else if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueDto[]>;
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | undefined, entityTypeFullName: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | undefined, entityId: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfEntityChangeListDto>;
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: DateTime | undefined, endDate: DateTime | undefined, userName: string | undefined, entityTypeFullName: string | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (userName === null)
            throw new Error("The parameter 'userName' cannot be null.");
        else if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&";
        if (entityTypeFullName === null)
            throw new Error("The parameter 'entityTypeFullName' cannot be null.");
        else if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId === null)
            throw new Error("The parameter 'entityChangeId' cannot be null.");
        else if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EntityPropertyChangeDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EntityPropertyChangeDto[]>;
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfCacheDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfCacheDto>;
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfCacheDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    clearCache(body: EntityDtoOfString | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    canClearAllCaches(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Caching/CanClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCanClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCanClearAllCaches(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processCanClearAllCaches(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserChatFriendsWithSettingsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserChatFriendsWithSettingsOutput>;
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserChatFriendsWithSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | undefined, userId: number | undefined, minMessageId: number | undefined, maxResultCount: number | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (minMessageId === null)
            throw new Error("The parameter 'minMessageId' cannot be null.");
        else if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfChatMessageDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfChatMessageDto>;
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfChatMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(body: MarkAllUnreadMessagesOfUserAsReadInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>;
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDefaultEditionNameOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDefaultEditionNameOutput>;
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CostCentersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param controllingAreaFilter (optional) 
     * @param costCenterNameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param actStateFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param costCenterCodeFilter (optional) 
     * @param costCenterShortFilter (optional) 
     * @param departmentNameFilter (optional) 
     * @param periodFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, controllingAreaFilter: string | undefined, costCenterNameFilter: string | undefined, descriptionFilter: string | undefined, actStateFilter: string | undefined, isActiveFilter: number | undefined, costCenterCodeFilter: string | undefined, costCenterShortFilter: string | undefined, departmentNameFilter: string | undefined, periodFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetCostCenterForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenters/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (controllingAreaFilter === null)
            throw new Error("The parameter 'controllingAreaFilter' cannot be null.");
        else if (controllingAreaFilter !== undefined)
            url_ += "ControllingAreaFilter=" + encodeURIComponent("" + controllingAreaFilter) + "&";
        if (costCenterNameFilter === null)
            throw new Error("The parameter 'costCenterNameFilter' cannot be null.");
        else if (costCenterNameFilter !== undefined)
            url_ += "CostCenterNameFilter=" + encodeURIComponent("" + costCenterNameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (actStateFilter === null)
            throw new Error("The parameter 'actStateFilter' cannot be null.");
        else if (actStateFilter !== undefined)
            url_ += "ActStateFilter=" + encodeURIComponent("" + actStateFilter) + "&";
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&";
        if (costCenterCodeFilter === null)
            throw new Error("The parameter 'costCenterCodeFilter' cannot be null.");
        else if (costCenterCodeFilter !== undefined)
            url_ += "CostCenterCodeFilter=" + encodeURIComponent("" + costCenterCodeFilter) + "&";
        if (costCenterShortFilter === null)
            throw new Error("The parameter 'costCenterShortFilter' cannot be null.");
        else if (costCenterShortFilter !== undefined)
            url_ += "CostCenterShortFilter=" + encodeURIComponent("" + costCenterShortFilter) + "&";
        if (departmentNameFilter === null)
            throw new Error("The parameter 'departmentNameFilter' cannot be null.");
        else if (departmentNameFilter !== undefined)
            url_ += "DepartmentNameFilter=" + encodeURIComponent("" + departmentNameFilter) + "&";
        if (periodFilter === null)
            throw new Error("The parameter 'periodFilter' cannot be null.");
        else if (periodFilter !== undefined)
            url_ += "PeriodFilter=" + encodeURIComponent("" + periodFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetCostCenterForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetCostCenterForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCostCenterForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCostCenterForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCostCenterForView(id: string | undefined): Observable<GetCostCenterForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenters/GetCostCenterForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCostCenterForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCostCenterForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCostCenterForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCostCenterForViewDto>;
        }));
    }

    protected processGetCostCenterForView(response: HttpResponseBase): Observable<GetCostCenterForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCostCenterForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCostCenterForEdit(id: string | undefined): Observable<GetCostCenterForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CostCenters/GetCostCenterForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCostCenterForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCostCenterForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCostCenterForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCostCenterForEditOutput>;
        }));
    }

    protected processGetCostCenterForEdit(response: HttpResponseBase): Observable<GetCostCenterForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCostCenterForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditCostCenterDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CostCenters/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CostCenters/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param controllingAreaFilter (optional) 
     * @param costCenterNameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param actStateFilter (optional) 
     * @param isActiveFilter (optional) 
     * @param costCenterCodeFilter (optional) 
     * @param costCenterShortFilter (optional) 
     * @param departmentNameFilter (optional) 
     * @param periodFilter (optional) 
     * @return Success
     */
    getCostCentersToExcel(filter: string | undefined, controllingAreaFilter: string | undefined, costCenterNameFilter: string | undefined, descriptionFilter: string | undefined, actStateFilter: string | undefined, isActiveFilter: number | undefined, costCenterCodeFilter: string | undefined, costCenterShortFilter: string | undefined, departmentNameFilter: string | undefined, periodFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenters/GetCostCentersToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (controllingAreaFilter === null)
            throw new Error("The parameter 'controllingAreaFilter' cannot be null.");
        else if (controllingAreaFilter !== undefined)
            url_ += "ControllingAreaFilter=" + encodeURIComponent("" + controllingAreaFilter) + "&";
        if (costCenterNameFilter === null)
            throw new Error("The parameter 'costCenterNameFilter' cannot be null.");
        else if (costCenterNameFilter !== undefined)
            url_ += "CostCenterNameFilter=" + encodeURIComponent("" + costCenterNameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (actStateFilter === null)
            throw new Error("The parameter 'actStateFilter' cannot be null.");
        else if (actStateFilter !== undefined)
            url_ += "ActStateFilter=" + encodeURIComponent("" + actStateFilter) + "&";
        if (isActiveFilter === null)
            throw new Error("The parameter 'isActiveFilter' cannot be null.");
        else if (isActiveFilter !== undefined)
            url_ += "IsActiveFilter=" + encodeURIComponent("" + isActiveFilter) + "&";
        if (costCenterCodeFilter === null)
            throw new Error("The parameter 'costCenterCodeFilter' cannot be null.");
        else if (costCenterCodeFilter !== undefined)
            url_ += "CostCenterCodeFilter=" + encodeURIComponent("" + costCenterCodeFilter) + "&";
        if (costCenterShortFilter === null)
            throw new Error("The parameter 'costCenterShortFilter' cannot be null.");
        else if (costCenterShortFilter !== undefined)
            url_ += "CostCenterShortFilter=" + encodeURIComponent("" + costCenterShortFilter) + "&";
        if (departmentNameFilter === null)
            throw new Error("The parameter 'departmentNameFilter' cannot be null.");
        else if (departmentNameFilter !== undefined)
            url_ += "DepartmentNameFilter=" + encodeURIComponent("" + departmentNameFilter) + "&";
        if (periodFilter === null)
            throw new Error("The parameter 'periodFilter' cannot be null.");
        else if (periodFilter !== undefined)
            url_ += "PeriodFilter=" + encodeURIComponent("" + periodFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCostCentersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCostCentersToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetCostCentersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCostCenterFromDepartmentId(id: number | undefined): Observable<GetCostCenterForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CostCenters/GetCostCenterFromDepartmentId?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCostCenterFromDepartmentId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCostCenterFromDepartmentId(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCostCenterForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCostCenterForViewDto>;
        }));
    }

    protected processGetCostCenterFromDepartmentId(response: HttpResponseBase): Observable<GetCostCenterForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCostCenterForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CostCentersSynchServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    synchronizeFromSAP(body: CostCenterSynchDto | undefined): Observable<DtoResponseModel> {
        let url_ = this.baseUrl + "/api/services/app/CostCentersSynchService/SynchronizeFromSAP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSynchronizeFromSAP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSynchronizeFromSAP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DtoResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DtoResponseModel>;
        }));
    }

    protected processSynchronizeFromSAP(response: HttpResponseBase): Observable<DtoResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DtoResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DashboardCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getUserDashboard(dashboardName: string | undefined, application: string | undefined): Observable<Dashboard> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetUserDashboard?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDashboard(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDashboard(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Dashboard>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Dashboard>;
        }));
    }

    protected processGetUserDashboard(response: HttpResponseBase): Observable<Dashboard> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Dashboard.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    savePage(body: SavePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/SavePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSavePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    renamePage(body: RenamePageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/RenamePage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRenamePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRenamePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRenamePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addNewPage(body: AddNewPageInput | undefined): Observable<AddNewPageOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddNewPage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddNewPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddNewPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddNewPageOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddNewPageOutput>;
        }));
    }

    protected processAddNewPage(response: HttpResponseBase): Observable<AddNewPageOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddNewPageOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    deletePage(id: string | undefined, dashboardName: string | undefined, application: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/DeletePage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeletePage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addWidget(body: AddWidgetInput | undefined): Observable<Widget> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/AddWidget";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddWidget(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddWidget(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<Widget>;
                }
            } else
                return _observableThrow(response_) as any as Observable<Widget>;
        }));
    }

    protected processAddWidget(response: HttpResponseBase): Observable<Widget> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Widget.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getDashboardDefinition(dashboardName: string | undefined, application: string | undefined): Observable<DashboardOutput> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetDashboardDefinition?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardDefinition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardDefinition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DashboardOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DashboardOutput>;
        }));
    }

    protected processGetDashboardDefinition(response: HttpResponseBase): Observable<DashboardOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DashboardOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @return Success
     */
    getAllWidgetDefinitions(dashboardName: string | undefined, application: string | undefined): Observable<WidgetOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetAllWidgetDefinitions?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWidgetDefinitions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWidgetDefinitions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetOutput[]>;
        }));
    }

    protected processGetAllWidgetDefinitions(response: HttpResponseBase): Observable<WidgetOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param dashboardName (optional) 
     * @param application (optional) 
     * @param pageId (optional) 
     * @return Success
     */
    getAllAvailableWidgetDefinitionsForPage(dashboardName: string | undefined, application: string | undefined, pageId: string | undefined): Observable<WidgetOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetAllAvailableWidgetDefinitionsForPage?";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "DashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "Application=" + encodeURIComponent("" + application) + "&";
        if (pageId === null)
            throw new Error("The parameter 'pageId' cannot be null.");
        else if (pageId !== undefined)
            url_ += "PageId=" + encodeURIComponent("" + pageId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAvailableWidgetDefinitionsForPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAvailableWidgetDefinitionsForPage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WidgetOutput[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WidgetOutput[]>;
        }));
    }

    protected processGetAllAvailableWidgetDefinitionsForPage(response: HttpResponseBase): Observable<WidgetOutput[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(WidgetOutput.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param application (optional) 
     * @param dashboardName (optional) 
     * @return Success
     */
    getSettingName(application: string | undefined, dashboardName: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/DashboardCustomization/GetSettingName?";
        if (application === null)
            throw new Error("The parameter 'application' cannot be null.");
        else if (application !== undefined)
            url_ += "application=" + encodeURIComponent("" + application) + "&";
        if (dashboardName === null)
            throw new Error("The parameter 'dashboardName' cannot be null.");
        else if (dashboardName !== undefined)
            url_ += "dashboardName=" + encodeURIComponent("" + dashboardName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSettingName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSettingName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetSettingName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DataProductionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param intfIdFilter (optional) 
     * @param intfSiteFilter (optional) 
     * @param intfSessionFilter (optional) 
     * @param objectIdFilter (optional) 
     * @param messageTypeFilter (optional) 
     * @param materialDocumentFilter (optional) 
     * @param maxMaterialDocYearFilter (optional) 
     * @param minMaterialDocYearFilter (optional) 
     * @param maxMaterialDocItemFilter (optional) 
     * @param minMaterialDocItemFilter (optional) 
     * @param orderFilter (optional) 
     * @param maxReservationFilter (optional) 
     * @param minReservationFilter (optional) 
     * @param purchaseOrderFilter (optional) 
     * @param maxPurchaseOrderItemFilter (optional) 
     * @param minPurchaseOrderItemFilter (optional) 
     * @param movementTypeFilter (optional) 
     * @param movementTypeTextFilter (optional) 
     * @param plantFilter (optional) 
     * @param storageLocationFilter (optional) 
     * @param materialFilter (optional) 
     * @param materialDescriptionFilter (optional) 
     * @param vendorFilter (optional) 
     * @param maxQuantityFilter (optional) 
     * @param minQuantityFilter (optional) 
     * @param maxQtyInOrderUnitFilter (optional) 
     * @param minQtyInOrderUnitFilter (optional) 
     * @param unitOfEntryFilter (optional) 
     * @param maxPostingDateFilter (optional) 
     * @param minPostingDateFilter (optional) 
     * @param maxEntryDateFilter (optional) 
     * @param minEntryDateFilter (optional) 
     * @param timeOfEntryFilter (optional) 
     * @param userNameFilter (optional) 
     * @param documentHeaderTextFilter (optional) 
     * @param maxDocumentDateFilter (optional) 
     * @param minDocumentDateFilter (optional) 
     * @param batchFilter (optional) 
     * @param costCenterFilter (optional) 
     * @param referenceFilter (optional) 
     * @param maxInterfaceCreatedDateFilter (optional) 
     * @param minInterfaceCreatedDateFilter (optional) 
     * @param interfaceCreatedByFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, intfIdFilter: string | undefined, intfSiteFilter: string | undefined, intfSessionFilter: string | undefined, objectIdFilter: string | undefined, messageTypeFilter: string | undefined, materialDocumentFilter: string | undefined, maxMaterialDocYearFilter: number | undefined, minMaterialDocYearFilter: number | undefined, maxMaterialDocItemFilter: number | undefined, minMaterialDocItemFilter: number | undefined, orderFilter: string | undefined, maxReservationFilter: number | undefined, minReservationFilter: number | undefined, purchaseOrderFilter: string | undefined, maxPurchaseOrderItemFilter: number | undefined, minPurchaseOrderItemFilter: number | undefined, movementTypeFilter: string | undefined, movementTypeTextFilter: string | undefined, plantFilter: string | undefined, storageLocationFilter: string | undefined, materialFilter: string | undefined, materialDescriptionFilter: string | undefined, vendorFilter: string | undefined, maxQuantityFilter: number | undefined, minQuantityFilter: number | undefined, maxQtyInOrderUnitFilter: number | undefined, minQtyInOrderUnitFilter: number | undefined, unitOfEntryFilter: string | undefined, maxPostingDateFilter: DateTime | undefined, minPostingDateFilter: DateTime | undefined, maxEntryDateFilter: DateTime | undefined, minEntryDateFilter: DateTime | undefined, timeOfEntryFilter: string | undefined, userNameFilter: string | undefined, documentHeaderTextFilter: string | undefined, maxDocumentDateFilter: DateTime | undefined, minDocumentDateFilter: DateTime | undefined, batchFilter: string | undefined, costCenterFilter: string | undefined, referenceFilter: string | undefined, maxInterfaceCreatedDateFilter: DateTime | undefined, minInterfaceCreatedDateFilter: DateTime | undefined, interfaceCreatedByFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetDataProductionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DataProductions/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (intfIdFilter === null)
            throw new Error("The parameter 'intfIdFilter' cannot be null.");
        else if (intfIdFilter !== undefined)
            url_ += "IntfIdFilter=" + encodeURIComponent("" + intfIdFilter) + "&";
        if (intfSiteFilter === null)
            throw new Error("The parameter 'intfSiteFilter' cannot be null.");
        else if (intfSiteFilter !== undefined)
            url_ += "IntfSiteFilter=" + encodeURIComponent("" + intfSiteFilter) + "&";
        if (intfSessionFilter === null)
            throw new Error("The parameter 'intfSessionFilter' cannot be null.");
        else if (intfSessionFilter !== undefined)
            url_ += "IntfSessionFilter=" + encodeURIComponent("" + intfSessionFilter) + "&";
        if (objectIdFilter === null)
            throw new Error("The parameter 'objectIdFilter' cannot be null.");
        else if (objectIdFilter !== undefined)
            url_ += "ObjectIdFilter=" + encodeURIComponent("" + objectIdFilter) + "&";
        if (messageTypeFilter === null)
            throw new Error("The parameter 'messageTypeFilter' cannot be null.");
        else if (messageTypeFilter !== undefined)
            url_ += "MessageTypeFilter=" + encodeURIComponent("" + messageTypeFilter) + "&";
        if (materialDocumentFilter === null)
            throw new Error("The parameter 'materialDocumentFilter' cannot be null.");
        else if (materialDocumentFilter !== undefined)
            url_ += "MaterialDocumentFilter=" + encodeURIComponent("" + materialDocumentFilter) + "&";
        if (maxMaterialDocYearFilter === null)
            throw new Error("The parameter 'maxMaterialDocYearFilter' cannot be null.");
        else if (maxMaterialDocYearFilter !== undefined)
            url_ += "MaxMaterialDocYearFilter=" + encodeURIComponent("" + maxMaterialDocYearFilter) + "&";
        if (minMaterialDocYearFilter === null)
            throw new Error("The parameter 'minMaterialDocYearFilter' cannot be null.");
        else if (minMaterialDocYearFilter !== undefined)
            url_ += "MinMaterialDocYearFilter=" + encodeURIComponent("" + minMaterialDocYearFilter) + "&";
        if (maxMaterialDocItemFilter === null)
            throw new Error("The parameter 'maxMaterialDocItemFilter' cannot be null.");
        else if (maxMaterialDocItemFilter !== undefined)
            url_ += "MaxMaterialDocItemFilter=" + encodeURIComponent("" + maxMaterialDocItemFilter) + "&";
        if (minMaterialDocItemFilter === null)
            throw new Error("The parameter 'minMaterialDocItemFilter' cannot be null.");
        else if (minMaterialDocItemFilter !== undefined)
            url_ += "MinMaterialDocItemFilter=" + encodeURIComponent("" + minMaterialDocItemFilter) + "&";
        if (orderFilter === null)
            throw new Error("The parameter 'orderFilter' cannot be null.");
        else if (orderFilter !== undefined)
            url_ += "OrderFilter=" + encodeURIComponent("" + orderFilter) + "&";
        if (maxReservationFilter === null)
            throw new Error("The parameter 'maxReservationFilter' cannot be null.");
        else if (maxReservationFilter !== undefined)
            url_ += "MaxReservationFilter=" + encodeURIComponent("" + maxReservationFilter) + "&";
        if (minReservationFilter === null)
            throw new Error("The parameter 'minReservationFilter' cannot be null.");
        else if (minReservationFilter !== undefined)
            url_ += "MinReservationFilter=" + encodeURIComponent("" + minReservationFilter) + "&";
        if (purchaseOrderFilter === null)
            throw new Error("The parameter 'purchaseOrderFilter' cannot be null.");
        else if (purchaseOrderFilter !== undefined)
            url_ += "PurchaseOrderFilter=" + encodeURIComponent("" + purchaseOrderFilter) + "&";
        if (maxPurchaseOrderItemFilter === null)
            throw new Error("The parameter 'maxPurchaseOrderItemFilter' cannot be null.");
        else if (maxPurchaseOrderItemFilter !== undefined)
            url_ += "MaxPurchaseOrderItemFilter=" + encodeURIComponent("" + maxPurchaseOrderItemFilter) + "&";
        if (minPurchaseOrderItemFilter === null)
            throw new Error("The parameter 'minPurchaseOrderItemFilter' cannot be null.");
        else if (minPurchaseOrderItemFilter !== undefined)
            url_ += "MinPurchaseOrderItemFilter=" + encodeURIComponent("" + minPurchaseOrderItemFilter) + "&";
        if (movementTypeFilter === null)
            throw new Error("The parameter 'movementTypeFilter' cannot be null.");
        else if (movementTypeFilter !== undefined)
            url_ += "MovementTypeFilter=" + encodeURIComponent("" + movementTypeFilter) + "&";
        if (movementTypeTextFilter === null)
            throw new Error("The parameter 'movementTypeTextFilter' cannot be null.");
        else if (movementTypeTextFilter !== undefined)
            url_ += "MovementTypeTextFilter=" + encodeURIComponent("" + movementTypeTextFilter) + "&";
        if (plantFilter === null)
            throw new Error("The parameter 'plantFilter' cannot be null.");
        else if (plantFilter !== undefined)
            url_ += "PlantFilter=" + encodeURIComponent("" + plantFilter) + "&";
        if (storageLocationFilter === null)
            throw new Error("The parameter 'storageLocationFilter' cannot be null.");
        else if (storageLocationFilter !== undefined)
            url_ += "StorageLocationFilter=" + encodeURIComponent("" + storageLocationFilter) + "&";
        if (materialFilter === null)
            throw new Error("The parameter 'materialFilter' cannot be null.");
        else if (materialFilter !== undefined)
            url_ += "MaterialFilter=" + encodeURIComponent("" + materialFilter) + "&";
        if (materialDescriptionFilter === null)
            throw new Error("The parameter 'materialDescriptionFilter' cannot be null.");
        else if (materialDescriptionFilter !== undefined)
            url_ += "MaterialDescriptionFilter=" + encodeURIComponent("" + materialDescriptionFilter) + "&";
        if (vendorFilter === null)
            throw new Error("The parameter 'vendorFilter' cannot be null.");
        else if (vendorFilter !== undefined)
            url_ += "VendorFilter=" + encodeURIComponent("" + vendorFilter) + "&";
        if (maxQuantityFilter === null)
            throw new Error("The parameter 'maxQuantityFilter' cannot be null.");
        else if (maxQuantityFilter !== undefined)
            url_ += "MaxQuantityFilter=" + encodeURIComponent("" + maxQuantityFilter) + "&";
        if (minQuantityFilter === null)
            throw new Error("The parameter 'minQuantityFilter' cannot be null.");
        else if (minQuantityFilter !== undefined)
            url_ += "MinQuantityFilter=" + encodeURIComponent("" + minQuantityFilter) + "&";
        if (maxQtyInOrderUnitFilter === null)
            throw new Error("The parameter 'maxQtyInOrderUnitFilter' cannot be null.");
        else if (maxQtyInOrderUnitFilter !== undefined)
            url_ += "MaxQtyInOrderUnitFilter=" + encodeURIComponent("" + maxQtyInOrderUnitFilter) + "&";
        if (minQtyInOrderUnitFilter === null)
            throw new Error("The parameter 'minQtyInOrderUnitFilter' cannot be null.");
        else if (minQtyInOrderUnitFilter !== undefined)
            url_ += "MinQtyInOrderUnitFilter=" + encodeURIComponent("" + minQtyInOrderUnitFilter) + "&";
        if (unitOfEntryFilter === null)
            throw new Error("The parameter 'unitOfEntryFilter' cannot be null.");
        else if (unitOfEntryFilter !== undefined)
            url_ += "UnitOfEntryFilter=" + encodeURIComponent("" + unitOfEntryFilter) + "&";
        if (maxPostingDateFilter === null)
            throw new Error("The parameter 'maxPostingDateFilter' cannot be null.");
        else if (maxPostingDateFilter !== undefined)
            url_ += "MaxPostingDateFilter=" + encodeURIComponent(maxPostingDateFilter ? "" + maxPostingDateFilter.toString() : "") + "&";
        if (minPostingDateFilter === null)
            throw new Error("The parameter 'minPostingDateFilter' cannot be null.");
        else if (minPostingDateFilter !== undefined)
            url_ += "MinPostingDateFilter=" + encodeURIComponent(minPostingDateFilter ? "" + minPostingDateFilter.toString() : "") + "&";
        if (maxEntryDateFilter === null)
            throw new Error("The parameter 'maxEntryDateFilter' cannot be null.");
        else if (maxEntryDateFilter !== undefined)
            url_ += "MaxEntryDateFilter=" + encodeURIComponent(maxEntryDateFilter ? "" + maxEntryDateFilter.toString() : "") + "&";
        if (minEntryDateFilter === null)
            throw new Error("The parameter 'minEntryDateFilter' cannot be null.");
        else if (minEntryDateFilter !== undefined)
            url_ += "MinEntryDateFilter=" + encodeURIComponent(minEntryDateFilter ? "" + minEntryDateFilter.toString() : "") + "&";
        if (timeOfEntryFilter === null)
            throw new Error("The parameter 'timeOfEntryFilter' cannot be null.");
        else if (timeOfEntryFilter !== undefined)
            url_ += "TimeOfEntryFilter=" + encodeURIComponent("" + timeOfEntryFilter) + "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        if (documentHeaderTextFilter === null)
            throw new Error("The parameter 'documentHeaderTextFilter' cannot be null.");
        else if (documentHeaderTextFilter !== undefined)
            url_ += "DocumentHeaderTextFilter=" + encodeURIComponent("" + documentHeaderTextFilter) + "&";
        if (maxDocumentDateFilter === null)
            throw new Error("The parameter 'maxDocumentDateFilter' cannot be null.");
        else if (maxDocumentDateFilter !== undefined)
            url_ += "MaxDocumentDateFilter=" + encodeURIComponent(maxDocumentDateFilter ? "" + maxDocumentDateFilter.toString() : "") + "&";
        if (minDocumentDateFilter === null)
            throw new Error("The parameter 'minDocumentDateFilter' cannot be null.");
        else if (minDocumentDateFilter !== undefined)
            url_ += "MinDocumentDateFilter=" + encodeURIComponent(minDocumentDateFilter ? "" + minDocumentDateFilter.toString() : "") + "&";
        if (batchFilter === null)
            throw new Error("The parameter 'batchFilter' cannot be null.");
        else if (batchFilter !== undefined)
            url_ += "BatchFilter=" + encodeURIComponent("" + batchFilter) + "&";
        if (costCenterFilter === null)
            throw new Error("The parameter 'costCenterFilter' cannot be null.");
        else if (costCenterFilter !== undefined)
            url_ += "CostCenterFilter=" + encodeURIComponent("" + costCenterFilter) + "&";
        if (referenceFilter === null)
            throw new Error("The parameter 'referenceFilter' cannot be null.");
        else if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&";
        if (maxInterfaceCreatedDateFilter === null)
            throw new Error("The parameter 'maxInterfaceCreatedDateFilter' cannot be null.");
        else if (maxInterfaceCreatedDateFilter !== undefined)
            url_ += "MaxInterfaceCreatedDateFilter=" + encodeURIComponent(maxInterfaceCreatedDateFilter ? "" + maxInterfaceCreatedDateFilter.toString() : "") + "&";
        if (minInterfaceCreatedDateFilter === null)
            throw new Error("The parameter 'minInterfaceCreatedDateFilter' cannot be null.");
        else if (minInterfaceCreatedDateFilter !== undefined)
            url_ += "MinInterfaceCreatedDateFilter=" + encodeURIComponent(minInterfaceCreatedDateFilter ? "" + minInterfaceCreatedDateFilter.toString() : "") + "&";
        if (interfaceCreatedByFilter === null)
            throw new Error("The parameter 'interfaceCreatedByFilter' cannot be null.");
        else if (interfaceCreatedByFilter !== undefined)
            url_ += "InterfaceCreatedByFilter=" + encodeURIComponent("" + interfaceCreatedByFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetDataProductionForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetDataProductionForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetDataProductionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetDataProductionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDataProductionForView(id: string | undefined): Observable<GetDataProductionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/DataProductions/GetDataProductionForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataProductionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataProductionForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDataProductionForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDataProductionForViewDto>;
        }));
    }

    protected processGetDataProductionForView(response: HttpResponseBase): Observable<GetDataProductionForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDataProductionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getDataProductionForEdit(id: string | undefined): Observable<GetDataProductionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/DataProductions/GetDataProductionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataProductionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataProductionForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDataProductionForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDataProductionForEditOutput>;
        }));
    }

    protected processGetDataProductionForEdit(response: HttpResponseBase): Observable<GetDataProductionForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDataProductionForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditDataProductionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataProductions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DataProductions/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param intfIdFilter (optional) 
     * @param intfSiteFilter (optional) 
     * @param intfSessionFilter (optional) 
     * @param objectIdFilter (optional) 
     * @param messageTypeFilter (optional) 
     * @param materialDocumentFilter (optional) 
     * @param maxMaterialDocYearFilter (optional) 
     * @param minMaterialDocYearFilter (optional) 
     * @param maxMaterialDocItemFilter (optional) 
     * @param minMaterialDocItemFilter (optional) 
     * @param orderFilter (optional) 
     * @param maxReservationFilter (optional) 
     * @param minReservationFilter (optional) 
     * @param purchaseOrderFilter (optional) 
     * @param maxPurchaseOrderItemFilter (optional) 
     * @param minPurchaseOrderItemFilter (optional) 
     * @param movementTypeFilter (optional) 
     * @param movementTypeTextFilter (optional) 
     * @param plantFilter (optional) 
     * @param storageLocationFilter (optional) 
     * @param materialFilter (optional) 
     * @param materialDescriptionFilter (optional) 
     * @param vendorFilter (optional) 
     * @param maxQuantityFilter (optional) 
     * @param minQuantityFilter (optional) 
     * @param maxQtyInOrderUnitFilter (optional) 
     * @param minQtyInOrderUnitFilter (optional) 
     * @param unitOfEntryFilter (optional) 
     * @param maxPostingDateFilter (optional) 
     * @param minPostingDateFilter (optional) 
     * @param maxEntryDateFilter (optional) 
     * @param minEntryDateFilter (optional) 
     * @param timeOfEntryFilter (optional) 
     * @param userNameFilter (optional) 
     * @param documentHeaderTextFilter (optional) 
     * @param maxDocumentDateFilter (optional) 
     * @param minDocumentDateFilter (optional) 
     * @param batchFilter (optional) 
     * @param costCenterFilter (optional) 
     * @param referenceFilter (optional) 
     * @param maxInterfaceCreatedDateFilter (optional) 
     * @param minInterfaceCreatedDateFilter (optional) 
     * @param interfaceCreatedByFilter (optional) 
     * @return Success
     */
    getDataProductionsToExcel(filter: string | undefined, intfIdFilter: string | undefined, intfSiteFilter: string | undefined, intfSessionFilter: string | undefined, objectIdFilter: string | undefined, messageTypeFilter: string | undefined, materialDocumentFilter: string | undefined, maxMaterialDocYearFilter: number | undefined, minMaterialDocYearFilter: number | undefined, maxMaterialDocItemFilter: number | undefined, minMaterialDocItemFilter: number | undefined, orderFilter: string | undefined, maxReservationFilter: number | undefined, minReservationFilter: number | undefined, purchaseOrderFilter: string | undefined, maxPurchaseOrderItemFilter: number | undefined, minPurchaseOrderItemFilter: number | undefined, movementTypeFilter: string | undefined, movementTypeTextFilter: string | undefined, plantFilter: string | undefined, storageLocationFilter: string | undefined, materialFilter: string | undefined, materialDescriptionFilter: string | undefined, vendorFilter: string | undefined, maxQuantityFilter: number | undefined, minQuantityFilter: number | undefined, maxQtyInOrderUnitFilter: number | undefined, minQtyInOrderUnitFilter: number | undefined, unitOfEntryFilter: string | undefined, maxPostingDateFilter: DateTime | undefined, minPostingDateFilter: DateTime | undefined, maxEntryDateFilter: DateTime | undefined, minEntryDateFilter: DateTime | undefined, timeOfEntryFilter: string | undefined, userNameFilter: string | undefined, documentHeaderTextFilter: string | undefined, maxDocumentDateFilter: DateTime | undefined, minDocumentDateFilter: DateTime | undefined, batchFilter: string | undefined, costCenterFilter: string | undefined, referenceFilter: string | undefined, maxInterfaceCreatedDateFilter: DateTime | undefined, minInterfaceCreatedDateFilter: DateTime | undefined, interfaceCreatedByFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/DataProductions/GetDataProductionsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (intfIdFilter === null)
            throw new Error("The parameter 'intfIdFilter' cannot be null.");
        else if (intfIdFilter !== undefined)
            url_ += "IntfIdFilter=" + encodeURIComponent("" + intfIdFilter) + "&";
        if (intfSiteFilter === null)
            throw new Error("The parameter 'intfSiteFilter' cannot be null.");
        else if (intfSiteFilter !== undefined)
            url_ += "IntfSiteFilter=" + encodeURIComponent("" + intfSiteFilter) + "&";
        if (intfSessionFilter === null)
            throw new Error("The parameter 'intfSessionFilter' cannot be null.");
        else if (intfSessionFilter !== undefined)
            url_ += "IntfSessionFilter=" + encodeURIComponent("" + intfSessionFilter) + "&";
        if (objectIdFilter === null)
            throw new Error("The parameter 'objectIdFilter' cannot be null.");
        else if (objectIdFilter !== undefined)
            url_ += "ObjectIdFilter=" + encodeURIComponent("" + objectIdFilter) + "&";
        if (messageTypeFilter === null)
            throw new Error("The parameter 'messageTypeFilter' cannot be null.");
        else if (messageTypeFilter !== undefined)
            url_ += "MessageTypeFilter=" + encodeURIComponent("" + messageTypeFilter) + "&";
        if (materialDocumentFilter === null)
            throw new Error("The parameter 'materialDocumentFilter' cannot be null.");
        else if (materialDocumentFilter !== undefined)
            url_ += "MaterialDocumentFilter=" + encodeURIComponent("" + materialDocumentFilter) + "&";
        if (maxMaterialDocYearFilter === null)
            throw new Error("The parameter 'maxMaterialDocYearFilter' cannot be null.");
        else if (maxMaterialDocYearFilter !== undefined)
            url_ += "MaxMaterialDocYearFilter=" + encodeURIComponent("" + maxMaterialDocYearFilter) + "&";
        if (minMaterialDocYearFilter === null)
            throw new Error("The parameter 'minMaterialDocYearFilter' cannot be null.");
        else if (minMaterialDocYearFilter !== undefined)
            url_ += "MinMaterialDocYearFilter=" + encodeURIComponent("" + minMaterialDocYearFilter) + "&";
        if (maxMaterialDocItemFilter === null)
            throw new Error("The parameter 'maxMaterialDocItemFilter' cannot be null.");
        else if (maxMaterialDocItemFilter !== undefined)
            url_ += "MaxMaterialDocItemFilter=" + encodeURIComponent("" + maxMaterialDocItemFilter) + "&";
        if (minMaterialDocItemFilter === null)
            throw new Error("The parameter 'minMaterialDocItemFilter' cannot be null.");
        else if (minMaterialDocItemFilter !== undefined)
            url_ += "MinMaterialDocItemFilter=" + encodeURIComponent("" + minMaterialDocItemFilter) + "&";
        if (orderFilter === null)
            throw new Error("The parameter 'orderFilter' cannot be null.");
        else if (orderFilter !== undefined)
            url_ += "OrderFilter=" + encodeURIComponent("" + orderFilter) + "&";
        if (maxReservationFilter === null)
            throw new Error("The parameter 'maxReservationFilter' cannot be null.");
        else if (maxReservationFilter !== undefined)
            url_ += "MaxReservationFilter=" + encodeURIComponent("" + maxReservationFilter) + "&";
        if (minReservationFilter === null)
            throw new Error("The parameter 'minReservationFilter' cannot be null.");
        else if (minReservationFilter !== undefined)
            url_ += "MinReservationFilter=" + encodeURIComponent("" + minReservationFilter) + "&";
        if (purchaseOrderFilter === null)
            throw new Error("The parameter 'purchaseOrderFilter' cannot be null.");
        else if (purchaseOrderFilter !== undefined)
            url_ += "PurchaseOrderFilter=" + encodeURIComponent("" + purchaseOrderFilter) + "&";
        if (maxPurchaseOrderItemFilter === null)
            throw new Error("The parameter 'maxPurchaseOrderItemFilter' cannot be null.");
        else if (maxPurchaseOrderItemFilter !== undefined)
            url_ += "MaxPurchaseOrderItemFilter=" + encodeURIComponent("" + maxPurchaseOrderItemFilter) + "&";
        if (minPurchaseOrderItemFilter === null)
            throw new Error("The parameter 'minPurchaseOrderItemFilter' cannot be null.");
        else if (minPurchaseOrderItemFilter !== undefined)
            url_ += "MinPurchaseOrderItemFilter=" + encodeURIComponent("" + minPurchaseOrderItemFilter) + "&";
        if (movementTypeFilter === null)
            throw new Error("The parameter 'movementTypeFilter' cannot be null.");
        else if (movementTypeFilter !== undefined)
            url_ += "MovementTypeFilter=" + encodeURIComponent("" + movementTypeFilter) + "&";
        if (movementTypeTextFilter === null)
            throw new Error("The parameter 'movementTypeTextFilter' cannot be null.");
        else if (movementTypeTextFilter !== undefined)
            url_ += "MovementTypeTextFilter=" + encodeURIComponent("" + movementTypeTextFilter) + "&";
        if (plantFilter === null)
            throw new Error("The parameter 'plantFilter' cannot be null.");
        else if (plantFilter !== undefined)
            url_ += "PlantFilter=" + encodeURIComponent("" + plantFilter) + "&";
        if (storageLocationFilter === null)
            throw new Error("The parameter 'storageLocationFilter' cannot be null.");
        else if (storageLocationFilter !== undefined)
            url_ += "StorageLocationFilter=" + encodeURIComponent("" + storageLocationFilter) + "&";
        if (materialFilter === null)
            throw new Error("The parameter 'materialFilter' cannot be null.");
        else if (materialFilter !== undefined)
            url_ += "MaterialFilter=" + encodeURIComponent("" + materialFilter) + "&";
        if (materialDescriptionFilter === null)
            throw new Error("The parameter 'materialDescriptionFilter' cannot be null.");
        else if (materialDescriptionFilter !== undefined)
            url_ += "MaterialDescriptionFilter=" + encodeURIComponent("" + materialDescriptionFilter) + "&";
        if (vendorFilter === null)
            throw new Error("The parameter 'vendorFilter' cannot be null.");
        else if (vendorFilter !== undefined)
            url_ += "VendorFilter=" + encodeURIComponent("" + vendorFilter) + "&";
        if (maxQuantityFilter === null)
            throw new Error("The parameter 'maxQuantityFilter' cannot be null.");
        else if (maxQuantityFilter !== undefined)
            url_ += "MaxQuantityFilter=" + encodeURIComponent("" + maxQuantityFilter) + "&";
        if (minQuantityFilter === null)
            throw new Error("The parameter 'minQuantityFilter' cannot be null.");
        else if (minQuantityFilter !== undefined)
            url_ += "MinQuantityFilter=" + encodeURIComponent("" + minQuantityFilter) + "&";
        if (maxQtyInOrderUnitFilter === null)
            throw new Error("The parameter 'maxQtyInOrderUnitFilter' cannot be null.");
        else if (maxQtyInOrderUnitFilter !== undefined)
            url_ += "MaxQtyInOrderUnitFilter=" + encodeURIComponent("" + maxQtyInOrderUnitFilter) + "&";
        if (minQtyInOrderUnitFilter === null)
            throw new Error("The parameter 'minQtyInOrderUnitFilter' cannot be null.");
        else if (minQtyInOrderUnitFilter !== undefined)
            url_ += "MinQtyInOrderUnitFilter=" + encodeURIComponent("" + minQtyInOrderUnitFilter) + "&";
        if (unitOfEntryFilter === null)
            throw new Error("The parameter 'unitOfEntryFilter' cannot be null.");
        else if (unitOfEntryFilter !== undefined)
            url_ += "UnitOfEntryFilter=" + encodeURIComponent("" + unitOfEntryFilter) + "&";
        if (maxPostingDateFilter === null)
            throw new Error("The parameter 'maxPostingDateFilter' cannot be null.");
        else if (maxPostingDateFilter !== undefined)
            url_ += "MaxPostingDateFilter=" + encodeURIComponent(maxPostingDateFilter ? "" + maxPostingDateFilter.toString() : "") + "&";
        if (minPostingDateFilter === null)
            throw new Error("The parameter 'minPostingDateFilter' cannot be null.");
        else if (minPostingDateFilter !== undefined)
            url_ += "MinPostingDateFilter=" + encodeURIComponent(minPostingDateFilter ? "" + minPostingDateFilter.toString() : "") + "&";
        if (maxEntryDateFilter === null)
            throw new Error("The parameter 'maxEntryDateFilter' cannot be null.");
        else if (maxEntryDateFilter !== undefined)
            url_ += "MaxEntryDateFilter=" + encodeURIComponent(maxEntryDateFilter ? "" + maxEntryDateFilter.toString() : "") + "&";
        if (minEntryDateFilter === null)
            throw new Error("The parameter 'minEntryDateFilter' cannot be null.");
        else if (minEntryDateFilter !== undefined)
            url_ += "MinEntryDateFilter=" + encodeURIComponent(minEntryDateFilter ? "" + minEntryDateFilter.toString() : "") + "&";
        if (timeOfEntryFilter === null)
            throw new Error("The parameter 'timeOfEntryFilter' cannot be null.");
        else if (timeOfEntryFilter !== undefined)
            url_ += "TimeOfEntryFilter=" + encodeURIComponent("" + timeOfEntryFilter) + "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        if (documentHeaderTextFilter === null)
            throw new Error("The parameter 'documentHeaderTextFilter' cannot be null.");
        else if (documentHeaderTextFilter !== undefined)
            url_ += "DocumentHeaderTextFilter=" + encodeURIComponent("" + documentHeaderTextFilter) + "&";
        if (maxDocumentDateFilter === null)
            throw new Error("The parameter 'maxDocumentDateFilter' cannot be null.");
        else if (maxDocumentDateFilter !== undefined)
            url_ += "MaxDocumentDateFilter=" + encodeURIComponent(maxDocumentDateFilter ? "" + maxDocumentDateFilter.toString() : "") + "&";
        if (minDocumentDateFilter === null)
            throw new Error("The parameter 'minDocumentDateFilter' cannot be null.");
        else if (minDocumentDateFilter !== undefined)
            url_ += "MinDocumentDateFilter=" + encodeURIComponent(minDocumentDateFilter ? "" + minDocumentDateFilter.toString() : "") + "&";
        if (batchFilter === null)
            throw new Error("The parameter 'batchFilter' cannot be null.");
        else if (batchFilter !== undefined)
            url_ += "BatchFilter=" + encodeURIComponent("" + batchFilter) + "&";
        if (costCenterFilter === null)
            throw new Error("The parameter 'costCenterFilter' cannot be null.");
        else if (costCenterFilter !== undefined)
            url_ += "CostCenterFilter=" + encodeURIComponent("" + costCenterFilter) + "&";
        if (referenceFilter === null)
            throw new Error("The parameter 'referenceFilter' cannot be null.");
        else if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&";
        if (maxInterfaceCreatedDateFilter === null)
            throw new Error("The parameter 'maxInterfaceCreatedDateFilter' cannot be null.");
        else if (maxInterfaceCreatedDateFilter !== undefined)
            url_ += "MaxInterfaceCreatedDateFilter=" + encodeURIComponent(maxInterfaceCreatedDateFilter ? "" + maxInterfaceCreatedDateFilter.toString() : "") + "&";
        if (minInterfaceCreatedDateFilter === null)
            throw new Error("The parameter 'minInterfaceCreatedDateFilter' cannot be null.");
        else if (minInterfaceCreatedDateFilter !== undefined)
            url_ += "MinInterfaceCreatedDateFilter=" + encodeURIComponent(minInterfaceCreatedDateFilter ? "" + minInterfaceCreatedDateFilter.toString() : "") + "&";
        if (interfaceCreatedByFilter === null)
            throw new Error("The parameter 'interfaceCreatedByFilter' cannot be null.");
        else if (interfaceCreatedByFilter !== undefined)
            url_ += "InterfaceCreatedByFilter=" + encodeURIComponent("" + interfaceCreatedByFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataProductionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataProductionsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetDataProductionsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: DateTime | undefined): Observable<DateFieldOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateFieldOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateFieldOutput>;
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateFieldOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateFieldOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: DateTime | undefined): Observable<DateFieldOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date === null)
            throw new Error("The parameter 'date' cannot be null.");
        else if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateFieldOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateFieldOutput>;
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateFieldOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateFieldOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<DateRangeFieldOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateRangeFieldOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateRangeFieldOutput>;
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateRangeFieldOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateRangeFieldOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAndGetDateWithText(body: SendAndGetDateWithTextInput | undefined): Observable<DateWithTextFieldOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateWithText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateWithText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateWithText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DateWithTextFieldOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DateWithTextFieldOutput>;
        }));
    }

    protected processSendAndGetDateWithText(response: HttpResponseBase): Observable<DateWithTextFieldOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateWithTextFieldOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm === null)
            throw new Error("The parameter 'searchTerm' cannot be null.");
        else if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueOfString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueOfString[]>;
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(body: NameValueOfString[] | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<NameValueOfString[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<NameValueOfString[]>;
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input === null)
            throw new Error("The parameter 'input' cannot be null.");
        else if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringOutput>;
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DynamicEntityPropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicEntityPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicEntityPropertyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityFullName (optional) 
     * @return Success
     */
    getAllPropertiesOfAnEntity(entityFullName: string | undefined): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAllPropertiesOfAnEntity?";
        if (entityFullName === null)
            throw new Error("The parameter 'entityFullName' cannot be null.");
        else if (entityFullName !== undefined)
            url_ += "EntityFullName=" + encodeURIComponent("" + entityFullName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPropertiesOfAnEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPropertiesOfAnEntity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
        }));
    }

    protected processGetAllPropertiesOfAnEntity(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicEntityPropertyDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicEntityPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicEntityPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllEntitiesHasDynamicProperty(): Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityProperty/GetAllEntitiesHasDynamicProperty";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntitiesHasDynamicProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntitiesHasDynamicProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput>;
        }));
    }

    protected processGetAllEntitiesHasDynamicProperty(response: HttpResponseBase): Observable<ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DynamicEntityPropertyDefinitionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllAllowedInputTypeNames(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyDefinition/GetAllAllowedInputTypeNames";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAllowedInputTypeNames(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAllowedInputTypeNames(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAllAllowedInputTypeNames(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllEntities(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyDefinition/GetAllEntities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEntities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEntities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAllEntities(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DynamicEntityPropertyValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicEntityPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicEntityPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicEntityPropertyValueDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicEntityPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicEntityPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param entityId (optional) 
     * @param propertyId (optional) 
     * @return Success
     */
    getAll(entityId: string | undefined, propertyId: number | undefined): Observable<ListResultDtoOfDynamicEntityPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/GetAll?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicEntityPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicEntityPropertyValueDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicEntityPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicEntityPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicEntityPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicEntityPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllDynamicEntityPropertyValues(entityFullName: string, entityId: string): Observable<GetAllDynamicEntityPropertyValuesOutput> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/GetAllDynamicEntityPropertyValues?";
        if (entityFullName === undefined || entityFullName === null)
            throw new Error("The parameter 'entityFullName' must be defined and cannot be null.");
        else
            url_ += "EntityFullName=" + encodeURIComponent("" + entityFullName) + "&";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined and cannot be null.");
        else
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDynamicEntityPropertyValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDynamicEntityPropertyValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllDynamicEntityPropertyValuesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllDynamicEntityPropertyValuesOutput>;
        }));
    }

    protected processGetAllDynamicEntityPropertyValues(response: HttpResponseBase): Observable<GetAllDynamicEntityPropertyValuesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllDynamicEntityPropertyValuesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    insertOrUpdateAllValues(body: InsertOrUpdateAllValuesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/InsertOrUpdateAllValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInsertOrUpdateAllValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInsertOrUpdateAllValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processInsertOrUpdateAllValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cleanValues(body: CleanValuesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicEntityPropertyValue/CleanValues";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCleanValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCleanValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCleanValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DynamicPropertyServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPropertyDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<ListResultDtoOfDynamicPropertyDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicPropertyDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicPropertyDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ListResultDtoOfDynamicPropertyDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicPropertyDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicPropertyDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @return Success
     */
    findAllowedInputType(name: string | undefined): Observable<IInputType> {
        let url_ = this.baseUrl + "/api/services/app/DynamicProperty/FindAllowedInputType?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindAllowedInputType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindAllowedInputType(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IInputType>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IInputType>;
        }));
    }

    protected processFindAllowedInputType(response: HttpResponseBase): Observable<IInputType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IInputType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DynamicPropertyValueServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: number | undefined): Observable<DynamicPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DynamicPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DynamicPropertyValueDto>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DynamicPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DynamicPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllValuesOfDynamicProperty(id: number | undefined): Observable<ListResultDtoOfDynamicPropertyValueDto> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/GetAllValuesOfDynamicProperty?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllValuesOfDynamicProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllValuesOfDynamicProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfDynamicPropertyValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfDynamicPropertyValueDto>;
        }));
    }

    protected processGetAllValuesOfDynamicProperty(response: HttpResponseBase): Observable<ListResultDtoOfDynamicPropertyValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfDynamicPropertyValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    add(body: DynamicPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Add";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAdd(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body: DynamicPropertyValueDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/DynamicPropertyValue/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfEditionListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfEditionListDto>;
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfEditionListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEditionEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEditionEditOutput>;
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createEdition(body: CreateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateEdition(body: UpdateEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(body: MoveTenantsToAnotherEditionDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | undefined, addAllItem: boolean | undefined, onlyFreeItems: boolean | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId === null)
            throw new Error("The parameter 'selectedEditionId' cannot be null.");
        else if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&";
        if (addAllItem === null)
            throw new Error("The parameter 'addAllItem' cannot be null.");
        else if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&";
        if (onlyFreeItems === null)
            throw new Error("The parameter 'onlyFreeItems' cannot be null.");
        else if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscribableEditionComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscribableEditionComboboxItemDto[]>;
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EKKOsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param mANDTFilter (optional) 
     * @param eBELNFilter (optional) 
     * @param bUKRSFilter (optional) 
     * @param bSTYPFilter (optional) 
     * @param bSARTFilter (optional) 
     * @param bSAKZFilter (optional) 
     * @param lOEKZFilter (optional) 
     * @param sTATUFilter (optional) 
     * @param maxAEDATFilter (optional) 
     * @param minAEDATFilter (optional) 
     * @param eRNAMFilter (optional) 
     * @param maxPINCRFilter (optional) 
     * @param minPINCRFilter (optional) 
     * @param maxLPONRFilter (optional) 
     * @param minLPONRFilter (optional) 
     * @param lIFNRFilter (optional) 
     * @param zTERMFilter (optional) 
     * @param maxZBD1TFilter (optional) 
     * @param minZBD1TFilter (optional) 
     * @param maxZBD2TFilter (optional) 
     * @param minZBD2TFilter (optional) 
     * @param maxZBD3TFilter (optional) 
     * @param minZBD3TFilter (optional) 
     * @param maxZBD1PFilter (optional) 
     * @param minZBD1PFilter (optional) 
     * @param maxZBD2PFilter (optional) 
     * @param minZBD2PFilter (optional) 
     * @param eKORGFilter (optional) 
     * @param eKGRPFilter (optional) 
     * @param wAERSFilter (optional) 
     * @param maxWKURSFilter (optional) 
     * @param minWKURSFilter (optional) 
     * @param kUFIXFilter (optional) 
     * @param maxBEDATFilter (optional) 
     * @param minBEDATFilter (optional) 
     * @param maxKDATBFilter (optional) 
     * @param minKDATBFilter (optional) 
     * @param maxKDATEFilter (optional) 
     * @param minKDATEFilter (optional) 
     * @param maxBWBDTFilter (optional) 
     * @param minBWBDTFilter (optional) 
     * @param maxGWLDTFilter (optional) 
     * @param minGWLDTFilter (optional) 
     * @param maxIHRANFilter (optional) 
     * @param minIHRANFilter (optional) 
     * @param kUNNRFilter (optional) 
     * @param kONNRFilter (optional) 
     * @param aBGRUFilter (optional) 
     * @param aUTLFFilter (optional) 
     * @param wEAKTFilter (optional) 
     * @param rESWKFilter (optional) 
     * @param lBLIFFilter (optional) 
     * @param iNCO1Filter (optional) 
     * @param iNCO2Filter (optional) 
     * @param sUBMIFilter (optional) 
     * @param kNUMVFilter (optional) 
     * @param kALSMFilter (optional) 
     * @param pROCSTATFilter (optional) 
     * @param uNSEZFilter (optional) 
     * @param fRGGRFilter (optional) 
     * @param fRGSXFilter (optional) 
     * @param fRGKEFilter (optional) 
     * @param fRGZUFilter (optional) 
     * @param aDRNRFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, mANDTFilter: string | undefined, eBELNFilter: string | undefined, bUKRSFilter: string | undefined, bSTYPFilter: string | undefined, bSARTFilter: string | undefined, bSAKZFilter: string | undefined, lOEKZFilter: string | undefined, sTATUFilter: string | undefined, maxAEDATFilter: DateTime | undefined, minAEDATFilter: DateTime | undefined, eRNAMFilter: string | undefined, maxPINCRFilter: number | undefined, minPINCRFilter: number | undefined, maxLPONRFilter: number | undefined, minLPONRFilter: number | undefined, lIFNRFilter: string | undefined, zTERMFilter: string | undefined, maxZBD1TFilter: number | undefined, minZBD1TFilter: number | undefined, maxZBD2TFilter: number | undefined, minZBD2TFilter: number | undefined, maxZBD3TFilter: number | undefined, minZBD3TFilter: number | undefined, maxZBD1PFilter: number | undefined, minZBD1PFilter: number | undefined, maxZBD2PFilter: number | undefined, minZBD2PFilter: number | undefined, eKORGFilter: string | undefined, eKGRPFilter: string | undefined, wAERSFilter: string | undefined, maxWKURSFilter: number | undefined, minWKURSFilter: number | undefined, kUFIXFilter: string | undefined, maxBEDATFilter: DateTime | undefined, minBEDATFilter: DateTime | undefined, maxKDATBFilter: DateTime | undefined, minKDATBFilter: DateTime | undefined, maxKDATEFilter: DateTime | undefined, minKDATEFilter: DateTime | undefined, maxBWBDTFilter: DateTime | undefined, minBWBDTFilter: DateTime | undefined, maxGWLDTFilter: DateTime | undefined, minGWLDTFilter: DateTime | undefined, maxIHRANFilter: DateTime | undefined, minIHRANFilter: DateTime | undefined, kUNNRFilter: string | undefined, kONNRFilter: string | undefined, aBGRUFilter: string | undefined, aUTLFFilter: string | undefined, wEAKTFilter: string | undefined, rESWKFilter: string | undefined, lBLIFFilter: string | undefined, iNCO1Filter: string | undefined, iNCO2Filter: string | undefined, sUBMIFilter: string | undefined, kNUMVFilter: string | undefined, kALSMFilter: string | undefined, pROCSTATFilter: string | undefined, uNSEZFilter: string | undefined, fRGGRFilter: string | undefined, fRGSXFilter: string | undefined, fRGKEFilter: string | undefined, fRGZUFilter: string | undefined, aDRNRFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetEkkoForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EKKOs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (mANDTFilter === null)
            throw new Error("The parameter 'mANDTFilter' cannot be null.");
        else if (mANDTFilter !== undefined)
            url_ += "MANDTFilter=" + encodeURIComponent("" + mANDTFilter) + "&";
        if (eBELNFilter === null)
            throw new Error("The parameter 'eBELNFilter' cannot be null.");
        else if (eBELNFilter !== undefined)
            url_ += "EBELNFilter=" + encodeURIComponent("" + eBELNFilter) + "&";
        if (bUKRSFilter === null)
            throw new Error("The parameter 'bUKRSFilter' cannot be null.");
        else if (bUKRSFilter !== undefined)
            url_ += "BUKRSFilter=" + encodeURIComponent("" + bUKRSFilter) + "&";
        if (bSTYPFilter === null)
            throw new Error("The parameter 'bSTYPFilter' cannot be null.");
        else if (bSTYPFilter !== undefined)
            url_ += "BSTYPFilter=" + encodeURIComponent("" + bSTYPFilter) + "&";
        if (bSARTFilter === null)
            throw new Error("The parameter 'bSARTFilter' cannot be null.");
        else if (bSARTFilter !== undefined)
            url_ += "BSARTFilter=" + encodeURIComponent("" + bSARTFilter) + "&";
        if (bSAKZFilter === null)
            throw new Error("The parameter 'bSAKZFilter' cannot be null.");
        else if (bSAKZFilter !== undefined)
            url_ += "BSAKZFilter=" + encodeURIComponent("" + bSAKZFilter) + "&";
        if (lOEKZFilter === null)
            throw new Error("The parameter 'lOEKZFilter' cannot be null.");
        else if (lOEKZFilter !== undefined)
            url_ += "LOEKZFilter=" + encodeURIComponent("" + lOEKZFilter) + "&";
        if (sTATUFilter === null)
            throw new Error("The parameter 'sTATUFilter' cannot be null.");
        else if (sTATUFilter !== undefined)
            url_ += "STATUFilter=" + encodeURIComponent("" + sTATUFilter) + "&";
        if (maxAEDATFilter === null)
            throw new Error("The parameter 'maxAEDATFilter' cannot be null.");
        else if (maxAEDATFilter !== undefined)
            url_ += "MaxAEDATFilter=" + encodeURIComponent(maxAEDATFilter ? "" + maxAEDATFilter.toString() : "") + "&";
        if (minAEDATFilter === null)
            throw new Error("The parameter 'minAEDATFilter' cannot be null.");
        else if (minAEDATFilter !== undefined)
            url_ += "MinAEDATFilter=" + encodeURIComponent(minAEDATFilter ? "" + minAEDATFilter.toString() : "") + "&";
        if (eRNAMFilter === null)
            throw new Error("The parameter 'eRNAMFilter' cannot be null.");
        else if (eRNAMFilter !== undefined)
            url_ += "ERNAMFilter=" + encodeURIComponent("" + eRNAMFilter) + "&";
        if (maxPINCRFilter === null)
            throw new Error("The parameter 'maxPINCRFilter' cannot be null.");
        else if (maxPINCRFilter !== undefined)
            url_ += "MaxPINCRFilter=" + encodeURIComponent("" + maxPINCRFilter) + "&";
        if (minPINCRFilter === null)
            throw new Error("The parameter 'minPINCRFilter' cannot be null.");
        else if (minPINCRFilter !== undefined)
            url_ += "MinPINCRFilter=" + encodeURIComponent("" + minPINCRFilter) + "&";
        if (maxLPONRFilter === null)
            throw new Error("The parameter 'maxLPONRFilter' cannot be null.");
        else if (maxLPONRFilter !== undefined)
            url_ += "MaxLPONRFilter=" + encodeURIComponent("" + maxLPONRFilter) + "&";
        if (minLPONRFilter === null)
            throw new Error("The parameter 'minLPONRFilter' cannot be null.");
        else if (minLPONRFilter !== undefined)
            url_ += "MinLPONRFilter=" + encodeURIComponent("" + minLPONRFilter) + "&";
        if (lIFNRFilter === null)
            throw new Error("The parameter 'lIFNRFilter' cannot be null.");
        else if (lIFNRFilter !== undefined)
            url_ += "LIFNRFilter=" + encodeURIComponent("" + lIFNRFilter) + "&";
        if (zTERMFilter === null)
            throw new Error("The parameter 'zTERMFilter' cannot be null.");
        else if (zTERMFilter !== undefined)
            url_ += "ZTERMFilter=" + encodeURIComponent("" + zTERMFilter) + "&";
        if (maxZBD1TFilter === null)
            throw new Error("The parameter 'maxZBD1TFilter' cannot be null.");
        else if (maxZBD1TFilter !== undefined)
            url_ += "MaxZBD1TFilter=" + encodeURIComponent("" + maxZBD1TFilter) + "&";
        if (minZBD1TFilter === null)
            throw new Error("The parameter 'minZBD1TFilter' cannot be null.");
        else if (minZBD1TFilter !== undefined)
            url_ += "MinZBD1TFilter=" + encodeURIComponent("" + minZBD1TFilter) + "&";
        if (maxZBD2TFilter === null)
            throw new Error("The parameter 'maxZBD2TFilter' cannot be null.");
        else if (maxZBD2TFilter !== undefined)
            url_ += "MaxZBD2TFilter=" + encodeURIComponent("" + maxZBD2TFilter) + "&";
        if (minZBD2TFilter === null)
            throw new Error("The parameter 'minZBD2TFilter' cannot be null.");
        else if (minZBD2TFilter !== undefined)
            url_ += "MinZBD2TFilter=" + encodeURIComponent("" + minZBD2TFilter) + "&";
        if (maxZBD3TFilter === null)
            throw new Error("The parameter 'maxZBD3TFilter' cannot be null.");
        else if (maxZBD3TFilter !== undefined)
            url_ += "MaxZBD3TFilter=" + encodeURIComponent("" + maxZBD3TFilter) + "&";
        if (minZBD3TFilter === null)
            throw new Error("The parameter 'minZBD3TFilter' cannot be null.");
        else if (minZBD3TFilter !== undefined)
            url_ += "MinZBD3TFilter=" + encodeURIComponent("" + minZBD3TFilter) + "&";
        if (maxZBD1PFilter === null)
            throw new Error("The parameter 'maxZBD1PFilter' cannot be null.");
        else if (maxZBD1PFilter !== undefined)
            url_ += "MaxZBD1PFilter=" + encodeURIComponent("" + maxZBD1PFilter) + "&";
        if (minZBD1PFilter === null)
            throw new Error("The parameter 'minZBD1PFilter' cannot be null.");
        else if (minZBD1PFilter !== undefined)
            url_ += "MinZBD1PFilter=" + encodeURIComponent("" + minZBD1PFilter) + "&";
        if (maxZBD2PFilter === null)
            throw new Error("The parameter 'maxZBD2PFilter' cannot be null.");
        else if (maxZBD2PFilter !== undefined)
            url_ += "MaxZBD2PFilter=" + encodeURIComponent("" + maxZBD2PFilter) + "&";
        if (minZBD2PFilter === null)
            throw new Error("The parameter 'minZBD2PFilter' cannot be null.");
        else if (minZBD2PFilter !== undefined)
            url_ += "MinZBD2PFilter=" + encodeURIComponent("" + minZBD2PFilter) + "&";
        if (eKORGFilter === null)
            throw new Error("The parameter 'eKORGFilter' cannot be null.");
        else if (eKORGFilter !== undefined)
            url_ += "EKORGFilter=" + encodeURIComponent("" + eKORGFilter) + "&";
        if (eKGRPFilter === null)
            throw new Error("The parameter 'eKGRPFilter' cannot be null.");
        else if (eKGRPFilter !== undefined)
            url_ += "EKGRPFilter=" + encodeURIComponent("" + eKGRPFilter) + "&";
        if (wAERSFilter === null)
            throw new Error("The parameter 'wAERSFilter' cannot be null.");
        else if (wAERSFilter !== undefined)
            url_ += "WAERSFilter=" + encodeURIComponent("" + wAERSFilter) + "&";
        if (maxWKURSFilter === null)
            throw new Error("The parameter 'maxWKURSFilter' cannot be null.");
        else if (maxWKURSFilter !== undefined)
            url_ += "MaxWKURSFilter=" + encodeURIComponent("" + maxWKURSFilter) + "&";
        if (minWKURSFilter === null)
            throw new Error("The parameter 'minWKURSFilter' cannot be null.");
        else if (minWKURSFilter !== undefined)
            url_ += "MinWKURSFilter=" + encodeURIComponent("" + minWKURSFilter) + "&";
        if (kUFIXFilter === null)
            throw new Error("The parameter 'kUFIXFilter' cannot be null.");
        else if (kUFIXFilter !== undefined)
            url_ += "KUFIXFilter=" + encodeURIComponent("" + kUFIXFilter) + "&";
        if (maxBEDATFilter === null)
            throw new Error("The parameter 'maxBEDATFilter' cannot be null.");
        else if (maxBEDATFilter !== undefined)
            url_ += "MaxBEDATFilter=" + encodeURIComponent(maxBEDATFilter ? "" + maxBEDATFilter.toString() : "") + "&";
        if (minBEDATFilter === null)
            throw new Error("The parameter 'minBEDATFilter' cannot be null.");
        else if (minBEDATFilter !== undefined)
            url_ += "MinBEDATFilter=" + encodeURIComponent(minBEDATFilter ? "" + minBEDATFilter.toString() : "") + "&";
        if (maxKDATBFilter === null)
            throw new Error("The parameter 'maxKDATBFilter' cannot be null.");
        else if (maxKDATBFilter !== undefined)
            url_ += "MaxKDATBFilter=" + encodeURIComponent(maxKDATBFilter ? "" + maxKDATBFilter.toString() : "") + "&";
        if (minKDATBFilter === null)
            throw new Error("The parameter 'minKDATBFilter' cannot be null.");
        else if (minKDATBFilter !== undefined)
            url_ += "MinKDATBFilter=" + encodeURIComponent(minKDATBFilter ? "" + minKDATBFilter.toString() : "") + "&";
        if (maxKDATEFilter === null)
            throw new Error("The parameter 'maxKDATEFilter' cannot be null.");
        else if (maxKDATEFilter !== undefined)
            url_ += "MaxKDATEFilter=" + encodeURIComponent(maxKDATEFilter ? "" + maxKDATEFilter.toString() : "") + "&";
        if (minKDATEFilter === null)
            throw new Error("The parameter 'minKDATEFilter' cannot be null.");
        else if (minKDATEFilter !== undefined)
            url_ += "MinKDATEFilter=" + encodeURIComponent(minKDATEFilter ? "" + minKDATEFilter.toString() : "") + "&";
        if (maxBWBDTFilter === null)
            throw new Error("The parameter 'maxBWBDTFilter' cannot be null.");
        else if (maxBWBDTFilter !== undefined)
            url_ += "MaxBWBDTFilter=" + encodeURIComponent(maxBWBDTFilter ? "" + maxBWBDTFilter.toString() : "") + "&";
        if (minBWBDTFilter === null)
            throw new Error("The parameter 'minBWBDTFilter' cannot be null.");
        else if (minBWBDTFilter !== undefined)
            url_ += "MinBWBDTFilter=" + encodeURIComponent(minBWBDTFilter ? "" + minBWBDTFilter.toString() : "") + "&";
        if (maxGWLDTFilter === null)
            throw new Error("The parameter 'maxGWLDTFilter' cannot be null.");
        else if (maxGWLDTFilter !== undefined)
            url_ += "MaxGWLDTFilter=" + encodeURIComponent(maxGWLDTFilter ? "" + maxGWLDTFilter.toString() : "") + "&";
        if (minGWLDTFilter === null)
            throw new Error("The parameter 'minGWLDTFilter' cannot be null.");
        else if (minGWLDTFilter !== undefined)
            url_ += "MinGWLDTFilter=" + encodeURIComponent(minGWLDTFilter ? "" + minGWLDTFilter.toString() : "") + "&";
        if (maxIHRANFilter === null)
            throw new Error("The parameter 'maxIHRANFilter' cannot be null.");
        else if (maxIHRANFilter !== undefined)
            url_ += "MaxIHRANFilter=" + encodeURIComponent(maxIHRANFilter ? "" + maxIHRANFilter.toString() : "") + "&";
        if (minIHRANFilter === null)
            throw new Error("The parameter 'minIHRANFilter' cannot be null.");
        else if (minIHRANFilter !== undefined)
            url_ += "MinIHRANFilter=" + encodeURIComponent(minIHRANFilter ? "" + minIHRANFilter.toString() : "") + "&";
        if (kUNNRFilter === null)
            throw new Error("The parameter 'kUNNRFilter' cannot be null.");
        else if (kUNNRFilter !== undefined)
            url_ += "KUNNRFilter=" + encodeURIComponent("" + kUNNRFilter) + "&";
        if (kONNRFilter === null)
            throw new Error("The parameter 'kONNRFilter' cannot be null.");
        else if (kONNRFilter !== undefined)
            url_ += "KONNRFilter=" + encodeURIComponent("" + kONNRFilter) + "&";
        if (aBGRUFilter === null)
            throw new Error("The parameter 'aBGRUFilter' cannot be null.");
        else if (aBGRUFilter !== undefined)
            url_ += "ABGRUFilter=" + encodeURIComponent("" + aBGRUFilter) + "&";
        if (aUTLFFilter === null)
            throw new Error("The parameter 'aUTLFFilter' cannot be null.");
        else if (aUTLFFilter !== undefined)
            url_ += "AUTLFFilter=" + encodeURIComponent("" + aUTLFFilter) + "&";
        if (wEAKTFilter === null)
            throw new Error("The parameter 'wEAKTFilter' cannot be null.");
        else if (wEAKTFilter !== undefined)
            url_ += "WEAKTFilter=" + encodeURIComponent("" + wEAKTFilter) + "&";
        if (rESWKFilter === null)
            throw new Error("The parameter 'rESWKFilter' cannot be null.");
        else if (rESWKFilter !== undefined)
            url_ += "RESWKFilter=" + encodeURIComponent("" + rESWKFilter) + "&";
        if (lBLIFFilter === null)
            throw new Error("The parameter 'lBLIFFilter' cannot be null.");
        else if (lBLIFFilter !== undefined)
            url_ += "LBLIFFilter=" + encodeURIComponent("" + lBLIFFilter) + "&";
        if (iNCO1Filter === null)
            throw new Error("The parameter 'iNCO1Filter' cannot be null.");
        else if (iNCO1Filter !== undefined)
            url_ += "INCO1Filter=" + encodeURIComponent("" + iNCO1Filter) + "&";
        if (iNCO2Filter === null)
            throw new Error("The parameter 'iNCO2Filter' cannot be null.");
        else if (iNCO2Filter !== undefined)
            url_ += "INCO2Filter=" + encodeURIComponent("" + iNCO2Filter) + "&";
        if (sUBMIFilter === null)
            throw new Error("The parameter 'sUBMIFilter' cannot be null.");
        else if (sUBMIFilter !== undefined)
            url_ += "SUBMIFilter=" + encodeURIComponent("" + sUBMIFilter) + "&";
        if (kNUMVFilter === null)
            throw new Error("The parameter 'kNUMVFilter' cannot be null.");
        else if (kNUMVFilter !== undefined)
            url_ += "KNUMVFilter=" + encodeURIComponent("" + kNUMVFilter) + "&";
        if (kALSMFilter === null)
            throw new Error("The parameter 'kALSMFilter' cannot be null.");
        else if (kALSMFilter !== undefined)
            url_ += "KALSMFilter=" + encodeURIComponent("" + kALSMFilter) + "&";
        if (pROCSTATFilter === null)
            throw new Error("The parameter 'pROCSTATFilter' cannot be null.");
        else if (pROCSTATFilter !== undefined)
            url_ += "PROCSTATFilter=" + encodeURIComponent("" + pROCSTATFilter) + "&";
        if (uNSEZFilter === null)
            throw new Error("The parameter 'uNSEZFilter' cannot be null.");
        else if (uNSEZFilter !== undefined)
            url_ += "UNSEZFilter=" + encodeURIComponent("" + uNSEZFilter) + "&";
        if (fRGGRFilter === null)
            throw new Error("The parameter 'fRGGRFilter' cannot be null.");
        else if (fRGGRFilter !== undefined)
            url_ += "FRGGRFilter=" + encodeURIComponent("" + fRGGRFilter) + "&";
        if (fRGSXFilter === null)
            throw new Error("The parameter 'fRGSXFilter' cannot be null.");
        else if (fRGSXFilter !== undefined)
            url_ += "FRGSXFilter=" + encodeURIComponent("" + fRGSXFilter) + "&";
        if (fRGKEFilter === null)
            throw new Error("The parameter 'fRGKEFilter' cannot be null.");
        else if (fRGKEFilter !== undefined)
            url_ += "FRGKEFilter=" + encodeURIComponent("" + fRGKEFilter) + "&";
        if (fRGZUFilter === null)
            throw new Error("The parameter 'fRGZUFilter' cannot be null.");
        else if (fRGZUFilter !== undefined)
            url_ += "FRGZUFilter=" + encodeURIComponent("" + fRGZUFilter) + "&";
        if (aDRNRFilter === null)
            throw new Error("The parameter 'aDRNRFilter' cannot be null.");
        else if (aDRNRFilter !== undefined)
            url_ += "ADRNRFilter=" + encodeURIComponent("" + aDRNRFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetEkkoForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetEkkoForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEkkoForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetEkkoForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEkkoForView(id: string | undefined): Observable<GetEkkoForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EKKOs/GetEkkoForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEkkoForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEkkoForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEkkoForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEkkoForViewDto>;
        }));
    }

    protected processGetEkkoForView(response: HttpResponseBase): Observable<GetEkkoForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEkkoForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEkkoForEdit(id: string | undefined): Observable<GetEkkoForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/EKKOs/GetEkkoForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEkkoForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEkkoForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEkkoForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEkkoForEditOutput>;
        }));
    }

    protected processGetEkkoForEdit(response: HttpResponseBase): Observable<GetEkkoForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEkkoForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditEkkoDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EKKOs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EKKOs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param mANDTFilter (optional) 
     * @param eBELNFilter (optional) 
     * @param bUKRSFilter (optional) 
     * @param bSTYPFilter (optional) 
     * @param bSARTFilter (optional) 
     * @param bSAKZFilter (optional) 
     * @param lOEKZFilter (optional) 
     * @param sTATUFilter (optional) 
     * @param maxAEDATFilter (optional) 
     * @param minAEDATFilter (optional) 
     * @param eRNAMFilter (optional) 
     * @param maxPINCRFilter (optional) 
     * @param minPINCRFilter (optional) 
     * @param maxLPONRFilter (optional) 
     * @param minLPONRFilter (optional) 
     * @param lIFNRFilter (optional) 
     * @param zTERMFilter (optional) 
     * @param maxZBD1TFilter (optional) 
     * @param minZBD1TFilter (optional) 
     * @param maxZBD2TFilter (optional) 
     * @param minZBD2TFilter (optional) 
     * @param maxZBD3TFilter (optional) 
     * @param minZBD3TFilter (optional) 
     * @param maxZBD1PFilter (optional) 
     * @param minZBD1PFilter (optional) 
     * @param maxZBD2PFilter (optional) 
     * @param minZBD2PFilter (optional) 
     * @param eKORGFilter (optional) 
     * @param eKGRPFilter (optional) 
     * @param wAERSFilter (optional) 
     * @param maxWKURSFilter (optional) 
     * @param minWKURSFilter (optional) 
     * @param kUFIXFilter (optional) 
     * @param maxBEDATFilter (optional) 
     * @param minBEDATFilter (optional) 
     * @param maxKDATBFilter (optional) 
     * @param minKDATBFilter (optional) 
     * @param maxKDATEFilter (optional) 
     * @param minKDATEFilter (optional) 
     * @param maxBWBDTFilter (optional) 
     * @param minBWBDTFilter (optional) 
     * @param maxGWLDTFilter (optional) 
     * @param minGWLDTFilter (optional) 
     * @param maxIHRANFilter (optional) 
     * @param minIHRANFilter (optional) 
     * @param kUNNRFilter (optional) 
     * @param kONNRFilter (optional) 
     * @param aBGRUFilter (optional) 
     * @param aUTLFFilter (optional) 
     * @param wEAKTFilter (optional) 
     * @param rESWKFilter (optional) 
     * @param lBLIFFilter (optional) 
     * @param iNCO1Filter (optional) 
     * @param iNCO2Filter (optional) 
     * @param sUBMIFilter (optional) 
     * @param kNUMVFilter (optional) 
     * @param kALSMFilter (optional) 
     * @param pROCSTATFilter (optional) 
     * @param uNSEZFilter (optional) 
     * @param fRGGRFilter (optional) 
     * @param fRGSXFilter (optional) 
     * @param fRGKEFilter (optional) 
     * @param fRGZUFilter (optional) 
     * @param aDRNRFilter (optional) 
     * @return Success
     */
    getEkkosToExcel(filter: string | undefined, mANDTFilter: string | undefined, eBELNFilter: string | undefined, bUKRSFilter: string | undefined, bSTYPFilter: string | undefined, bSARTFilter: string | undefined, bSAKZFilter: string | undefined, lOEKZFilter: string | undefined, sTATUFilter: string | undefined, maxAEDATFilter: DateTime | undefined, minAEDATFilter: DateTime | undefined, eRNAMFilter: string | undefined, maxPINCRFilter: number | undefined, minPINCRFilter: number | undefined, maxLPONRFilter: number | undefined, minLPONRFilter: number | undefined, lIFNRFilter: string | undefined, zTERMFilter: string | undefined, maxZBD1TFilter: number | undefined, minZBD1TFilter: number | undefined, maxZBD2TFilter: number | undefined, minZBD2TFilter: number | undefined, maxZBD3TFilter: number | undefined, minZBD3TFilter: number | undefined, maxZBD1PFilter: number | undefined, minZBD1PFilter: number | undefined, maxZBD2PFilter: number | undefined, minZBD2PFilter: number | undefined, eKORGFilter: string | undefined, eKGRPFilter: string | undefined, wAERSFilter: string | undefined, maxWKURSFilter: number | undefined, minWKURSFilter: number | undefined, kUFIXFilter: string | undefined, maxBEDATFilter: DateTime | undefined, minBEDATFilter: DateTime | undefined, maxKDATBFilter: DateTime | undefined, minKDATBFilter: DateTime | undefined, maxKDATEFilter: DateTime | undefined, minKDATEFilter: DateTime | undefined, maxBWBDTFilter: DateTime | undefined, minBWBDTFilter: DateTime | undefined, maxGWLDTFilter: DateTime | undefined, minGWLDTFilter: DateTime | undefined, maxIHRANFilter: DateTime | undefined, minIHRANFilter: DateTime | undefined, kUNNRFilter: string | undefined, kONNRFilter: string | undefined, aBGRUFilter: string | undefined, aUTLFFilter: string | undefined, wEAKTFilter: string | undefined, rESWKFilter: string | undefined, lBLIFFilter: string | undefined, iNCO1Filter: string | undefined, iNCO2Filter: string | undefined, sUBMIFilter: string | undefined, kNUMVFilter: string | undefined, kALSMFilter: string | undefined, pROCSTATFilter: string | undefined, uNSEZFilter: string | undefined, fRGGRFilter: string | undefined, fRGSXFilter: string | undefined, fRGKEFilter: string | undefined, fRGZUFilter: string | undefined, aDRNRFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/EKKOs/GetEkkosToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (mANDTFilter === null)
            throw new Error("The parameter 'mANDTFilter' cannot be null.");
        else if (mANDTFilter !== undefined)
            url_ += "MANDTFilter=" + encodeURIComponent("" + mANDTFilter) + "&";
        if (eBELNFilter === null)
            throw new Error("The parameter 'eBELNFilter' cannot be null.");
        else if (eBELNFilter !== undefined)
            url_ += "EBELNFilter=" + encodeURIComponent("" + eBELNFilter) + "&";
        if (bUKRSFilter === null)
            throw new Error("The parameter 'bUKRSFilter' cannot be null.");
        else if (bUKRSFilter !== undefined)
            url_ += "BUKRSFilter=" + encodeURIComponent("" + bUKRSFilter) + "&";
        if (bSTYPFilter === null)
            throw new Error("The parameter 'bSTYPFilter' cannot be null.");
        else if (bSTYPFilter !== undefined)
            url_ += "BSTYPFilter=" + encodeURIComponent("" + bSTYPFilter) + "&";
        if (bSARTFilter === null)
            throw new Error("The parameter 'bSARTFilter' cannot be null.");
        else if (bSARTFilter !== undefined)
            url_ += "BSARTFilter=" + encodeURIComponent("" + bSARTFilter) + "&";
        if (bSAKZFilter === null)
            throw new Error("The parameter 'bSAKZFilter' cannot be null.");
        else if (bSAKZFilter !== undefined)
            url_ += "BSAKZFilter=" + encodeURIComponent("" + bSAKZFilter) + "&";
        if (lOEKZFilter === null)
            throw new Error("The parameter 'lOEKZFilter' cannot be null.");
        else if (lOEKZFilter !== undefined)
            url_ += "LOEKZFilter=" + encodeURIComponent("" + lOEKZFilter) + "&";
        if (sTATUFilter === null)
            throw new Error("The parameter 'sTATUFilter' cannot be null.");
        else if (sTATUFilter !== undefined)
            url_ += "STATUFilter=" + encodeURIComponent("" + sTATUFilter) + "&";
        if (maxAEDATFilter === null)
            throw new Error("The parameter 'maxAEDATFilter' cannot be null.");
        else if (maxAEDATFilter !== undefined)
            url_ += "MaxAEDATFilter=" + encodeURIComponent(maxAEDATFilter ? "" + maxAEDATFilter.toString() : "") + "&";
        if (minAEDATFilter === null)
            throw new Error("The parameter 'minAEDATFilter' cannot be null.");
        else if (minAEDATFilter !== undefined)
            url_ += "MinAEDATFilter=" + encodeURIComponent(minAEDATFilter ? "" + minAEDATFilter.toString() : "") + "&";
        if (eRNAMFilter === null)
            throw new Error("The parameter 'eRNAMFilter' cannot be null.");
        else if (eRNAMFilter !== undefined)
            url_ += "ERNAMFilter=" + encodeURIComponent("" + eRNAMFilter) + "&";
        if (maxPINCRFilter === null)
            throw new Error("The parameter 'maxPINCRFilter' cannot be null.");
        else if (maxPINCRFilter !== undefined)
            url_ += "MaxPINCRFilter=" + encodeURIComponent("" + maxPINCRFilter) + "&";
        if (minPINCRFilter === null)
            throw new Error("The parameter 'minPINCRFilter' cannot be null.");
        else if (minPINCRFilter !== undefined)
            url_ += "MinPINCRFilter=" + encodeURIComponent("" + minPINCRFilter) + "&";
        if (maxLPONRFilter === null)
            throw new Error("The parameter 'maxLPONRFilter' cannot be null.");
        else if (maxLPONRFilter !== undefined)
            url_ += "MaxLPONRFilter=" + encodeURIComponent("" + maxLPONRFilter) + "&";
        if (minLPONRFilter === null)
            throw new Error("The parameter 'minLPONRFilter' cannot be null.");
        else if (minLPONRFilter !== undefined)
            url_ += "MinLPONRFilter=" + encodeURIComponent("" + minLPONRFilter) + "&";
        if (lIFNRFilter === null)
            throw new Error("The parameter 'lIFNRFilter' cannot be null.");
        else if (lIFNRFilter !== undefined)
            url_ += "LIFNRFilter=" + encodeURIComponent("" + lIFNRFilter) + "&";
        if (zTERMFilter === null)
            throw new Error("The parameter 'zTERMFilter' cannot be null.");
        else if (zTERMFilter !== undefined)
            url_ += "ZTERMFilter=" + encodeURIComponent("" + zTERMFilter) + "&";
        if (maxZBD1TFilter === null)
            throw new Error("The parameter 'maxZBD1TFilter' cannot be null.");
        else if (maxZBD1TFilter !== undefined)
            url_ += "MaxZBD1TFilter=" + encodeURIComponent("" + maxZBD1TFilter) + "&";
        if (minZBD1TFilter === null)
            throw new Error("The parameter 'minZBD1TFilter' cannot be null.");
        else if (minZBD1TFilter !== undefined)
            url_ += "MinZBD1TFilter=" + encodeURIComponent("" + minZBD1TFilter) + "&";
        if (maxZBD2TFilter === null)
            throw new Error("The parameter 'maxZBD2TFilter' cannot be null.");
        else if (maxZBD2TFilter !== undefined)
            url_ += "MaxZBD2TFilter=" + encodeURIComponent("" + maxZBD2TFilter) + "&";
        if (minZBD2TFilter === null)
            throw new Error("The parameter 'minZBD2TFilter' cannot be null.");
        else if (minZBD2TFilter !== undefined)
            url_ += "MinZBD2TFilter=" + encodeURIComponent("" + minZBD2TFilter) + "&";
        if (maxZBD3TFilter === null)
            throw new Error("The parameter 'maxZBD3TFilter' cannot be null.");
        else if (maxZBD3TFilter !== undefined)
            url_ += "MaxZBD3TFilter=" + encodeURIComponent("" + maxZBD3TFilter) + "&";
        if (minZBD3TFilter === null)
            throw new Error("The parameter 'minZBD3TFilter' cannot be null.");
        else if (minZBD3TFilter !== undefined)
            url_ += "MinZBD3TFilter=" + encodeURIComponent("" + minZBD3TFilter) + "&";
        if (maxZBD1PFilter === null)
            throw new Error("The parameter 'maxZBD1PFilter' cannot be null.");
        else if (maxZBD1PFilter !== undefined)
            url_ += "MaxZBD1PFilter=" + encodeURIComponent("" + maxZBD1PFilter) + "&";
        if (minZBD1PFilter === null)
            throw new Error("The parameter 'minZBD1PFilter' cannot be null.");
        else if (minZBD1PFilter !== undefined)
            url_ += "MinZBD1PFilter=" + encodeURIComponent("" + minZBD1PFilter) + "&";
        if (maxZBD2PFilter === null)
            throw new Error("The parameter 'maxZBD2PFilter' cannot be null.");
        else if (maxZBD2PFilter !== undefined)
            url_ += "MaxZBD2PFilter=" + encodeURIComponent("" + maxZBD2PFilter) + "&";
        if (minZBD2PFilter === null)
            throw new Error("The parameter 'minZBD2PFilter' cannot be null.");
        else if (minZBD2PFilter !== undefined)
            url_ += "MinZBD2PFilter=" + encodeURIComponent("" + minZBD2PFilter) + "&";
        if (eKORGFilter === null)
            throw new Error("The parameter 'eKORGFilter' cannot be null.");
        else if (eKORGFilter !== undefined)
            url_ += "EKORGFilter=" + encodeURIComponent("" + eKORGFilter) + "&";
        if (eKGRPFilter === null)
            throw new Error("The parameter 'eKGRPFilter' cannot be null.");
        else if (eKGRPFilter !== undefined)
            url_ += "EKGRPFilter=" + encodeURIComponent("" + eKGRPFilter) + "&";
        if (wAERSFilter === null)
            throw new Error("The parameter 'wAERSFilter' cannot be null.");
        else if (wAERSFilter !== undefined)
            url_ += "WAERSFilter=" + encodeURIComponent("" + wAERSFilter) + "&";
        if (maxWKURSFilter === null)
            throw new Error("The parameter 'maxWKURSFilter' cannot be null.");
        else if (maxWKURSFilter !== undefined)
            url_ += "MaxWKURSFilter=" + encodeURIComponent("" + maxWKURSFilter) + "&";
        if (minWKURSFilter === null)
            throw new Error("The parameter 'minWKURSFilter' cannot be null.");
        else if (minWKURSFilter !== undefined)
            url_ += "MinWKURSFilter=" + encodeURIComponent("" + minWKURSFilter) + "&";
        if (kUFIXFilter === null)
            throw new Error("The parameter 'kUFIXFilter' cannot be null.");
        else if (kUFIXFilter !== undefined)
            url_ += "KUFIXFilter=" + encodeURIComponent("" + kUFIXFilter) + "&";
        if (maxBEDATFilter === null)
            throw new Error("The parameter 'maxBEDATFilter' cannot be null.");
        else if (maxBEDATFilter !== undefined)
            url_ += "MaxBEDATFilter=" + encodeURIComponent(maxBEDATFilter ? "" + maxBEDATFilter.toString() : "") + "&";
        if (minBEDATFilter === null)
            throw new Error("The parameter 'minBEDATFilter' cannot be null.");
        else if (minBEDATFilter !== undefined)
            url_ += "MinBEDATFilter=" + encodeURIComponent(minBEDATFilter ? "" + minBEDATFilter.toString() : "") + "&";
        if (maxKDATBFilter === null)
            throw new Error("The parameter 'maxKDATBFilter' cannot be null.");
        else if (maxKDATBFilter !== undefined)
            url_ += "MaxKDATBFilter=" + encodeURIComponent(maxKDATBFilter ? "" + maxKDATBFilter.toString() : "") + "&";
        if (minKDATBFilter === null)
            throw new Error("The parameter 'minKDATBFilter' cannot be null.");
        else if (minKDATBFilter !== undefined)
            url_ += "MinKDATBFilter=" + encodeURIComponent(minKDATBFilter ? "" + minKDATBFilter.toString() : "") + "&";
        if (maxKDATEFilter === null)
            throw new Error("The parameter 'maxKDATEFilter' cannot be null.");
        else if (maxKDATEFilter !== undefined)
            url_ += "MaxKDATEFilter=" + encodeURIComponent(maxKDATEFilter ? "" + maxKDATEFilter.toString() : "") + "&";
        if (minKDATEFilter === null)
            throw new Error("The parameter 'minKDATEFilter' cannot be null.");
        else if (minKDATEFilter !== undefined)
            url_ += "MinKDATEFilter=" + encodeURIComponent(minKDATEFilter ? "" + minKDATEFilter.toString() : "") + "&";
        if (maxBWBDTFilter === null)
            throw new Error("The parameter 'maxBWBDTFilter' cannot be null.");
        else if (maxBWBDTFilter !== undefined)
            url_ += "MaxBWBDTFilter=" + encodeURIComponent(maxBWBDTFilter ? "" + maxBWBDTFilter.toString() : "") + "&";
        if (minBWBDTFilter === null)
            throw new Error("The parameter 'minBWBDTFilter' cannot be null.");
        else if (minBWBDTFilter !== undefined)
            url_ += "MinBWBDTFilter=" + encodeURIComponent(minBWBDTFilter ? "" + minBWBDTFilter.toString() : "") + "&";
        if (maxGWLDTFilter === null)
            throw new Error("The parameter 'maxGWLDTFilter' cannot be null.");
        else if (maxGWLDTFilter !== undefined)
            url_ += "MaxGWLDTFilter=" + encodeURIComponent(maxGWLDTFilter ? "" + maxGWLDTFilter.toString() : "") + "&";
        if (minGWLDTFilter === null)
            throw new Error("The parameter 'minGWLDTFilter' cannot be null.");
        else if (minGWLDTFilter !== undefined)
            url_ += "MinGWLDTFilter=" + encodeURIComponent(minGWLDTFilter ? "" + minGWLDTFilter.toString() : "") + "&";
        if (maxIHRANFilter === null)
            throw new Error("The parameter 'maxIHRANFilter' cannot be null.");
        else if (maxIHRANFilter !== undefined)
            url_ += "MaxIHRANFilter=" + encodeURIComponent(maxIHRANFilter ? "" + maxIHRANFilter.toString() : "") + "&";
        if (minIHRANFilter === null)
            throw new Error("The parameter 'minIHRANFilter' cannot be null.");
        else if (minIHRANFilter !== undefined)
            url_ += "MinIHRANFilter=" + encodeURIComponent(minIHRANFilter ? "" + minIHRANFilter.toString() : "") + "&";
        if (kUNNRFilter === null)
            throw new Error("The parameter 'kUNNRFilter' cannot be null.");
        else if (kUNNRFilter !== undefined)
            url_ += "KUNNRFilter=" + encodeURIComponent("" + kUNNRFilter) + "&";
        if (kONNRFilter === null)
            throw new Error("The parameter 'kONNRFilter' cannot be null.");
        else if (kONNRFilter !== undefined)
            url_ += "KONNRFilter=" + encodeURIComponent("" + kONNRFilter) + "&";
        if (aBGRUFilter === null)
            throw new Error("The parameter 'aBGRUFilter' cannot be null.");
        else if (aBGRUFilter !== undefined)
            url_ += "ABGRUFilter=" + encodeURIComponent("" + aBGRUFilter) + "&";
        if (aUTLFFilter === null)
            throw new Error("The parameter 'aUTLFFilter' cannot be null.");
        else if (aUTLFFilter !== undefined)
            url_ += "AUTLFFilter=" + encodeURIComponent("" + aUTLFFilter) + "&";
        if (wEAKTFilter === null)
            throw new Error("The parameter 'wEAKTFilter' cannot be null.");
        else if (wEAKTFilter !== undefined)
            url_ += "WEAKTFilter=" + encodeURIComponent("" + wEAKTFilter) + "&";
        if (rESWKFilter === null)
            throw new Error("The parameter 'rESWKFilter' cannot be null.");
        else if (rESWKFilter !== undefined)
            url_ += "RESWKFilter=" + encodeURIComponent("" + rESWKFilter) + "&";
        if (lBLIFFilter === null)
            throw new Error("The parameter 'lBLIFFilter' cannot be null.");
        else if (lBLIFFilter !== undefined)
            url_ += "LBLIFFilter=" + encodeURIComponent("" + lBLIFFilter) + "&";
        if (iNCO1Filter === null)
            throw new Error("The parameter 'iNCO1Filter' cannot be null.");
        else if (iNCO1Filter !== undefined)
            url_ += "INCO1Filter=" + encodeURIComponent("" + iNCO1Filter) + "&";
        if (iNCO2Filter === null)
            throw new Error("The parameter 'iNCO2Filter' cannot be null.");
        else if (iNCO2Filter !== undefined)
            url_ += "INCO2Filter=" + encodeURIComponent("" + iNCO2Filter) + "&";
        if (sUBMIFilter === null)
            throw new Error("The parameter 'sUBMIFilter' cannot be null.");
        else if (sUBMIFilter !== undefined)
            url_ += "SUBMIFilter=" + encodeURIComponent("" + sUBMIFilter) + "&";
        if (kNUMVFilter === null)
            throw new Error("The parameter 'kNUMVFilter' cannot be null.");
        else if (kNUMVFilter !== undefined)
            url_ += "KNUMVFilter=" + encodeURIComponent("" + kNUMVFilter) + "&";
        if (kALSMFilter === null)
            throw new Error("The parameter 'kALSMFilter' cannot be null.");
        else if (kALSMFilter !== undefined)
            url_ += "KALSMFilter=" + encodeURIComponent("" + kALSMFilter) + "&";
        if (pROCSTATFilter === null)
            throw new Error("The parameter 'pROCSTATFilter' cannot be null.");
        else if (pROCSTATFilter !== undefined)
            url_ += "PROCSTATFilter=" + encodeURIComponent("" + pROCSTATFilter) + "&";
        if (uNSEZFilter === null)
            throw new Error("The parameter 'uNSEZFilter' cannot be null.");
        else if (uNSEZFilter !== undefined)
            url_ += "UNSEZFilter=" + encodeURIComponent("" + uNSEZFilter) + "&";
        if (fRGGRFilter === null)
            throw new Error("The parameter 'fRGGRFilter' cannot be null.");
        else if (fRGGRFilter !== undefined)
            url_ += "FRGGRFilter=" + encodeURIComponent("" + fRGGRFilter) + "&";
        if (fRGSXFilter === null)
            throw new Error("The parameter 'fRGSXFilter' cannot be null.");
        else if (fRGSXFilter !== undefined)
            url_ += "FRGSXFilter=" + encodeURIComponent("" + fRGSXFilter) + "&";
        if (fRGKEFilter === null)
            throw new Error("The parameter 'fRGKEFilter' cannot be null.");
        else if (fRGKEFilter !== undefined)
            url_ += "FRGKEFilter=" + encodeURIComponent("" + fRGKEFilter) + "&";
        if (fRGZUFilter === null)
            throw new Error("The parameter 'fRGZUFilter' cannot be null.");
        else if (fRGZUFilter !== undefined)
            url_ += "FRGZUFilter=" + encodeURIComponent("" + fRGZUFilter) + "&";
        if (aDRNRFilter === null)
            throw new Error("The parameter 'aDRNRFilter' cannot be null.");
        else if (aDRNRFilter !== undefined)
            url_ += "ADRNRFilter=" + encodeURIComponent("" + aDRNRFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEkkosToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEkkosToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetEkkosToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EKPOsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param mANDTFilter (optional) 
     * @param eBELNFilter (optional) 
     * @param maxEBELPFilter (optional) 
     * @param minEBELPFilter (optional) 
     * @param uNIQUEIDFilter (optional) 
     * @param lOEKZFilter (optional) 
     * @param sTATUFilter (optional) 
     * @param maxAEDATFilter (optional) 
     * @param minAEDATFilter (optional) 
     * @param tXZ01Filter (optional) 
     * @param mATNRFilter (optional) 
     * @param eMATNFilter (optional) 
     * @param bUKRSFilter (optional) 
     * @param wERKSFilter (optional) 
     * @param lGORTFilter (optional) 
     * @param bEDNRFilter (optional) 
     * @param mATKLFilter (optional) 
     * @param iNFNRFilter (optional) 
     * @param iDNLFFilter (optional) 
     * @param maxKTMNGFilter (optional) 
     * @param minKTMNGFilter (optional) 
     * @param maxMENGEFilter (optional) 
     * @param minMENGEFilter (optional) 
     * @param mEINSFilter (optional) 
     * @param bPRMEFilter (optional) 
     * @param maxBPUMZFilter (optional) 
     * @param minBPUMZFilter (optional) 
     * @param maxBPUMNFilter (optional) 
     * @param minBPUMNFilter (optional) 
     * @param maxUMREZFilter (optional) 
     * @param minUMREZFilter (optional) 
     * @param maxUMRENFilter (optional) 
     * @param minUMRENFilter (optional) 
     * @param maxNETPRFilter (optional) 
     * @param minNETPRFilter (optional) 
     * @param maxPEINHFilter (optional) 
     * @param minPEINHFilter (optional) 
     * @param maxNETWRFilter (optional) 
     * @param minNETWRFilter (optional) 
     * @param maxBRTWRFilter (optional) 
     * @param minBRTWRFilter (optional) 
     * @param maxAGDATFilter (optional) 
     * @param minAGDATFilter (optional) 
     * @param maxWEBAZFilter (optional) 
     * @param minWEBAZFilter (optional) 
     * @param mWSKZFilter (optional) 
     * @param bONUSFilter (optional) 
     * @param iNSMKFilter (optional) 
     * @param sPINFFilter (optional) 
     * @param pRSDRFilter (optional) 
     * @param bWTARFilter (optional) 
     * @param bWTTYFilter (optional) 
     * @param aBSKZFilter (optional) 
     * @param pSTYPFilter (optional) 
     * @param kNTTPFilter (optional) 
     * @param kONNRFilter (optional) 
     * @param maxKTPNRFilter (optional) 
     * @param minKTPNRFilter (optional) 
     * @param maxPACKNOFilter (optional) 
     * @param minPACKNOFilter (optional) 
     * @param aNFNRFilter (optional) 
     * @param bANFNFilter (optional) 
     * @param maxBNFPOFilter (optional) 
     * @param minBNFPOFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, mANDTFilter: string | undefined, eBELNFilter: string | undefined, maxEBELPFilter: number | undefined, minEBELPFilter: number | undefined, uNIQUEIDFilter: string | undefined, lOEKZFilter: string | undefined, sTATUFilter: string | undefined, maxAEDATFilter: DateTime | undefined, minAEDATFilter: DateTime | undefined, tXZ01Filter: string | undefined, mATNRFilter: string | undefined, eMATNFilter: string | undefined, bUKRSFilter: string | undefined, wERKSFilter: string | undefined, lGORTFilter: string | undefined, bEDNRFilter: string | undefined, mATKLFilter: string | undefined, iNFNRFilter: string | undefined, iDNLFFilter: string | undefined, maxKTMNGFilter: number | undefined, minKTMNGFilter: number | undefined, maxMENGEFilter: number | undefined, minMENGEFilter: number | undefined, mEINSFilter: string | undefined, bPRMEFilter: string | undefined, maxBPUMZFilter: number | undefined, minBPUMZFilter: number | undefined, maxBPUMNFilter: number | undefined, minBPUMNFilter: number | undefined, maxUMREZFilter: number | undefined, minUMREZFilter: number | undefined, maxUMRENFilter: number | undefined, minUMRENFilter: number | undefined, maxNETPRFilter: number | undefined, minNETPRFilter: number | undefined, maxPEINHFilter: number | undefined, minPEINHFilter: number | undefined, maxNETWRFilter: number | undefined, minNETWRFilter: number | undefined, maxBRTWRFilter: number | undefined, minBRTWRFilter: number | undefined, maxAGDATFilter: DateTime | undefined, minAGDATFilter: DateTime | undefined, maxWEBAZFilter: number | undefined, minWEBAZFilter: number | undefined, mWSKZFilter: string | undefined, bONUSFilter: string | undefined, iNSMKFilter: string | undefined, sPINFFilter: string | undefined, pRSDRFilter: string | undefined, bWTARFilter: string | undefined, bWTTYFilter: string | undefined, aBSKZFilter: string | undefined, pSTYPFilter: string | undefined, kNTTPFilter: string | undefined, kONNRFilter: string | undefined, maxKTPNRFilter: number | undefined, minKTPNRFilter: number | undefined, maxPACKNOFilter: number | undefined, minPACKNOFilter: number | undefined, aNFNRFilter: string | undefined, bANFNFilter: string | undefined, maxBNFPOFilter: number | undefined, minBNFPOFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetEKPOForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EKPOs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (mANDTFilter === null)
            throw new Error("The parameter 'mANDTFilter' cannot be null.");
        else if (mANDTFilter !== undefined)
            url_ += "MANDTFilter=" + encodeURIComponent("" + mANDTFilter) + "&";
        if (eBELNFilter === null)
            throw new Error("The parameter 'eBELNFilter' cannot be null.");
        else if (eBELNFilter !== undefined)
            url_ += "EBELNFilter=" + encodeURIComponent("" + eBELNFilter) + "&";
        if (maxEBELPFilter === null)
            throw new Error("The parameter 'maxEBELPFilter' cannot be null.");
        else if (maxEBELPFilter !== undefined)
            url_ += "MaxEBELPFilter=" + encodeURIComponent("" + maxEBELPFilter) + "&";
        if (minEBELPFilter === null)
            throw new Error("The parameter 'minEBELPFilter' cannot be null.");
        else if (minEBELPFilter !== undefined)
            url_ += "MinEBELPFilter=" + encodeURIComponent("" + minEBELPFilter) + "&";
        if (uNIQUEIDFilter === null)
            throw new Error("The parameter 'uNIQUEIDFilter' cannot be null.");
        else if (uNIQUEIDFilter !== undefined)
            url_ += "UNIQUEIDFilter=" + encodeURIComponent("" + uNIQUEIDFilter) + "&";
        if (lOEKZFilter === null)
            throw new Error("The parameter 'lOEKZFilter' cannot be null.");
        else if (lOEKZFilter !== undefined)
            url_ += "LOEKZFilter=" + encodeURIComponent("" + lOEKZFilter) + "&";
        if (sTATUFilter === null)
            throw new Error("The parameter 'sTATUFilter' cannot be null.");
        else if (sTATUFilter !== undefined)
            url_ += "STATUFilter=" + encodeURIComponent("" + sTATUFilter) + "&";
        if (maxAEDATFilter === null)
            throw new Error("The parameter 'maxAEDATFilter' cannot be null.");
        else if (maxAEDATFilter !== undefined)
            url_ += "MaxAEDATFilter=" + encodeURIComponent(maxAEDATFilter ? "" + maxAEDATFilter.toString() : "") + "&";
        if (minAEDATFilter === null)
            throw new Error("The parameter 'minAEDATFilter' cannot be null.");
        else if (minAEDATFilter !== undefined)
            url_ += "MinAEDATFilter=" + encodeURIComponent(minAEDATFilter ? "" + minAEDATFilter.toString() : "") + "&";
        if (tXZ01Filter === null)
            throw new Error("The parameter 'tXZ01Filter' cannot be null.");
        else if (tXZ01Filter !== undefined)
            url_ += "TXZ01Filter=" + encodeURIComponent("" + tXZ01Filter) + "&";
        if (mATNRFilter === null)
            throw new Error("The parameter 'mATNRFilter' cannot be null.");
        else if (mATNRFilter !== undefined)
            url_ += "MATNRFilter=" + encodeURIComponent("" + mATNRFilter) + "&";
        if (eMATNFilter === null)
            throw new Error("The parameter 'eMATNFilter' cannot be null.");
        else if (eMATNFilter !== undefined)
            url_ += "EMATNFilter=" + encodeURIComponent("" + eMATNFilter) + "&";
        if (bUKRSFilter === null)
            throw new Error("The parameter 'bUKRSFilter' cannot be null.");
        else if (bUKRSFilter !== undefined)
            url_ += "BUKRSFilter=" + encodeURIComponent("" + bUKRSFilter) + "&";
        if (wERKSFilter === null)
            throw new Error("The parameter 'wERKSFilter' cannot be null.");
        else if (wERKSFilter !== undefined)
            url_ += "WERKSFilter=" + encodeURIComponent("" + wERKSFilter) + "&";
        if (lGORTFilter === null)
            throw new Error("The parameter 'lGORTFilter' cannot be null.");
        else if (lGORTFilter !== undefined)
            url_ += "LGORTFilter=" + encodeURIComponent("" + lGORTFilter) + "&";
        if (bEDNRFilter === null)
            throw new Error("The parameter 'bEDNRFilter' cannot be null.");
        else if (bEDNRFilter !== undefined)
            url_ += "BEDNRFilter=" + encodeURIComponent("" + bEDNRFilter) + "&";
        if (mATKLFilter === null)
            throw new Error("The parameter 'mATKLFilter' cannot be null.");
        else if (mATKLFilter !== undefined)
            url_ += "MATKLFilter=" + encodeURIComponent("" + mATKLFilter) + "&";
        if (iNFNRFilter === null)
            throw new Error("The parameter 'iNFNRFilter' cannot be null.");
        else if (iNFNRFilter !== undefined)
            url_ += "INFNRFilter=" + encodeURIComponent("" + iNFNRFilter) + "&";
        if (iDNLFFilter === null)
            throw new Error("The parameter 'iDNLFFilter' cannot be null.");
        else if (iDNLFFilter !== undefined)
            url_ += "IDNLFFilter=" + encodeURIComponent("" + iDNLFFilter) + "&";
        if (maxKTMNGFilter === null)
            throw new Error("The parameter 'maxKTMNGFilter' cannot be null.");
        else if (maxKTMNGFilter !== undefined)
            url_ += "MaxKTMNGFilter=" + encodeURIComponent("" + maxKTMNGFilter) + "&";
        if (minKTMNGFilter === null)
            throw new Error("The parameter 'minKTMNGFilter' cannot be null.");
        else if (minKTMNGFilter !== undefined)
            url_ += "MinKTMNGFilter=" + encodeURIComponent("" + minKTMNGFilter) + "&";
        if (maxMENGEFilter === null)
            throw new Error("The parameter 'maxMENGEFilter' cannot be null.");
        else if (maxMENGEFilter !== undefined)
            url_ += "MaxMENGEFilter=" + encodeURIComponent("" + maxMENGEFilter) + "&";
        if (minMENGEFilter === null)
            throw new Error("The parameter 'minMENGEFilter' cannot be null.");
        else if (minMENGEFilter !== undefined)
            url_ += "MinMENGEFilter=" + encodeURIComponent("" + minMENGEFilter) + "&";
        if (mEINSFilter === null)
            throw new Error("The parameter 'mEINSFilter' cannot be null.");
        else if (mEINSFilter !== undefined)
            url_ += "MEINSFilter=" + encodeURIComponent("" + mEINSFilter) + "&";
        if (bPRMEFilter === null)
            throw new Error("The parameter 'bPRMEFilter' cannot be null.");
        else if (bPRMEFilter !== undefined)
            url_ += "BPRMEFilter=" + encodeURIComponent("" + bPRMEFilter) + "&";
        if (maxBPUMZFilter === null)
            throw new Error("The parameter 'maxBPUMZFilter' cannot be null.");
        else if (maxBPUMZFilter !== undefined)
            url_ += "MaxBPUMZFilter=" + encodeURIComponent("" + maxBPUMZFilter) + "&";
        if (minBPUMZFilter === null)
            throw new Error("The parameter 'minBPUMZFilter' cannot be null.");
        else if (minBPUMZFilter !== undefined)
            url_ += "MinBPUMZFilter=" + encodeURIComponent("" + minBPUMZFilter) + "&";
        if (maxBPUMNFilter === null)
            throw new Error("The parameter 'maxBPUMNFilter' cannot be null.");
        else if (maxBPUMNFilter !== undefined)
            url_ += "MaxBPUMNFilter=" + encodeURIComponent("" + maxBPUMNFilter) + "&";
        if (minBPUMNFilter === null)
            throw new Error("The parameter 'minBPUMNFilter' cannot be null.");
        else if (minBPUMNFilter !== undefined)
            url_ += "MinBPUMNFilter=" + encodeURIComponent("" + minBPUMNFilter) + "&";
        if (maxUMREZFilter === null)
            throw new Error("The parameter 'maxUMREZFilter' cannot be null.");
        else if (maxUMREZFilter !== undefined)
            url_ += "MaxUMREZFilter=" + encodeURIComponent("" + maxUMREZFilter) + "&";
        if (minUMREZFilter === null)
            throw new Error("The parameter 'minUMREZFilter' cannot be null.");
        else if (minUMREZFilter !== undefined)
            url_ += "MinUMREZFilter=" + encodeURIComponent("" + minUMREZFilter) + "&";
        if (maxUMRENFilter === null)
            throw new Error("The parameter 'maxUMRENFilter' cannot be null.");
        else if (maxUMRENFilter !== undefined)
            url_ += "MaxUMRENFilter=" + encodeURIComponent("" + maxUMRENFilter) + "&";
        if (minUMRENFilter === null)
            throw new Error("The parameter 'minUMRENFilter' cannot be null.");
        else if (minUMRENFilter !== undefined)
            url_ += "MinUMRENFilter=" + encodeURIComponent("" + minUMRENFilter) + "&";
        if (maxNETPRFilter === null)
            throw new Error("The parameter 'maxNETPRFilter' cannot be null.");
        else if (maxNETPRFilter !== undefined)
            url_ += "MaxNETPRFilter=" + encodeURIComponent("" + maxNETPRFilter) + "&";
        if (minNETPRFilter === null)
            throw new Error("The parameter 'minNETPRFilter' cannot be null.");
        else if (minNETPRFilter !== undefined)
            url_ += "MinNETPRFilter=" + encodeURIComponent("" + minNETPRFilter) + "&";
        if (maxPEINHFilter === null)
            throw new Error("The parameter 'maxPEINHFilter' cannot be null.");
        else if (maxPEINHFilter !== undefined)
            url_ += "MaxPEINHFilter=" + encodeURIComponent("" + maxPEINHFilter) + "&";
        if (minPEINHFilter === null)
            throw new Error("The parameter 'minPEINHFilter' cannot be null.");
        else if (minPEINHFilter !== undefined)
            url_ += "MinPEINHFilter=" + encodeURIComponent("" + minPEINHFilter) + "&";
        if (maxNETWRFilter === null)
            throw new Error("The parameter 'maxNETWRFilter' cannot be null.");
        else if (maxNETWRFilter !== undefined)
            url_ += "MaxNETWRFilter=" + encodeURIComponent("" + maxNETWRFilter) + "&";
        if (minNETWRFilter === null)
            throw new Error("The parameter 'minNETWRFilter' cannot be null.");
        else if (minNETWRFilter !== undefined)
            url_ += "MinNETWRFilter=" + encodeURIComponent("" + minNETWRFilter) + "&";
        if (maxBRTWRFilter === null)
            throw new Error("The parameter 'maxBRTWRFilter' cannot be null.");
        else if (maxBRTWRFilter !== undefined)
            url_ += "MaxBRTWRFilter=" + encodeURIComponent("" + maxBRTWRFilter) + "&";
        if (minBRTWRFilter === null)
            throw new Error("The parameter 'minBRTWRFilter' cannot be null.");
        else if (minBRTWRFilter !== undefined)
            url_ += "MinBRTWRFilter=" + encodeURIComponent("" + minBRTWRFilter) + "&";
        if (maxAGDATFilter === null)
            throw new Error("The parameter 'maxAGDATFilter' cannot be null.");
        else if (maxAGDATFilter !== undefined)
            url_ += "MaxAGDATFilter=" + encodeURIComponent(maxAGDATFilter ? "" + maxAGDATFilter.toString() : "") + "&";
        if (minAGDATFilter === null)
            throw new Error("The parameter 'minAGDATFilter' cannot be null.");
        else if (minAGDATFilter !== undefined)
            url_ += "MinAGDATFilter=" + encodeURIComponent(minAGDATFilter ? "" + minAGDATFilter.toString() : "") + "&";
        if (maxWEBAZFilter === null)
            throw new Error("The parameter 'maxWEBAZFilter' cannot be null.");
        else if (maxWEBAZFilter !== undefined)
            url_ += "MaxWEBAZFilter=" + encodeURIComponent("" + maxWEBAZFilter) + "&";
        if (minWEBAZFilter === null)
            throw new Error("The parameter 'minWEBAZFilter' cannot be null.");
        else if (minWEBAZFilter !== undefined)
            url_ += "MinWEBAZFilter=" + encodeURIComponent("" + minWEBAZFilter) + "&";
        if (mWSKZFilter === null)
            throw new Error("The parameter 'mWSKZFilter' cannot be null.");
        else if (mWSKZFilter !== undefined)
            url_ += "MWSKZFilter=" + encodeURIComponent("" + mWSKZFilter) + "&";
        if (bONUSFilter === null)
            throw new Error("The parameter 'bONUSFilter' cannot be null.");
        else if (bONUSFilter !== undefined)
            url_ += "BONUSFilter=" + encodeURIComponent("" + bONUSFilter) + "&";
        if (iNSMKFilter === null)
            throw new Error("The parameter 'iNSMKFilter' cannot be null.");
        else if (iNSMKFilter !== undefined)
            url_ += "INSMKFilter=" + encodeURIComponent("" + iNSMKFilter) + "&";
        if (sPINFFilter === null)
            throw new Error("The parameter 'sPINFFilter' cannot be null.");
        else if (sPINFFilter !== undefined)
            url_ += "SPINFFilter=" + encodeURIComponent("" + sPINFFilter) + "&";
        if (pRSDRFilter === null)
            throw new Error("The parameter 'pRSDRFilter' cannot be null.");
        else if (pRSDRFilter !== undefined)
            url_ += "PRSDRFilter=" + encodeURIComponent("" + pRSDRFilter) + "&";
        if (bWTARFilter === null)
            throw new Error("The parameter 'bWTARFilter' cannot be null.");
        else if (bWTARFilter !== undefined)
            url_ += "BWTARFilter=" + encodeURIComponent("" + bWTARFilter) + "&";
        if (bWTTYFilter === null)
            throw new Error("The parameter 'bWTTYFilter' cannot be null.");
        else if (bWTTYFilter !== undefined)
            url_ += "BWTTYFilter=" + encodeURIComponent("" + bWTTYFilter) + "&";
        if (aBSKZFilter === null)
            throw new Error("The parameter 'aBSKZFilter' cannot be null.");
        else if (aBSKZFilter !== undefined)
            url_ += "ABSKZFilter=" + encodeURIComponent("" + aBSKZFilter) + "&";
        if (pSTYPFilter === null)
            throw new Error("The parameter 'pSTYPFilter' cannot be null.");
        else if (pSTYPFilter !== undefined)
            url_ += "PSTYPFilter=" + encodeURIComponent("" + pSTYPFilter) + "&";
        if (kNTTPFilter === null)
            throw new Error("The parameter 'kNTTPFilter' cannot be null.");
        else if (kNTTPFilter !== undefined)
            url_ += "KNTTPFilter=" + encodeURIComponent("" + kNTTPFilter) + "&";
        if (kONNRFilter === null)
            throw new Error("The parameter 'kONNRFilter' cannot be null.");
        else if (kONNRFilter !== undefined)
            url_ += "KONNRFilter=" + encodeURIComponent("" + kONNRFilter) + "&";
        if (maxKTPNRFilter === null)
            throw new Error("The parameter 'maxKTPNRFilter' cannot be null.");
        else if (maxKTPNRFilter !== undefined)
            url_ += "MaxKTPNRFilter=" + encodeURIComponent("" + maxKTPNRFilter) + "&";
        if (minKTPNRFilter === null)
            throw new Error("The parameter 'minKTPNRFilter' cannot be null.");
        else if (minKTPNRFilter !== undefined)
            url_ += "MinKTPNRFilter=" + encodeURIComponent("" + minKTPNRFilter) + "&";
        if (maxPACKNOFilter === null)
            throw new Error("The parameter 'maxPACKNOFilter' cannot be null.");
        else if (maxPACKNOFilter !== undefined)
            url_ += "MaxPACKNOFilter=" + encodeURIComponent("" + maxPACKNOFilter) + "&";
        if (minPACKNOFilter === null)
            throw new Error("The parameter 'minPACKNOFilter' cannot be null.");
        else if (minPACKNOFilter !== undefined)
            url_ += "MinPACKNOFilter=" + encodeURIComponent("" + minPACKNOFilter) + "&";
        if (aNFNRFilter === null)
            throw new Error("The parameter 'aNFNRFilter' cannot be null.");
        else if (aNFNRFilter !== undefined)
            url_ += "ANFNRFilter=" + encodeURIComponent("" + aNFNRFilter) + "&";
        if (bANFNFilter === null)
            throw new Error("The parameter 'bANFNFilter' cannot be null.");
        else if (bANFNFilter !== undefined)
            url_ += "BANFNFilter=" + encodeURIComponent("" + bANFNFilter) + "&";
        if (maxBNFPOFilter === null)
            throw new Error("The parameter 'maxBNFPOFilter' cannot be null.");
        else if (maxBNFPOFilter !== undefined)
            url_ += "MaxBNFPOFilter=" + encodeURIComponent("" + maxBNFPOFilter) + "&";
        if (minBNFPOFilter === null)
            throw new Error("The parameter 'minBNFPOFilter' cannot be null.");
        else if (minBNFPOFilter !== undefined)
            url_ += "MinBNFPOFilter=" + encodeURIComponent("" + minBNFPOFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetEKPOForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetEKPOForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEKPOForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetEKPOForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEKPOForView(id: string | undefined): Observable<GetEKPOForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EKPOs/GetEKPOForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEKPOForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEKPOForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEKPOForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEKPOForViewDto>;
        }));
    }

    protected processGetEKPOForView(response: HttpResponseBase): Observable<GetEKPOForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEKPOForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEKPOForEdit(id: string | undefined): Observable<GetEKPOForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/EKPOs/GetEKPOForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEKPOForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEKPOForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEKPOForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEKPOForEditOutput>;
        }));
    }

    protected processGetEKPOForEdit(response: HttpResponseBase): Observable<GetEKPOForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEKPOForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditEKPODto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EKPOs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EKPOs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param mANDTFilter (optional) 
     * @param eBELNFilter (optional) 
     * @param maxEBELPFilter (optional) 
     * @param minEBELPFilter (optional) 
     * @param uNIQUEIDFilter (optional) 
     * @param lOEKZFilter (optional) 
     * @param sTATUFilter (optional) 
     * @param maxAEDATFilter (optional) 
     * @param minAEDATFilter (optional) 
     * @param tXZ01Filter (optional) 
     * @param mATNRFilter (optional) 
     * @param eMATNFilter (optional) 
     * @param bUKRSFilter (optional) 
     * @param wERKSFilter (optional) 
     * @param lGORTFilter (optional) 
     * @param bEDNRFilter (optional) 
     * @param mATKLFilter (optional) 
     * @param iNFNRFilter (optional) 
     * @param iDNLFFilter (optional) 
     * @param maxKTMNGFilter (optional) 
     * @param minKTMNGFilter (optional) 
     * @param maxMENGEFilter (optional) 
     * @param minMENGEFilter (optional) 
     * @param mEINSFilter (optional) 
     * @param bPRMEFilter (optional) 
     * @param maxBPUMZFilter (optional) 
     * @param minBPUMZFilter (optional) 
     * @param maxBPUMNFilter (optional) 
     * @param minBPUMNFilter (optional) 
     * @param maxUMREZFilter (optional) 
     * @param minUMREZFilter (optional) 
     * @param maxUMRENFilter (optional) 
     * @param minUMRENFilter (optional) 
     * @param maxNETPRFilter (optional) 
     * @param minNETPRFilter (optional) 
     * @param maxPEINHFilter (optional) 
     * @param minPEINHFilter (optional) 
     * @param maxNETWRFilter (optional) 
     * @param minNETWRFilter (optional) 
     * @param maxBRTWRFilter (optional) 
     * @param minBRTWRFilter (optional) 
     * @param maxAGDATFilter (optional) 
     * @param minAGDATFilter (optional) 
     * @param maxWEBAZFilter (optional) 
     * @param minWEBAZFilter (optional) 
     * @param mWSKZFilter (optional) 
     * @param bONUSFilter (optional) 
     * @param iNSMKFilter (optional) 
     * @param sPINFFilter (optional) 
     * @param pRSDRFilter (optional) 
     * @param bWTARFilter (optional) 
     * @param bWTTYFilter (optional) 
     * @param aBSKZFilter (optional) 
     * @param pSTYPFilter (optional) 
     * @param kNTTPFilter (optional) 
     * @param kONNRFilter (optional) 
     * @param maxKTPNRFilter (optional) 
     * @param minKTPNRFilter (optional) 
     * @param maxPACKNOFilter (optional) 
     * @param minPACKNOFilter (optional) 
     * @param aNFNRFilter (optional) 
     * @param bANFNFilter (optional) 
     * @param maxBNFPOFilter (optional) 
     * @param minBNFPOFilter (optional) 
     * @return Success
     */
    getEKPOsToExcel(filter: string | undefined, mANDTFilter: string | undefined, eBELNFilter: string | undefined, maxEBELPFilter: number | undefined, minEBELPFilter: number | undefined, uNIQUEIDFilter: string | undefined, lOEKZFilter: string | undefined, sTATUFilter: string | undefined, maxAEDATFilter: DateTime | undefined, minAEDATFilter: DateTime | undefined, tXZ01Filter: string | undefined, mATNRFilter: string | undefined, eMATNFilter: string | undefined, bUKRSFilter: string | undefined, wERKSFilter: string | undefined, lGORTFilter: string | undefined, bEDNRFilter: string | undefined, mATKLFilter: string | undefined, iNFNRFilter: string | undefined, iDNLFFilter: string | undefined, maxKTMNGFilter: number | undefined, minKTMNGFilter: number | undefined, maxMENGEFilter: number | undefined, minMENGEFilter: number | undefined, mEINSFilter: string | undefined, bPRMEFilter: string | undefined, maxBPUMZFilter: number | undefined, minBPUMZFilter: number | undefined, maxBPUMNFilter: number | undefined, minBPUMNFilter: number | undefined, maxUMREZFilter: number | undefined, minUMREZFilter: number | undefined, maxUMRENFilter: number | undefined, minUMRENFilter: number | undefined, maxNETPRFilter: number | undefined, minNETPRFilter: number | undefined, maxPEINHFilter: number | undefined, minPEINHFilter: number | undefined, maxNETWRFilter: number | undefined, minNETWRFilter: number | undefined, maxBRTWRFilter: number | undefined, minBRTWRFilter: number | undefined, maxAGDATFilter: DateTime | undefined, minAGDATFilter: DateTime | undefined, maxWEBAZFilter: number | undefined, minWEBAZFilter: number | undefined, mWSKZFilter: string | undefined, bONUSFilter: string | undefined, iNSMKFilter: string | undefined, sPINFFilter: string | undefined, pRSDRFilter: string | undefined, bWTARFilter: string | undefined, bWTTYFilter: string | undefined, aBSKZFilter: string | undefined, pSTYPFilter: string | undefined, kNTTPFilter: string | undefined, kONNRFilter: string | undefined, maxKTPNRFilter: number | undefined, minKTPNRFilter: number | undefined, maxPACKNOFilter: number | undefined, minPACKNOFilter: number | undefined, aNFNRFilter: string | undefined, bANFNFilter: string | undefined, maxBNFPOFilter: number | undefined, minBNFPOFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/EKPOs/GetEKPOsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (mANDTFilter === null)
            throw new Error("The parameter 'mANDTFilter' cannot be null.");
        else if (mANDTFilter !== undefined)
            url_ += "MANDTFilter=" + encodeURIComponent("" + mANDTFilter) + "&";
        if (eBELNFilter === null)
            throw new Error("The parameter 'eBELNFilter' cannot be null.");
        else if (eBELNFilter !== undefined)
            url_ += "EBELNFilter=" + encodeURIComponent("" + eBELNFilter) + "&";
        if (maxEBELPFilter === null)
            throw new Error("The parameter 'maxEBELPFilter' cannot be null.");
        else if (maxEBELPFilter !== undefined)
            url_ += "MaxEBELPFilter=" + encodeURIComponent("" + maxEBELPFilter) + "&";
        if (minEBELPFilter === null)
            throw new Error("The parameter 'minEBELPFilter' cannot be null.");
        else if (minEBELPFilter !== undefined)
            url_ += "MinEBELPFilter=" + encodeURIComponent("" + minEBELPFilter) + "&";
        if (uNIQUEIDFilter === null)
            throw new Error("The parameter 'uNIQUEIDFilter' cannot be null.");
        else if (uNIQUEIDFilter !== undefined)
            url_ += "UNIQUEIDFilter=" + encodeURIComponent("" + uNIQUEIDFilter) + "&";
        if (lOEKZFilter === null)
            throw new Error("The parameter 'lOEKZFilter' cannot be null.");
        else if (lOEKZFilter !== undefined)
            url_ += "LOEKZFilter=" + encodeURIComponent("" + lOEKZFilter) + "&";
        if (sTATUFilter === null)
            throw new Error("The parameter 'sTATUFilter' cannot be null.");
        else if (sTATUFilter !== undefined)
            url_ += "STATUFilter=" + encodeURIComponent("" + sTATUFilter) + "&";
        if (maxAEDATFilter === null)
            throw new Error("The parameter 'maxAEDATFilter' cannot be null.");
        else if (maxAEDATFilter !== undefined)
            url_ += "MaxAEDATFilter=" + encodeURIComponent(maxAEDATFilter ? "" + maxAEDATFilter.toString() : "") + "&";
        if (minAEDATFilter === null)
            throw new Error("The parameter 'minAEDATFilter' cannot be null.");
        else if (minAEDATFilter !== undefined)
            url_ += "MinAEDATFilter=" + encodeURIComponent(minAEDATFilter ? "" + minAEDATFilter.toString() : "") + "&";
        if (tXZ01Filter === null)
            throw new Error("The parameter 'tXZ01Filter' cannot be null.");
        else if (tXZ01Filter !== undefined)
            url_ += "TXZ01Filter=" + encodeURIComponent("" + tXZ01Filter) + "&";
        if (mATNRFilter === null)
            throw new Error("The parameter 'mATNRFilter' cannot be null.");
        else if (mATNRFilter !== undefined)
            url_ += "MATNRFilter=" + encodeURIComponent("" + mATNRFilter) + "&";
        if (eMATNFilter === null)
            throw new Error("The parameter 'eMATNFilter' cannot be null.");
        else if (eMATNFilter !== undefined)
            url_ += "EMATNFilter=" + encodeURIComponent("" + eMATNFilter) + "&";
        if (bUKRSFilter === null)
            throw new Error("The parameter 'bUKRSFilter' cannot be null.");
        else if (bUKRSFilter !== undefined)
            url_ += "BUKRSFilter=" + encodeURIComponent("" + bUKRSFilter) + "&";
        if (wERKSFilter === null)
            throw new Error("The parameter 'wERKSFilter' cannot be null.");
        else if (wERKSFilter !== undefined)
            url_ += "WERKSFilter=" + encodeURIComponent("" + wERKSFilter) + "&";
        if (lGORTFilter === null)
            throw new Error("The parameter 'lGORTFilter' cannot be null.");
        else if (lGORTFilter !== undefined)
            url_ += "LGORTFilter=" + encodeURIComponent("" + lGORTFilter) + "&";
        if (bEDNRFilter === null)
            throw new Error("The parameter 'bEDNRFilter' cannot be null.");
        else if (bEDNRFilter !== undefined)
            url_ += "BEDNRFilter=" + encodeURIComponent("" + bEDNRFilter) + "&";
        if (mATKLFilter === null)
            throw new Error("The parameter 'mATKLFilter' cannot be null.");
        else if (mATKLFilter !== undefined)
            url_ += "MATKLFilter=" + encodeURIComponent("" + mATKLFilter) + "&";
        if (iNFNRFilter === null)
            throw new Error("The parameter 'iNFNRFilter' cannot be null.");
        else if (iNFNRFilter !== undefined)
            url_ += "INFNRFilter=" + encodeURIComponent("" + iNFNRFilter) + "&";
        if (iDNLFFilter === null)
            throw new Error("The parameter 'iDNLFFilter' cannot be null.");
        else if (iDNLFFilter !== undefined)
            url_ += "IDNLFFilter=" + encodeURIComponent("" + iDNLFFilter) + "&";
        if (maxKTMNGFilter === null)
            throw new Error("The parameter 'maxKTMNGFilter' cannot be null.");
        else if (maxKTMNGFilter !== undefined)
            url_ += "MaxKTMNGFilter=" + encodeURIComponent("" + maxKTMNGFilter) + "&";
        if (minKTMNGFilter === null)
            throw new Error("The parameter 'minKTMNGFilter' cannot be null.");
        else if (minKTMNGFilter !== undefined)
            url_ += "MinKTMNGFilter=" + encodeURIComponent("" + minKTMNGFilter) + "&";
        if (maxMENGEFilter === null)
            throw new Error("The parameter 'maxMENGEFilter' cannot be null.");
        else if (maxMENGEFilter !== undefined)
            url_ += "MaxMENGEFilter=" + encodeURIComponent("" + maxMENGEFilter) + "&";
        if (minMENGEFilter === null)
            throw new Error("The parameter 'minMENGEFilter' cannot be null.");
        else if (minMENGEFilter !== undefined)
            url_ += "MinMENGEFilter=" + encodeURIComponent("" + minMENGEFilter) + "&";
        if (mEINSFilter === null)
            throw new Error("The parameter 'mEINSFilter' cannot be null.");
        else if (mEINSFilter !== undefined)
            url_ += "MEINSFilter=" + encodeURIComponent("" + mEINSFilter) + "&";
        if (bPRMEFilter === null)
            throw new Error("The parameter 'bPRMEFilter' cannot be null.");
        else if (bPRMEFilter !== undefined)
            url_ += "BPRMEFilter=" + encodeURIComponent("" + bPRMEFilter) + "&";
        if (maxBPUMZFilter === null)
            throw new Error("The parameter 'maxBPUMZFilter' cannot be null.");
        else if (maxBPUMZFilter !== undefined)
            url_ += "MaxBPUMZFilter=" + encodeURIComponent("" + maxBPUMZFilter) + "&";
        if (minBPUMZFilter === null)
            throw new Error("The parameter 'minBPUMZFilter' cannot be null.");
        else if (minBPUMZFilter !== undefined)
            url_ += "MinBPUMZFilter=" + encodeURIComponent("" + minBPUMZFilter) + "&";
        if (maxBPUMNFilter === null)
            throw new Error("The parameter 'maxBPUMNFilter' cannot be null.");
        else if (maxBPUMNFilter !== undefined)
            url_ += "MaxBPUMNFilter=" + encodeURIComponent("" + maxBPUMNFilter) + "&";
        if (minBPUMNFilter === null)
            throw new Error("The parameter 'minBPUMNFilter' cannot be null.");
        else if (minBPUMNFilter !== undefined)
            url_ += "MinBPUMNFilter=" + encodeURIComponent("" + minBPUMNFilter) + "&";
        if (maxUMREZFilter === null)
            throw new Error("The parameter 'maxUMREZFilter' cannot be null.");
        else if (maxUMREZFilter !== undefined)
            url_ += "MaxUMREZFilter=" + encodeURIComponent("" + maxUMREZFilter) + "&";
        if (minUMREZFilter === null)
            throw new Error("The parameter 'minUMREZFilter' cannot be null.");
        else if (minUMREZFilter !== undefined)
            url_ += "MinUMREZFilter=" + encodeURIComponent("" + minUMREZFilter) + "&";
        if (maxUMRENFilter === null)
            throw new Error("The parameter 'maxUMRENFilter' cannot be null.");
        else if (maxUMRENFilter !== undefined)
            url_ += "MaxUMRENFilter=" + encodeURIComponent("" + maxUMRENFilter) + "&";
        if (minUMRENFilter === null)
            throw new Error("The parameter 'minUMRENFilter' cannot be null.");
        else if (minUMRENFilter !== undefined)
            url_ += "MinUMRENFilter=" + encodeURIComponent("" + minUMRENFilter) + "&";
        if (maxNETPRFilter === null)
            throw new Error("The parameter 'maxNETPRFilter' cannot be null.");
        else if (maxNETPRFilter !== undefined)
            url_ += "MaxNETPRFilter=" + encodeURIComponent("" + maxNETPRFilter) + "&";
        if (minNETPRFilter === null)
            throw new Error("The parameter 'minNETPRFilter' cannot be null.");
        else if (minNETPRFilter !== undefined)
            url_ += "MinNETPRFilter=" + encodeURIComponent("" + minNETPRFilter) + "&";
        if (maxPEINHFilter === null)
            throw new Error("The parameter 'maxPEINHFilter' cannot be null.");
        else if (maxPEINHFilter !== undefined)
            url_ += "MaxPEINHFilter=" + encodeURIComponent("" + maxPEINHFilter) + "&";
        if (minPEINHFilter === null)
            throw new Error("The parameter 'minPEINHFilter' cannot be null.");
        else if (minPEINHFilter !== undefined)
            url_ += "MinPEINHFilter=" + encodeURIComponent("" + minPEINHFilter) + "&";
        if (maxNETWRFilter === null)
            throw new Error("The parameter 'maxNETWRFilter' cannot be null.");
        else if (maxNETWRFilter !== undefined)
            url_ += "MaxNETWRFilter=" + encodeURIComponent("" + maxNETWRFilter) + "&";
        if (minNETWRFilter === null)
            throw new Error("The parameter 'minNETWRFilter' cannot be null.");
        else if (minNETWRFilter !== undefined)
            url_ += "MinNETWRFilter=" + encodeURIComponent("" + minNETWRFilter) + "&";
        if (maxBRTWRFilter === null)
            throw new Error("The parameter 'maxBRTWRFilter' cannot be null.");
        else if (maxBRTWRFilter !== undefined)
            url_ += "MaxBRTWRFilter=" + encodeURIComponent("" + maxBRTWRFilter) + "&";
        if (minBRTWRFilter === null)
            throw new Error("The parameter 'minBRTWRFilter' cannot be null.");
        else if (minBRTWRFilter !== undefined)
            url_ += "MinBRTWRFilter=" + encodeURIComponent("" + minBRTWRFilter) + "&";
        if (maxAGDATFilter === null)
            throw new Error("The parameter 'maxAGDATFilter' cannot be null.");
        else if (maxAGDATFilter !== undefined)
            url_ += "MaxAGDATFilter=" + encodeURIComponent(maxAGDATFilter ? "" + maxAGDATFilter.toString() : "") + "&";
        if (minAGDATFilter === null)
            throw new Error("The parameter 'minAGDATFilter' cannot be null.");
        else if (minAGDATFilter !== undefined)
            url_ += "MinAGDATFilter=" + encodeURIComponent(minAGDATFilter ? "" + minAGDATFilter.toString() : "") + "&";
        if (maxWEBAZFilter === null)
            throw new Error("The parameter 'maxWEBAZFilter' cannot be null.");
        else if (maxWEBAZFilter !== undefined)
            url_ += "MaxWEBAZFilter=" + encodeURIComponent("" + maxWEBAZFilter) + "&";
        if (minWEBAZFilter === null)
            throw new Error("The parameter 'minWEBAZFilter' cannot be null.");
        else if (minWEBAZFilter !== undefined)
            url_ += "MinWEBAZFilter=" + encodeURIComponent("" + minWEBAZFilter) + "&";
        if (mWSKZFilter === null)
            throw new Error("The parameter 'mWSKZFilter' cannot be null.");
        else if (mWSKZFilter !== undefined)
            url_ += "MWSKZFilter=" + encodeURIComponent("" + mWSKZFilter) + "&";
        if (bONUSFilter === null)
            throw new Error("The parameter 'bONUSFilter' cannot be null.");
        else if (bONUSFilter !== undefined)
            url_ += "BONUSFilter=" + encodeURIComponent("" + bONUSFilter) + "&";
        if (iNSMKFilter === null)
            throw new Error("The parameter 'iNSMKFilter' cannot be null.");
        else if (iNSMKFilter !== undefined)
            url_ += "INSMKFilter=" + encodeURIComponent("" + iNSMKFilter) + "&";
        if (sPINFFilter === null)
            throw new Error("The parameter 'sPINFFilter' cannot be null.");
        else if (sPINFFilter !== undefined)
            url_ += "SPINFFilter=" + encodeURIComponent("" + sPINFFilter) + "&";
        if (pRSDRFilter === null)
            throw new Error("The parameter 'pRSDRFilter' cannot be null.");
        else if (pRSDRFilter !== undefined)
            url_ += "PRSDRFilter=" + encodeURIComponent("" + pRSDRFilter) + "&";
        if (bWTARFilter === null)
            throw new Error("The parameter 'bWTARFilter' cannot be null.");
        else if (bWTARFilter !== undefined)
            url_ += "BWTARFilter=" + encodeURIComponent("" + bWTARFilter) + "&";
        if (bWTTYFilter === null)
            throw new Error("The parameter 'bWTTYFilter' cannot be null.");
        else if (bWTTYFilter !== undefined)
            url_ += "BWTTYFilter=" + encodeURIComponent("" + bWTTYFilter) + "&";
        if (aBSKZFilter === null)
            throw new Error("The parameter 'aBSKZFilter' cannot be null.");
        else if (aBSKZFilter !== undefined)
            url_ += "ABSKZFilter=" + encodeURIComponent("" + aBSKZFilter) + "&";
        if (pSTYPFilter === null)
            throw new Error("The parameter 'pSTYPFilter' cannot be null.");
        else if (pSTYPFilter !== undefined)
            url_ += "PSTYPFilter=" + encodeURIComponent("" + pSTYPFilter) + "&";
        if (kNTTPFilter === null)
            throw new Error("The parameter 'kNTTPFilter' cannot be null.");
        else if (kNTTPFilter !== undefined)
            url_ += "KNTTPFilter=" + encodeURIComponent("" + kNTTPFilter) + "&";
        if (kONNRFilter === null)
            throw new Error("The parameter 'kONNRFilter' cannot be null.");
        else if (kONNRFilter !== undefined)
            url_ += "KONNRFilter=" + encodeURIComponent("" + kONNRFilter) + "&";
        if (maxKTPNRFilter === null)
            throw new Error("The parameter 'maxKTPNRFilter' cannot be null.");
        else if (maxKTPNRFilter !== undefined)
            url_ += "MaxKTPNRFilter=" + encodeURIComponent("" + maxKTPNRFilter) + "&";
        if (minKTPNRFilter === null)
            throw new Error("The parameter 'minKTPNRFilter' cannot be null.");
        else if (minKTPNRFilter !== undefined)
            url_ += "MinKTPNRFilter=" + encodeURIComponent("" + minKTPNRFilter) + "&";
        if (maxPACKNOFilter === null)
            throw new Error("The parameter 'maxPACKNOFilter' cannot be null.");
        else if (maxPACKNOFilter !== undefined)
            url_ += "MaxPACKNOFilter=" + encodeURIComponent("" + maxPACKNOFilter) + "&";
        if (minPACKNOFilter === null)
            throw new Error("The parameter 'minPACKNOFilter' cannot be null.");
        else if (minPACKNOFilter !== undefined)
            url_ += "MinPACKNOFilter=" + encodeURIComponent("" + minPACKNOFilter) + "&";
        if (aNFNRFilter === null)
            throw new Error("The parameter 'aNFNRFilter' cannot be null.");
        else if (aNFNRFilter !== undefined)
            url_ += "ANFNRFilter=" + encodeURIComponent("" + aNFNRFilter) + "&";
        if (bANFNFilter === null)
            throw new Error("The parameter 'bANFNFilter' cannot be null.");
        else if (bANFNFilter !== undefined)
            url_ += "BANFNFilter=" + encodeURIComponent("" + bANFNFilter) + "&";
        if (maxBNFPOFilter === null)
            throw new Error("The parameter 'maxBNFPOFilter' cannot be null.");
        else if (maxBNFPOFilter !== undefined)
            url_ += "MaxBNFPOFilter=" + encodeURIComponent("" + maxBNFPOFilter) + "&";
        if (minBNFPOFilter === null)
            throw new Error("The parameter 'minBNFPOFilter' cannot be null.");
        else if (minBNFPOFilter !== undefined)
            url_ += "MinBNFPOFilter=" + encodeURIComponent("" + minBNFPOFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEKPOsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEKPOsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetEKPOsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class EnumTablesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param enumCodeFilter (optional) 
     * @param enumValueFilter (optional) 
     * @param enumLabelFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, enumCodeFilter: string | undefined, enumValueFilter: string | undefined, enumLabelFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetEnumTableForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EnumTables/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (enumCodeFilter === null)
            throw new Error("The parameter 'enumCodeFilter' cannot be null.");
        else if (enumCodeFilter !== undefined)
            url_ += "EnumCodeFilter=" + encodeURIComponent("" + enumCodeFilter) + "&";
        if (enumValueFilter === null)
            throw new Error("The parameter 'enumValueFilter' cannot be null.");
        else if (enumValueFilter !== undefined)
            url_ += "EnumValueFilter=" + encodeURIComponent("" + enumValueFilter) + "&";
        if (enumLabelFilter === null)
            throw new Error("The parameter 'enumLabelFilter' cannot be null.");
        else if (enumLabelFilter !== undefined)
            url_ += "EnumLabelFilter=" + encodeURIComponent("" + enumLabelFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetEnumTableForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetEnumTableForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEnumTableForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetEnumTableForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEnumTableForView(id: string | undefined): Observable<GetEnumTableForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EnumTables/GetEnumTableForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumTableForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumTableForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEnumTableForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEnumTableForViewDto>;
        }));
    }

    protected processGetEnumTableForView(response: HttpResponseBase): Observable<GetEnumTableForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEnumTableForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEnumTableForEdit(id: string | undefined): Observable<GetEnumTableForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/EnumTables/GetEnumTableForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumTableForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumTableForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEnumTableForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEnumTableForEditOutput>;
        }));
    }

    protected processGetEnumTableForEdit(response: HttpResponseBase): Observable<GetEnumTableForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEnumTableForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditEnumTableDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnumTables/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EnumTables/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param enumCodeFilter (optional) 
     * @param enumValueFilter (optional) 
     * @param enumLabelFilter (optional) 
     * @return Success
     */
    getEnumTablesToExcel(filter: string | undefined, enumCodeFilter: string | undefined, enumValueFilter: string | undefined, enumLabelFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/EnumTables/GetEnumTablesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (enumCodeFilter === null)
            throw new Error("The parameter 'enumCodeFilter' cannot be null.");
        else if (enumCodeFilter !== undefined)
            url_ += "EnumCodeFilter=" + encodeURIComponent("" + enumCodeFilter) + "&";
        if (enumValueFilter === null)
            throw new Error("The parameter 'enumValueFilter' cannot be null.");
        else if (enumValueFilter !== undefined)
            url_ += "EnumValueFilter=" + encodeURIComponent("" + enumValueFilter) + "&";
        if (enumLabelFilter === null)
            throw new Error("The parameter 'enumLabelFilter' cannot be null.");
        else if (enumLabelFilter !== undefined)
            url_ += "EnumLabelFilter=" + encodeURIComponent("" + enumLabelFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumTablesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumTablesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetEnumTablesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipRequest(body: CreateFriendshipRequestInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDto>;
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipWithDifferentTenant(body: CreateFriendshipWithDifferentTenantInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipWithDifferentTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipWithDifferentTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipWithDifferentTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDto>;
        }));
    }

    protected processCreateFriendshipWithDifferentTenant(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createFriendshipForCurrentTenant(body: CreateFriendshipForCurrentTenantInput | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipForCurrentTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipForCurrentTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipForCurrentTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FriendDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FriendDto>;
        }));
    }

    protected processCreateFriendshipForCurrentTenant(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    blockUser(body: BlockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unblockUser(body: UnblockUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptFriendshipRequest(body: AcceptFriendshipRequestInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    removeFriend(userId: number | undefined, tenantId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/RemoveFriend?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFriend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFriend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveFriend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GeneralLedgerAccountsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param fundsCenterFilter (optional) 
     * @param maxConsumableBudgetFilter (optional) 
     * @param minConsumableBudgetFilter (optional) 
     * @param maxConsumedBudgetFilter (optional) 
     * @param minConsumedBudgetFilter (optional) 
     * @param maxAvailableAmountFilter (optional) 
     * @param minAvailableAmountFilter (optional) 
     * @param maxCurrentBudgetFilter (optional) 
     * @param minCurrentBudgetFilter (optional) 
     * @param maxCommitmentActualsFilter (optional) 
     * @param minCommitmentActualsFilter (optional) 
     * @param fundsCenterDescriptionFilter (optional) 
     * @param costCenterCostCenterNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, fundsCenterFilter: string | undefined, maxConsumableBudgetFilter: number | undefined, minConsumableBudgetFilter: number | undefined, maxConsumedBudgetFilter: number | undefined, minConsumedBudgetFilter: number | undefined, maxAvailableAmountFilter: number | undefined, minAvailableAmountFilter: number | undefined, maxCurrentBudgetFilter: number | undefined, minCurrentBudgetFilter: number | undefined, maxCommitmentActualsFilter: number | undefined, minCommitmentActualsFilter: number | undefined, fundsCenterDescriptionFilter: string | undefined, costCenterCostCenterNameFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetGeneralLedgerAccountForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerAccounts/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (fundsCenterFilter === null)
            throw new Error("The parameter 'fundsCenterFilter' cannot be null.");
        else if (fundsCenterFilter !== undefined)
            url_ += "FundsCenterFilter=" + encodeURIComponent("" + fundsCenterFilter) + "&";
        if (maxConsumableBudgetFilter === null)
            throw new Error("The parameter 'maxConsumableBudgetFilter' cannot be null.");
        else if (maxConsumableBudgetFilter !== undefined)
            url_ += "MaxConsumableBudgetFilter=" + encodeURIComponent("" + maxConsumableBudgetFilter) + "&";
        if (minConsumableBudgetFilter === null)
            throw new Error("The parameter 'minConsumableBudgetFilter' cannot be null.");
        else if (minConsumableBudgetFilter !== undefined)
            url_ += "MinConsumableBudgetFilter=" + encodeURIComponent("" + minConsumableBudgetFilter) + "&";
        if (maxConsumedBudgetFilter === null)
            throw new Error("The parameter 'maxConsumedBudgetFilter' cannot be null.");
        else if (maxConsumedBudgetFilter !== undefined)
            url_ += "MaxConsumedBudgetFilter=" + encodeURIComponent("" + maxConsumedBudgetFilter) + "&";
        if (minConsumedBudgetFilter === null)
            throw new Error("The parameter 'minConsumedBudgetFilter' cannot be null.");
        else if (minConsumedBudgetFilter !== undefined)
            url_ += "MinConsumedBudgetFilter=" + encodeURIComponent("" + minConsumedBudgetFilter) + "&";
        if (maxAvailableAmountFilter === null)
            throw new Error("The parameter 'maxAvailableAmountFilter' cannot be null.");
        else if (maxAvailableAmountFilter !== undefined)
            url_ += "MaxAvailableAmountFilter=" + encodeURIComponent("" + maxAvailableAmountFilter) + "&";
        if (minAvailableAmountFilter === null)
            throw new Error("The parameter 'minAvailableAmountFilter' cannot be null.");
        else if (minAvailableAmountFilter !== undefined)
            url_ += "MinAvailableAmountFilter=" + encodeURIComponent("" + minAvailableAmountFilter) + "&";
        if (maxCurrentBudgetFilter === null)
            throw new Error("The parameter 'maxCurrentBudgetFilter' cannot be null.");
        else if (maxCurrentBudgetFilter !== undefined)
            url_ += "MaxCurrentBudgetFilter=" + encodeURIComponent("" + maxCurrentBudgetFilter) + "&";
        if (minCurrentBudgetFilter === null)
            throw new Error("The parameter 'minCurrentBudgetFilter' cannot be null.");
        else if (minCurrentBudgetFilter !== undefined)
            url_ += "MinCurrentBudgetFilter=" + encodeURIComponent("" + minCurrentBudgetFilter) + "&";
        if (maxCommitmentActualsFilter === null)
            throw new Error("The parameter 'maxCommitmentActualsFilter' cannot be null.");
        else if (maxCommitmentActualsFilter !== undefined)
            url_ += "MaxCommitmentActualsFilter=" + encodeURIComponent("" + maxCommitmentActualsFilter) + "&";
        if (minCommitmentActualsFilter === null)
            throw new Error("The parameter 'minCommitmentActualsFilter' cannot be null.");
        else if (minCommitmentActualsFilter !== undefined)
            url_ += "MinCommitmentActualsFilter=" + encodeURIComponent("" + minCommitmentActualsFilter) + "&";
        if (fundsCenterDescriptionFilter === null)
            throw new Error("The parameter 'fundsCenterDescriptionFilter' cannot be null.");
        else if (fundsCenterDescriptionFilter !== undefined)
            url_ += "FundsCenterDescriptionFilter=" + encodeURIComponent("" + fundsCenterDescriptionFilter) + "&";
        if (costCenterCostCenterNameFilter === null)
            throw new Error("The parameter 'costCenterCostCenterNameFilter' cannot be null.");
        else if (costCenterCostCenterNameFilter !== undefined)
            url_ += "CostCenterCostCenterNameFilter=" + encodeURIComponent("" + costCenterCostCenterNameFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetGeneralLedgerAccountForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetGeneralLedgerAccountForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetGeneralLedgerAccountForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetGeneralLedgerAccountForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGeneralLedgerAccountForView(id: string | undefined): Observable<GetGeneralLedgerAccountForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerAccounts/GetGeneralLedgerAccountForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralLedgerAccountForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralLedgerAccountForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGeneralLedgerAccountForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGeneralLedgerAccountForViewDto>;
        }));
    }

    protected processGetGeneralLedgerAccountForView(response: HttpResponseBase): Observable<GetGeneralLedgerAccountForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralLedgerAccountForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGeneralLedgerAccountForEdit(id: string | undefined): Observable<GetGeneralLedgerAccountForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerAccounts/GetGeneralLedgerAccountForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralLedgerAccountForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralLedgerAccountForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGeneralLedgerAccountForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGeneralLedgerAccountForEditOutput>;
        }));
    }

    protected processGetGeneralLedgerAccountForEdit(response: HttpResponseBase): Observable<GetGeneralLedgerAccountForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralLedgerAccountForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditGeneralLedgerAccountDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerAccounts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerAccounts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param fundsCenterFilter (optional) 
     * @param maxConsumableBudgetFilter (optional) 
     * @param minConsumableBudgetFilter (optional) 
     * @param maxConsumedBudgetFilter (optional) 
     * @param minConsumedBudgetFilter (optional) 
     * @param maxAvailableAmountFilter (optional) 
     * @param minAvailableAmountFilter (optional) 
     * @param maxCurrentBudgetFilter (optional) 
     * @param minCurrentBudgetFilter (optional) 
     * @param maxCommitmentActualsFilter (optional) 
     * @param minCommitmentActualsFilter (optional) 
     * @param fundsCenterDescriptionFilter (optional) 
     * @param costCenterCostCenterNameFilter (optional) 
     * @return Success
     */
    getGeneralLedgerAccountsToExcel(filter: string | undefined, fundsCenterFilter: string | undefined, maxConsumableBudgetFilter: number | undefined, minConsumableBudgetFilter: number | undefined, maxConsumedBudgetFilter: number | undefined, minConsumedBudgetFilter: number | undefined, maxAvailableAmountFilter: number | undefined, minAvailableAmountFilter: number | undefined, maxCurrentBudgetFilter: number | undefined, minCurrentBudgetFilter: number | undefined, maxCommitmentActualsFilter: number | undefined, minCommitmentActualsFilter: number | undefined, fundsCenterDescriptionFilter: string | undefined, costCenterCostCenterNameFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerAccounts/GetGeneralLedgerAccountsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (fundsCenterFilter === null)
            throw new Error("The parameter 'fundsCenterFilter' cannot be null.");
        else if (fundsCenterFilter !== undefined)
            url_ += "FundsCenterFilter=" + encodeURIComponent("" + fundsCenterFilter) + "&";
        if (maxConsumableBudgetFilter === null)
            throw new Error("The parameter 'maxConsumableBudgetFilter' cannot be null.");
        else if (maxConsumableBudgetFilter !== undefined)
            url_ += "MaxConsumableBudgetFilter=" + encodeURIComponent("" + maxConsumableBudgetFilter) + "&";
        if (minConsumableBudgetFilter === null)
            throw new Error("The parameter 'minConsumableBudgetFilter' cannot be null.");
        else if (minConsumableBudgetFilter !== undefined)
            url_ += "MinConsumableBudgetFilter=" + encodeURIComponent("" + minConsumableBudgetFilter) + "&";
        if (maxConsumedBudgetFilter === null)
            throw new Error("The parameter 'maxConsumedBudgetFilter' cannot be null.");
        else if (maxConsumedBudgetFilter !== undefined)
            url_ += "MaxConsumedBudgetFilter=" + encodeURIComponent("" + maxConsumedBudgetFilter) + "&";
        if (minConsumedBudgetFilter === null)
            throw new Error("The parameter 'minConsumedBudgetFilter' cannot be null.");
        else if (minConsumedBudgetFilter !== undefined)
            url_ += "MinConsumedBudgetFilter=" + encodeURIComponent("" + minConsumedBudgetFilter) + "&";
        if (maxAvailableAmountFilter === null)
            throw new Error("The parameter 'maxAvailableAmountFilter' cannot be null.");
        else if (maxAvailableAmountFilter !== undefined)
            url_ += "MaxAvailableAmountFilter=" + encodeURIComponent("" + maxAvailableAmountFilter) + "&";
        if (minAvailableAmountFilter === null)
            throw new Error("The parameter 'minAvailableAmountFilter' cannot be null.");
        else if (minAvailableAmountFilter !== undefined)
            url_ += "MinAvailableAmountFilter=" + encodeURIComponent("" + minAvailableAmountFilter) + "&";
        if (maxCurrentBudgetFilter === null)
            throw new Error("The parameter 'maxCurrentBudgetFilter' cannot be null.");
        else if (maxCurrentBudgetFilter !== undefined)
            url_ += "MaxCurrentBudgetFilter=" + encodeURIComponent("" + maxCurrentBudgetFilter) + "&";
        if (minCurrentBudgetFilter === null)
            throw new Error("The parameter 'minCurrentBudgetFilter' cannot be null.");
        else if (minCurrentBudgetFilter !== undefined)
            url_ += "MinCurrentBudgetFilter=" + encodeURIComponent("" + minCurrentBudgetFilter) + "&";
        if (maxCommitmentActualsFilter === null)
            throw new Error("The parameter 'maxCommitmentActualsFilter' cannot be null.");
        else if (maxCommitmentActualsFilter !== undefined)
            url_ += "MaxCommitmentActualsFilter=" + encodeURIComponent("" + maxCommitmentActualsFilter) + "&";
        if (minCommitmentActualsFilter === null)
            throw new Error("The parameter 'minCommitmentActualsFilter' cannot be null.");
        else if (minCommitmentActualsFilter !== undefined)
            url_ += "MinCommitmentActualsFilter=" + encodeURIComponent("" + minCommitmentActualsFilter) + "&";
        if (fundsCenterDescriptionFilter === null)
            throw new Error("The parameter 'fundsCenterDescriptionFilter' cannot be null.");
        else if (fundsCenterDescriptionFilter !== undefined)
            url_ += "FundsCenterDescriptionFilter=" + encodeURIComponent("" + fundsCenterDescriptionFilter) + "&";
        if (costCenterCostCenterNameFilter === null)
            throw new Error("The parameter 'costCenterCostCenterNameFilter' cannot be null.");
        else if (costCenterCostCenterNameFilter !== undefined)
            url_ += "CostCenterCostCenterNameFilter=" + encodeURIComponent("" + costCenterCostCenterNameFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralLedgerAccountsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralLedgerAccountsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetGeneralLedgerAccountsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCostCenterForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGeneralLedgerAccountCostCenterLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerAccounts/GetAllCostCenterForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCostCenterForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCostCenterForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGeneralLedgerAccountCostCenterLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGeneralLedgerAccountCostCenterLookupTableDto>;
        }));
    }

    protected processGetAllCostCenterForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfGeneralLedgerAccountCostCenterLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGeneralLedgerAccountCostCenterLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GeneralLedgerMappingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param gLAccountFilter (optional) 
     * @param gLAccountDescriptionFilter (optional) 
     * @param mappingTypeFilter (optional) 
     * @param valuationClassFilter (optional) 
     * @param valuationClassDescriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, gLAccountFilter: string | undefined, gLAccountDescriptionFilter: string | undefined, mappingTypeFilter: string | undefined, valuationClassFilter: string | undefined, valuationClassDescriptionFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetGeneralLedgerMappingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerMappings/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (gLAccountFilter === null)
            throw new Error("The parameter 'gLAccountFilter' cannot be null.");
        else if (gLAccountFilter !== undefined)
            url_ += "GLAccountFilter=" + encodeURIComponent("" + gLAccountFilter) + "&";
        if (gLAccountDescriptionFilter === null)
            throw new Error("The parameter 'gLAccountDescriptionFilter' cannot be null.");
        else if (gLAccountDescriptionFilter !== undefined)
            url_ += "GLAccountDescriptionFilter=" + encodeURIComponent("" + gLAccountDescriptionFilter) + "&";
        if (mappingTypeFilter === null)
            throw new Error("The parameter 'mappingTypeFilter' cannot be null.");
        else if (mappingTypeFilter !== undefined)
            url_ += "MappingTypeFilter=" + encodeURIComponent("" + mappingTypeFilter) + "&";
        if (valuationClassFilter === null)
            throw new Error("The parameter 'valuationClassFilter' cannot be null.");
        else if (valuationClassFilter !== undefined)
            url_ += "ValuationClassFilter=" + encodeURIComponent("" + valuationClassFilter) + "&";
        if (valuationClassDescriptionFilter === null)
            throw new Error("The parameter 'valuationClassDescriptionFilter' cannot be null.");
        else if (valuationClassDescriptionFilter !== undefined)
            url_ += "ValuationClassDescriptionFilter=" + encodeURIComponent("" + valuationClassDescriptionFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetGeneralLedgerMappingForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetGeneralLedgerMappingForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetGeneralLedgerMappingForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetGeneralLedgerMappingForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGeneralLedgerMappingForView(id: string | undefined): Observable<GetGeneralLedgerMappingForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerMappings/GetGeneralLedgerMappingForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralLedgerMappingForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralLedgerMappingForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGeneralLedgerMappingForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGeneralLedgerMappingForViewDto>;
        }));
    }

    protected processGetGeneralLedgerMappingForView(response: HttpResponseBase): Observable<GetGeneralLedgerMappingForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralLedgerMappingForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGeneralLedgerMappingForEdit(id: string | undefined): Observable<GetGeneralLedgerMappingForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerMappings/GetGeneralLedgerMappingForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralLedgerMappingForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralLedgerMappingForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGeneralLedgerMappingForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGeneralLedgerMappingForEditOutput>;
        }));
    }

    protected processGetGeneralLedgerMappingForEdit(response: HttpResponseBase): Observable<GetGeneralLedgerMappingForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralLedgerMappingForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditGeneralLedgerMappingDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerMappings/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerMappings/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param gLAccountFilter (optional) 
     * @param gLAccountDescriptionFilter (optional) 
     * @param mappingTypeFilter (optional) 
     * @param valuationClassFilter (optional) 
     * @param valuationClassDescriptionFilter (optional) 
     * @return Success
     */
    getGeneralLedgerMappingsToExcel(filter: string | undefined, gLAccountFilter: string | undefined, gLAccountDescriptionFilter: string | undefined, mappingTypeFilter: string | undefined, valuationClassFilter: string | undefined, valuationClassDescriptionFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/GeneralLedgerMappings/GetGeneralLedgerMappingsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (gLAccountFilter === null)
            throw new Error("The parameter 'gLAccountFilter' cannot be null.");
        else if (gLAccountFilter !== undefined)
            url_ += "GLAccountFilter=" + encodeURIComponent("" + gLAccountFilter) + "&";
        if (gLAccountDescriptionFilter === null)
            throw new Error("The parameter 'gLAccountDescriptionFilter' cannot be null.");
        else if (gLAccountDescriptionFilter !== undefined)
            url_ += "GLAccountDescriptionFilter=" + encodeURIComponent("" + gLAccountDescriptionFilter) + "&";
        if (mappingTypeFilter === null)
            throw new Error("The parameter 'mappingTypeFilter' cannot be null.");
        else if (mappingTypeFilter !== undefined)
            url_ += "MappingTypeFilter=" + encodeURIComponent("" + mappingTypeFilter) + "&";
        if (valuationClassFilter === null)
            throw new Error("The parameter 'valuationClassFilter' cannot be null.");
        else if (valuationClassFilter !== undefined)
            url_ += "ValuationClassFilter=" + encodeURIComponent("" + valuationClassFilter) + "&";
        if (valuationClassDescriptionFilter === null)
            throw new Error("The parameter 'valuationClassDescriptionFilter' cannot be null.");
        else if (valuationClassDescriptionFilter !== undefined)
            url_ += "ValuationClassDescriptionFilter=" + encodeURIComponent("" + valuationClassDescriptionFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralLedgerMappingsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralLedgerMappingsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetGeneralLedgerMappingsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getTopStatsData(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<TopStatsData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetTopStatsData?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStatsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStatsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TopStatsData>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TopStatsData>;
        }));
    }

    protected processGetTopStatsData(response: HttpResponseBase): Observable<TopStatsData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TopStatsData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRecentTenantsData(): Observable<GetRecentTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetRecentTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentTenantsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRecentTenantsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRecentTenantsOutput>;
        }));
    }

    protected processGetRecentTenantsData(response: HttpResponseBase): Observable<GetRecentTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRecentTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getSubscriptionExpiringTenantsData(): Observable<GetExpiringTenantsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetSubscriptionExpiringTenantsData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscriptionExpiringTenantsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscriptionExpiringTenantsData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetExpiringTenantsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetExpiringTenantsOutput>;
        }));
    }

    protected processGetSubscriptionExpiringTenantsData(response: HttpResponseBase): Observable<GetExpiringTenantsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetExpiringTenantsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetIncomeStatisticsDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetIncomeStatisticsDataOutput>;
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncomeStatisticsDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetEditionTenantStatisticsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetEditionTenantStatisticsOutput>;
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionTenantStatisticsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<HostSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<HostSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: HostSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginSettingsDto>;
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setup(body: InstallDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AppSettingsJsonDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AppSettingsJsonDto>;
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingsJsonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CheckDatabaseOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CheckDatabaseOutput>;
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckDatabaseOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<InvoiceDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<InvoiceDto>;
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createInvoice(body: CreateInvoiceDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class JobSynchronizesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param jobNameFilter (optional) 
     * @param jobTypeFilter (optional) 
     * @param dataSourceFilter (optional) 
     * @param lastStatusFilter (optional) 
     * @param uriFilter (optional) 
     * @param maxLastUpdateFilter (optional) 
     * @param minLastUpdateFilter (optional) 
     * @param maxTotalInsertFilter (optional) 
     * @param minTotalInsertFilter (optional) 
     * @param maxTotalUpdateFilter (optional) 
     * @param minTotalUpdateFilter (optional) 
     * @param maxTotalDeleteFilter (optional) 
     * @param minTotalDeleteFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, jobNameFilter: string | undefined, jobTypeFilter: number | undefined, dataSourceFilter: string | undefined, lastStatusFilter: number | undefined, uriFilter: string | undefined, maxLastUpdateFilter: DateTime | undefined, minLastUpdateFilter: DateTime | undefined, maxTotalInsertFilter: number | undefined, minTotalInsertFilter: number | undefined, maxTotalUpdateFilter: number | undefined, minTotalUpdateFilter: number | undefined, maxTotalDeleteFilter: number | undefined, minTotalDeleteFilter: number | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetJobSynchronizeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/JobSynchronizes/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (jobNameFilter === null)
            throw new Error("The parameter 'jobNameFilter' cannot be null.");
        else if (jobNameFilter !== undefined)
            url_ += "JobNameFilter=" + encodeURIComponent("" + jobNameFilter) + "&";
        if (jobTypeFilter === null)
            throw new Error("The parameter 'jobTypeFilter' cannot be null.");
        else if (jobTypeFilter !== undefined)
            url_ += "JobTypeFilter=" + encodeURIComponent("" + jobTypeFilter) + "&";
        if (dataSourceFilter === null)
            throw new Error("The parameter 'dataSourceFilter' cannot be null.");
        else if (dataSourceFilter !== undefined)
            url_ += "DataSourceFilter=" + encodeURIComponent("" + dataSourceFilter) + "&";
        if (lastStatusFilter === null)
            throw new Error("The parameter 'lastStatusFilter' cannot be null.");
        else if (lastStatusFilter !== undefined)
            url_ += "LastStatusFilter=" + encodeURIComponent("" + lastStatusFilter) + "&";
        if (uriFilter === null)
            throw new Error("The parameter 'uriFilter' cannot be null.");
        else if (uriFilter !== undefined)
            url_ += "UriFilter=" + encodeURIComponent("" + uriFilter) + "&";
        if (maxLastUpdateFilter === null)
            throw new Error("The parameter 'maxLastUpdateFilter' cannot be null.");
        else if (maxLastUpdateFilter !== undefined)
            url_ += "MaxLastUpdateFilter=" + encodeURIComponent(maxLastUpdateFilter ? "" + maxLastUpdateFilter.toString() : "") + "&";
        if (minLastUpdateFilter === null)
            throw new Error("The parameter 'minLastUpdateFilter' cannot be null.");
        else if (minLastUpdateFilter !== undefined)
            url_ += "MinLastUpdateFilter=" + encodeURIComponent(minLastUpdateFilter ? "" + minLastUpdateFilter.toString() : "") + "&";
        if (maxTotalInsertFilter === null)
            throw new Error("The parameter 'maxTotalInsertFilter' cannot be null.");
        else if (maxTotalInsertFilter !== undefined)
            url_ += "MaxTotalInsertFilter=" + encodeURIComponent("" + maxTotalInsertFilter) + "&";
        if (minTotalInsertFilter === null)
            throw new Error("The parameter 'minTotalInsertFilter' cannot be null.");
        else if (minTotalInsertFilter !== undefined)
            url_ += "MinTotalInsertFilter=" + encodeURIComponent("" + minTotalInsertFilter) + "&";
        if (maxTotalUpdateFilter === null)
            throw new Error("The parameter 'maxTotalUpdateFilter' cannot be null.");
        else if (maxTotalUpdateFilter !== undefined)
            url_ += "MaxTotalUpdateFilter=" + encodeURIComponent("" + maxTotalUpdateFilter) + "&";
        if (minTotalUpdateFilter === null)
            throw new Error("The parameter 'minTotalUpdateFilter' cannot be null.");
        else if (minTotalUpdateFilter !== undefined)
            url_ += "MinTotalUpdateFilter=" + encodeURIComponent("" + minTotalUpdateFilter) + "&";
        if (maxTotalDeleteFilter === null)
            throw new Error("The parameter 'maxTotalDeleteFilter' cannot be null.");
        else if (maxTotalDeleteFilter !== undefined)
            url_ += "MaxTotalDeleteFilter=" + encodeURIComponent("" + maxTotalDeleteFilter) + "&";
        if (minTotalDeleteFilter === null)
            throw new Error("The parameter 'minTotalDeleteFilter' cannot be null.");
        else if (minTotalDeleteFilter !== undefined)
            url_ += "MinTotalDeleteFilter=" + encodeURIComponent("" + minTotalDeleteFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetJobSynchronizeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetJobSynchronizeForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetJobSynchronizeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetJobSynchronizeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getJobSynchronizeForView(id: string | undefined): Observable<GetJobSynchronizeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/JobSynchronizes/GetJobSynchronizeForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobSynchronizeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobSynchronizeForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJobSynchronizeForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJobSynchronizeForViewDto>;
        }));
    }

    protected processGetJobSynchronizeForView(response: HttpResponseBase): Observable<GetJobSynchronizeForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJobSynchronizeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getJobSynchronizeForEdit(id: string | undefined): Observable<GetJobSynchronizeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/JobSynchronizes/GetJobSynchronizeForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobSynchronizeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobSynchronizeForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetJobSynchronizeForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetJobSynchronizeForEditOutput>;
        }));
    }

    protected processGetJobSynchronizeForEdit(response: HttpResponseBase): Observable<GetJobSynchronizeForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetJobSynchronizeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditJobSynchronizeDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobSynchronizes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/JobSynchronizes/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param jobNameFilter (optional) 
     * @param jobTypeFilter (optional) 
     * @param dataSourceFilter (optional) 
     * @param lastStatusFilter (optional) 
     * @param uriFilter (optional) 
     * @param maxLastUpdateFilter (optional) 
     * @param minLastUpdateFilter (optional) 
     * @param maxTotalInsertFilter (optional) 
     * @param minTotalInsertFilter (optional) 
     * @param maxTotalUpdateFilter (optional) 
     * @param minTotalUpdateFilter (optional) 
     * @param maxTotalDeleteFilter (optional) 
     * @param minTotalDeleteFilter (optional) 
     * @return Success
     */
    getJobSynchronizesToExcel(filter: string | undefined, jobNameFilter: string | undefined, jobTypeFilter: number | undefined, dataSourceFilter: string | undefined, lastStatusFilter: number | undefined, uriFilter: string | undefined, maxLastUpdateFilter: DateTime | undefined, minLastUpdateFilter: DateTime | undefined, maxTotalInsertFilter: number | undefined, minTotalInsertFilter: number | undefined, maxTotalUpdateFilter: number | undefined, minTotalUpdateFilter: number | undefined, maxTotalDeleteFilter: number | undefined, minTotalDeleteFilter: number | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/JobSynchronizes/GetJobSynchronizesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (jobNameFilter === null)
            throw new Error("The parameter 'jobNameFilter' cannot be null.");
        else if (jobNameFilter !== undefined)
            url_ += "JobNameFilter=" + encodeURIComponent("" + jobNameFilter) + "&";
        if (jobTypeFilter === null)
            throw new Error("The parameter 'jobTypeFilter' cannot be null.");
        else if (jobTypeFilter !== undefined)
            url_ += "JobTypeFilter=" + encodeURIComponent("" + jobTypeFilter) + "&";
        if (dataSourceFilter === null)
            throw new Error("The parameter 'dataSourceFilter' cannot be null.");
        else if (dataSourceFilter !== undefined)
            url_ += "DataSourceFilter=" + encodeURIComponent("" + dataSourceFilter) + "&";
        if (lastStatusFilter === null)
            throw new Error("The parameter 'lastStatusFilter' cannot be null.");
        else if (lastStatusFilter !== undefined)
            url_ += "LastStatusFilter=" + encodeURIComponent("" + lastStatusFilter) + "&";
        if (uriFilter === null)
            throw new Error("The parameter 'uriFilter' cannot be null.");
        else if (uriFilter !== undefined)
            url_ += "UriFilter=" + encodeURIComponent("" + uriFilter) + "&";
        if (maxLastUpdateFilter === null)
            throw new Error("The parameter 'maxLastUpdateFilter' cannot be null.");
        else if (maxLastUpdateFilter !== undefined)
            url_ += "MaxLastUpdateFilter=" + encodeURIComponent(maxLastUpdateFilter ? "" + maxLastUpdateFilter.toString() : "") + "&";
        if (minLastUpdateFilter === null)
            throw new Error("The parameter 'minLastUpdateFilter' cannot be null.");
        else if (minLastUpdateFilter !== undefined)
            url_ += "MinLastUpdateFilter=" + encodeURIComponent(minLastUpdateFilter ? "" + minLastUpdateFilter.toString() : "") + "&";
        if (maxTotalInsertFilter === null)
            throw new Error("The parameter 'maxTotalInsertFilter' cannot be null.");
        else if (maxTotalInsertFilter !== undefined)
            url_ += "MaxTotalInsertFilter=" + encodeURIComponent("" + maxTotalInsertFilter) + "&";
        if (minTotalInsertFilter === null)
            throw new Error("The parameter 'minTotalInsertFilter' cannot be null.");
        else if (minTotalInsertFilter !== undefined)
            url_ += "MinTotalInsertFilter=" + encodeURIComponent("" + minTotalInsertFilter) + "&";
        if (maxTotalUpdateFilter === null)
            throw new Error("The parameter 'maxTotalUpdateFilter' cannot be null.");
        else if (maxTotalUpdateFilter !== undefined)
            url_ += "MaxTotalUpdateFilter=" + encodeURIComponent("" + maxTotalUpdateFilter) + "&";
        if (minTotalUpdateFilter === null)
            throw new Error("The parameter 'minTotalUpdateFilter' cannot be null.");
        else if (minTotalUpdateFilter !== undefined)
            url_ += "MinTotalUpdateFilter=" + encodeURIComponent("" + minTotalUpdateFilter) + "&";
        if (maxTotalDeleteFilter === null)
            throw new Error("The parameter 'maxTotalDeleteFilter' cannot be null.");
        else if (maxTotalDeleteFilter !== undefined)
            url_ += "MaxTotalDeleteFilter=" + encodeURIComponent("" + maxTotalDeleteFilter) + "&";
        if (minTotalDeleteFilter === null)
            throw new Error("The parameter 'minTotalDeleteFilter' cannot be null.");
        else if (minTotalDeleteFilter !== undefined)
            url_ += "MinTotalDeleteFilter=" + encodeURIComponent("" + minTotalDeleteFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetJobSynchronizesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetJobSynchronizesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetJobSynchronizesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLanguagesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLanguagesOutput>;
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLanguageForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLanguageForEditOutput>;
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateLanguage(body: CreateOrUpdateLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setDefaultLanguage(body: SetDefaultLanguageInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined, sourceName: string, baseLanguageName: string | undefined, targetLanguageName: string, targetValueFilter: string | undefined, filterText: string | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&";
        if (baseLanguageName === null)
            throw new Error("The parameter 'baseLanguageName' cannot be null.");
        else if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&";
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&";
        if (targetValueFilter === null)
            throw new Error("The parameter 'targetValueFilter' cannot be null.");
        else if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&";
        if (filterText === null)
            throw new Error("The parameter 'filterText' cannot be null.");
        else if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLanguageTextListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLanguageTextListDto>;
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageTextListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateLanguageText(body: UpdateLanguageTextInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class LookupPagesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param lookupNameFilter (optional) 
     * @param costCenterDisplayPropertyFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, lookupNameFilter: string | undefined, costCenterDisplayPropertyFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetLookupPageForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LookupPages/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (lookupNameFilter === null)
            throw new Error("The parameter 'lookupNameFilter' cannot be null.");
        else if (lookupNameFilter !== undefined)
            url_ += "LookupNameFilter=" + encodeURIComponent("" + lookupNameFilter) + "&";
        if (costCenterDisplayPropertyFilter === null)
            throw new Error("The parameter 'costCenterDisplayPropertyFilter' cannot be null.");
        else if (costCenterDisplayPropertyFilter !== undefined)
            url_ += "CostCenterDisplayPropertyFilter=" + encodeURIComponent("" + costCenterDisplayPropertyFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetLookupPageForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetLookupPageForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetLookupPageForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetLookupPageForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLookupPageForView(id: string | undefined): Observable<GetLookupPageForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LookupPages/GetLookupPageForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookupPageForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookupPageForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLookupPageForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLookupPageForViewDto>;
        }));
    }

    protected processGetLookupPageForView(response: HttpResponseBase): Observable<GetLookupPageForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLookupPageForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLookupPageForEdit(id: string | undefined): Observable<GetLookupPageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/LookupPages/GetLookupPageForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookupPageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookupPageForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLookupPageForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLookupPageForEditOutput>;
        }));
    }

    protected processGetLookupPageForEdit(response: HttpResponseBase): Observable<GetLookupPageForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLookupPageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditLookupPageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LookupPages/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LookupPages/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param lookupNameFilter (optional) 
     * @param costCenterDisplayPropertyFilter (optional) 
     * @return Success
     */
    getLookupPagesToExcel(filter: string | undefined, lookupNameFilter: string | undefined, costCenterDisplayPropertyFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/LookupPages/GetLookupPagesToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (lookupNameFilter === null)
            throw new Error("The parameter 'lookupNameFilter' cannot be null.");
        else if (lookupNameFilter !== undefined)
            url_ += "LookupNameFilter=" + encodeURIComponent("" + lookupNameFilter) + "&";
        if (costCenterDisplayPropertyFilter === null)
            throw new Error("The parameter 'costCenterDisplayPropertyFilter' cannot be null.");
        else if (costCenterDisplayPropertyFilter !== undefined)
            url_ += "CostCenterDisplayPropertyFilter=" + encodeURIComponent("" + costCenterDisplayPropertyFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLookupPagesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLookupPagesToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetLookupPagesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCostCenterForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfLookupPageCostCenterLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/LookupPages/GetAllCostCenterForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCostCenterForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCostCenterForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLookupPageCostCenterLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLookupPageCostCenterLookupTableDto>;
        }));
    }

    protected processGetAllCostCenterForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLookupPageCostCenterLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLookupPageCostCenterLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MaterialGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param materialGroupCodeFilter (optional) 
     * @param materialGroupNameFilter (optional) 
     * @param materialGroupDescriptionFilter (optional) 
     * @param languageFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, materialGroupCodeFilter: string | undefined, materialGroupNameFilter: string | undefined, materialGroupDescriptionFilter: string | undefined, languageFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMaterialGroupForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialGroups/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (materialGroupCodeFilter === null)
            throw new Error("The parameter 'materialGroupCodeFilter' cannot be null.");
        else if (materialGroupCodeFilter !== undefined)
            url_ += "MaterialGroupCodeFilter=" + encodeURIComponent("" + materialGroupCodeFilter) + "&";
        if (materialGroupNameFilter === null)
            throw new Error("The parameter 'materialGroupNameFilter' cannot be null.");
        else if (materialGroupNameFilter !== undefined)
            url_ += "MaterialGroupNameFilter=" + encodeURIComponent("" + materialGroupNameFilter) + "&";
        if (materialGroupDescriptionFilter === null)
            throw new Error("The parameter 'materialGroupDescriptionFilter' cannot be null.");
        else if (materialGroupDescriptionFilter !== undefined)
            url_ += "MaterialGroupDescriptionFilter=" + encodeURIComponent("" + materialGroupDescriptionFilter) + "&";
        if (languageFilter === null)
            throw new Error("The parameter 'languageFilter' cannot be null.");
        else if (languageFilter !== undefined)
            url_ += "LanguageFilter=" + encodeURIComponent("" + languageFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetMaterialGroupForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetMaterialGroupForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaterialGroupForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMaterialGroupForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialGroupForView(id: string | undefined): Observable<GetMaterialGroupForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialGroups/GetMaterialGroupForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialGroupForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialGroupForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMaterialGroupForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMaterialGroupForViewDto>;
        }));
    }

    protected processGetMaterialGroupForView(response: HttpResponseBase): Observable<GetMaterialGroupForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaterialGroupForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialGroupForEdit(id: string | undefined): Observable<GetMaterialGroupForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialGroups/GetMaterialGroupForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialGroupForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialGroupForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMaterialGroupForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMaterialGroupForEditOutput>;
        }));
    }

    protected processGetMaterialGroupForEdit(response: HttpResponseBase): Observable<GetMaterialGroupForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaterialGroupForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMaterialGroupDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialGroups/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialGroups/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param materialGroupCodeFilter (optional) 
     * @param materialGroupNameFilter (optional) 
     * @param materialGroupDescriptionFilter (optional) 
     * @param languageFilter (optional) 
     * @return Success
     */
    getMaterialGroupsToExcel(filter: string | undefined, materialGroupCodeFilter: string | undefined, materialGroupNameFilter: string | undefined, materialGroupDescriptionFilter: string | undefined, languageFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialGroups/GetMaterialGroupsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (materialGroupCodeFilter === null)
            throw new Error("The parameter 'materialGroupCodeFilter' cannot be null.");
        else if (materialGroupCodeFilter !== undefined)
            url_ += "MaterialGroupCodeFilter=" + encodeURIComponent("" + materialGroupCodeFilter) + "&";
        if (materialGroupNameFilter === null)
            throw new Error("The parameter 'materialGroupNameFilter' cannot be null.");
        else if (materialGroupNameFilter !== undefined)
            url_ += "MaterialGroupNameFilter=" + encodeURIComponent("" + materialGroupNameFilter) + "&";
        if (materialGroupDescriptionFilter === null)
            throw new Error("The parameter 'materialGroupDescriptionFilter' cannot be null.");
        else if (materialGroupDescriptionFilter !== undefined)
            url_ += "MaterialGroupDescriptionFilter=" + encodeURIComponent("" + materialGroupDescriptionFilter) + "&";
        if (languageFilter === null)
            throw new Error("The parameter 'languageFilter' cannot be null.");
        else if (languageFilter !== undefined)
            url_ += "LanguageFilter=" + encodeURIComponent("" + languageFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialGroupsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialGroupsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetMaterialGroupsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MaterialRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param requestNoFilter (optional) 
     * @param requestStatusFilter (optional) 
     * @param materialNameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param purposeFilter (optional) 
     * @param materialTypeFilter (optional) 
     * @param categoryFilter (optional) 
     * @param sizeFilter (optional) 
     * @param uoMFilter (optional) 
     * @param packageSizeFilter (optional) 
     * @param generalLedgerFilter (optional) 
     * @param brandFilter (optional) 
     * @param weightFilter (optional) 
     * @param imageColletionFilter (optional) 
     * @param uNSPSCDisplayPropertyFilter (optional) 
     * @param generalLedgerMappingDisplayPropertyFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, requestNoFilter: string | undefined, requestStatusFilter: number | undefined, materialNameFilter: string | undefined, descriptionFilter: string | undefined, purposeFilter: string | undefined, materialTypeFilter: string | undefined, categoryFilter: string | undefined, sizeFilter: string | undefined, uoMFilter: string | undefined, packageSizeFilter: string | undefined, generalLedgerFilter: string | undefined, brandFilter: string | undefined, weightFilter: string | undefined, imageColletionFilter: string | undefined, uNSPSCDisplayPropertyFilter: string | undefined, generalLedgerMappingDisplayPropertyFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMaterialRequestForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequests/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (requestNoFilter === null)
            throw new Error("The parameter 'requestNoFilter' cannot be null.");
        else if (requestNoFilter !== undefined)
            url_ += "RequestNoFilter=" + encodeURIComponent("" + requestNoFilter) + "&";
        if (requestStatusFilter === null)
            throw new Error("The parameter 'requestStatusFilter' cannot be null.");
        else if (requestStatusFilter !== undefined)
            url_ += "RequestStatusFilter=" + encodeURIComponent("" + requestStatusFilter) + "&";
        if (materialNameFilter === null)
            throw new Error("The parameter 'materialNameFilter' cannot be null.");
        else if (materialNameFilter !== undefined)
            url_ += "MaterialNameFilter=" + encodeURIComponent("" + materialNameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (purposeFilter === null)
            throw new Error("The parameter 'purposeFilter' cannot be null.");
        else if (purposeFilter !== undefined)
            url_ += "PurposeFilter=" + encodeURIComponent("" + purposeFilter) + "&";
        if (materialTypeFilter === null)
            throw new Error("The parameter 'materialTypeFilter' cannot be null.");
        else if (materialTypeFilter !== undefined)
            url_ += "MaterialTypeFilter=" + encodeURIComponent("" + materialTypeFilter) + "&";
        if (categoryFilter === null)
            throw new Error("The parameter 'categoryFilter' cannot be null.");
        else if (categoryFilter !== undefined)
            url_ += "CategoryFilter=" + encodeURIComponent("" + categoryFilter) + "&";
        if (sizeFilter === null)
            throw new Error("The parameter 'sizeFilter' cannot be null.");
        else if (sizeFilter !== undefined)
            url_ += "SizeFilter=" + encodeURIComponent("" + sizeFilter) + "&";
        if (uoMFilter === null)
            throw new Error("The parameter 'uoMFilter' cannot be null.");
        else if (uoMFilter !== undefined)
            url_ += "UoMFilter=" + encodeURIComponent("" + uoMFilter) + "&";
        if (packageSizeFilter === null)
            throw new Error("The parameter 'packageSizeFilter' cannot be null.");
        else if (packageSizeFilter !== undefined)
            url_ += "PackageSizeFilter=" + encodeURIComponent("" + packageSizeFilter) + "&";
        if (generalLedgerFilter === null)
            throw new Error("The parameter 'generalLedgerFilter' cannot be null.");
        else if (generalLedgerFilter !== undefined)
            url_ += "GeneralLedgerFilter=" + encodeURIComponent("" + generalLedgerFilter) + "&";
        if (brandFilter === null)
            throw new Error("The parameter 'brandFilter' cannot be null.");
        else if (brandFilter !== undefined)
            url_ += "BrandFilter=" + encodeURIComponent("" + brandFilter) + "&";
        if (weightFilter === null)
            throw new Error("The parameter 'weightFilter' cannot be null.");
        else if (weightFilter !== undefined)
            url_ += "WeightFilter=" + encodeURIComponent("" + weightFilter) + "&";
        if (imageColletionFilter === null)
            throw new Error("The parameter 'imageColletionFilter' cannot be null.");
        else if (imageColletionFilter !== undefined)
            url_ += "ImageColletionFilter=" + encodeURIComponent("" + imageColletionFilter) + "&";
        if (uNSPSCDisplayPropertyFilter === null)
            throw new Error("The parameter 'uNSPSCDisplayPropertyFilter' cannot be null.");
        else if (uNSPSCDisplayPropertyFilter !== undefined)
            url_ += "UNSPSCDisplayPropertyFilter=" + encodeURIComponent("" + uNSPSCDisplayPropertyFilter) + "&";
        if (generalLedgerMappingDisplayPropertyFilter === null)
            throw new Error("The parameter 'generalLedgerMappingDisplayPropertyFilter' cannot be null.");
        else if (generalLedgerMappingDisplayPropertyFilter !== undefined)
            url_ += "GeneralLedgerMappingDisplayPropertyFilter=" + encodeURIComponent("" + generalLedgerMappingDisplayPropertyFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetMaterialRequestForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetMaterialRequestForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaterialRequestForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMaterialRequestForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialRequestForView(id: string | undefined): Observable<GetMaterialRequestForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequests/GetMaterialRequestForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialRequestForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialRequestForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMaterialRequestForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMaterialRequestForViewDto>;
        }));
    }

    protected processGetMaterialRequestForView(response: HttpResponseBase): Observable<GetMaterialRequestForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaterialRequestForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialRequestForEdit(id: string | undefined): Observable<GetMaterialRequestForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequests/GetMaterialRequestForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialRequestForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialRequestForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMaterialRequestForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMaterialRequestForEditOutput>;
        }));
    }

    protected processGetMaterialRequestForEdit(response: HttpResponseBase): Observable<GetMaterialRequestForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaterialRequestForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMaterialRequestDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequests/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequests/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param requestNoFilter (optional) 
     * @param requestStatusFilter (optional) 
     * @param materialNameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param purposeFilter (optional) 
     * @param materialTypeFilter (optional) 
     * @param categoryFilter (optional) 
     * @param sizeFilter (optional) 
     * @param uoMFilter (optional) 
     * @param packageSizeFilter (optional) 
     * @param generalLedgerFilter (optional) 
     * @param brandFilter (optional) 
     * @param weightFilter (optional) 
     * @param imageColletionFilter (optional) 
     * @param uNSPSCDisplayPropertyFilter (optional) 
     * @param generalLedgerMappingDisplayPropertyFilter (optional) 
     * @return Success
     */
    getMaterialRequestsToExcel(filter: string | undefined, requestNoFilter: string | undefined, requestStatusFilter: number | undefined, materialNameFilter: string | undefined, descriptionFilter: string | undefined, purposeFilter: string | undefined, materialTypeFilter: string | undefined, categoryFilter: string | undefined, sizeFilter: string | undefined, uoMFilter: string | undefined, packageSizeFilter: string | undefined, generalLedgerFilter: string | undefined, brandFilter: string | undefined, weightFilter: string | undefined, imageColletionFilter: string | undefined, uNSPSCDisplayPropertyFilter: string | undefined, generalLedgerMappingDisplayPropertyFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequests/GetMaterialRequestsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (requestNoFilter === null)
            throw new Error("The parameter 'requestNoFilter' cannot be null.");
        else if (requestNoFilter !== undefined)
            url_ += "RequestNoFilter=" + encodeURIComponent("" + requestNoFilter) + "&";
        if (requestStatusFilter === null)
            throw new Error("The parameter 'requestStatusFilter' cannot be null.");
        else if (requestStatusFilter !== undefined)
            url_ += "RequestStatusFilter=" + encodeURIComponent("" + requestStatusFilter) + "&";
        if (materialNameFilter === null)
            throw new Error("The parameter 'materialNameFilter' cannot be null.");
        else if (materialNameFilter !== undefined)
            url_ += "MaterialNameFilter=" + encodeURIComponent("" + materialNameFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (purposeFilter === null)
            throw new Error("The parameter 'purposeFilter' cannot be null.");
        else if (purposeFilter !== undefined)
            url_ += "PurposeFilter=" + encodeURIComponent("" + purposeFilter) + "&";
        if (materialTypeFilter === null)
            throw new Error("The parameter 'materialTypeFilter' cannot be null.");
        else if (materialTypeFilter !== undefined)
            url_ += "MaterialTypeFilter=" + encodeURIComponent("" + materialTypeFilter) + "&";
        if (categoryFilter === null)
            throw new Error("The parameter 'categoryFilter' cannot be null.");
        else if (categoryFilter !== undefined)
            url_ += "CategoryFilter=" + encodeURIComponent("" + categoryFilter) + "&";
        if (sizeFilter === null)
            throw new Error("The parameter 'sizeFilter' cannot be null.");
        else if (sizeFilter !== undefined)
            url_ += "SizeFilter=" + encodeURIComponent("" + sizeFilter) + "&";
        if (uoMFilter === null)
            throw new Error("The parameter 'uoMFilter' cannot be null.");
        else if (uoMFilter !== undefined)
            url_ += "UoMFilter=" + encodeURIComponent("" + uoMFilter) + "&";
        if (packageSizeFilter === null)
            throw new Error("The parameter 'packageSizeFilter' cannot be null.");
        else if (packageSizeFilter !== undefined)
            url_ += "PackageSizeFilter=" + encodeURIComponent("" + packageSizeFilter) + "&";
        if (generalLedgerFilter === null)
            throw new Error("The parameter 'generalLedgerFilter' cannot be null.");
        else if (generalLedgerFilter !== undefined)
            url_ += "GeneralLedgerFilter=" + encodeURIComponent("" + generalLedgerFilter) + "&";
        if (brandFilter === null)
            throw new Error("The parameter 'brandFilter' cannot be null.");
        else if (brandFilter !== undefined)
            url_ += "BrandFilter=" + encodeURIComponent("" + brandFilter) + "&";
        if (weightFilter === null)
            throw new Error("The parameter 'weightFilter' cannot be null.");
        else if (weightFilter !== undefined)
            url_ += "WeightFilter=" + encodeURIComponent("" + weightFilter) + "&";
        if (imageColletionFilter === null)
            throw new Error("The parameter 'imageColletionFilter' cannot be null.");
        else if (imageColletionFilter !== undefined)
            url_ += "ImageColletionFilter=" + encodeURIComponent("" + imageColletionFilter) + "&";
        if (uNSPSCDisplayPropertyFilter === null)
            throw new Error("The parameter 'uNSPSCDisplayPropertyFilter' cannot be null.");
        else if (uNSPSCDisplayPropertyFilter !== undefined)
            url_ += "UNSPSCDisplayPropertyFilter=" + encodeURIComponent("" + uNSPSCDisplayPropertyFilter) + "&";
        if (generalLedgerMappingDisplayPropertyFilter === null)
            throw new Error("The parameter 'generalLedgerMappingDisplayPropertyFilter' cannot be null.");
        else if (generalLedgerMappingDisplayPropertyFilter !== undefined)
            url_ += "GeneralLedgerMappingDisplayPropertyFilter=" + encodeURIComponent("" + generalLedgerMappingDisplayPropertyFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialRequestsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialRequestsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetMaterialRequestsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUNSPSCForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMaterialRequestUNSPSCLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequests/GetAllUNSPSCForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUNSPSCForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUNSPSCForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMaterialRequestUNSPSCLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMaterialRequestUNSPSCLookupTableDto>;
        }));
    }

    protected processGetAllUNSPSCForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMaterialRequestUNSPSCLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMaterialRequestUNSPSCLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllGeneralLedgerMappingForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMaterialRequestGeneralLedgerMappingLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequests/GetAllGeneralLedgerMappingForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGeneralLedgerMappingForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGeneralLedgerMappingForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMaterialRequestGeneralLedgerMappingLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMaterialRequestGeneralLedgerMappingLookupTableDto>;
        }));
    }

    protected processGetAllGeneralLedgerMappingForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMaterialRequestGeneralLedgerMappingLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMaterialRequestGeneralLedgerMappingLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removePictureFile(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaterialRequests/RemovePictureFile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemovePictureFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemovePictureFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemovePictureFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class MaterialsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param materialNoFilter (optional) 
     * @param materialNameFilter (optional) 
     * @param materialNameSAPFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sizeFilter (optional) 
     * @param uoMFilter (optional) 
     * @param brandFilter (optional) 
     * @param materialGroupDisplayPropertyFilter (optional) 
     * @param uNSPSCDisplayPropertyFilter (optional) 
     * @param generalLedgerMappingDisplayPropertyFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, materialNoFilter: string | undefined, materialNameFilter: string | undefined, materialNameSAPFilter: string | undefined, descriptionFilter: string | undefined, sizeFilter: string | undefined, uoMFilter: string | undefined, brandFilter: string | undefined, materialGroupDisplayPropertyFilter: string | undefined, uNSPSCDisplayPropertyFilter: string | undefined, generalLedgerMappingDisplayPropertyFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetMaterialForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Materials/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (materialNoFilter === null)
            throw new Error("The parameter 'materialNoFilter' cannot be null.");
        else if (materialNoFilter !== undefined)
            url_ += "MaterialNoFilter=" + encodeURIComponent("" + materialNoFilter) + "&";
        if (materialNameFilter === null)
            throw new Error("The parameter 'materialNameFilter' cannot be null.");
        else if (materialNameFilter !== undefined)
            url_ += "MaterialNameFilter=" + encodeURIComponent("" + materialNameFilter) + "&";
        if (materialNameSAPFilter === null)
            throw new Error("The parameter 'materialNameSAPFilter' cannot be null.");
        else if (materialNameSAPFilter !== undefined)
            url_ += "MaterialNameSAPFilter=" + encodeURIComponent("" + materialNameSAPFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (sizeFilter === null)
            throw new Error("The parameter 'sizeFilter' cannot be null.");
        else if (sizeFilter !== undefined)
            url_ += "SizeFilter=" + encodeURIComponent("" + sizeFilter) + "&";
        if (uoMFilter === null)
            throw new Error("The parameter 'uoMFilter' cannot be null.");
        else if (uoMFilter !== undefined)
            url_ += "UoMFilter=" + encodeURIComponent("" + uoMFilter) + "&";
        if (brandFilter === null)
            throw new Error("The parameter 'brandFilter' cannot be null.");
        else if (brandFilter !== undefined)
            url_ += "BrandFilter=" + encodeURIComponent("" + brandFilter) + "&";
        if (materialGroupDisplayPropertyFilter === null)
            throw new Error("The parameter 'materialGroupDisplayPropertyFilter' cannot be null.");
        else if (materialGroupDisplayPropertyFilter !== undefined)
            url_ += "MaterialGroupDisplayPropertyFilter=" + encodeURIComponent("" + materialGroupDisplayPropertyFilter) + "&";
        if (uNSPSCDisplayPropertyFilter === null)
            throw new Error("The parameter 'uNSPSCDisplayPropertyFilter' cannot be null.");
        else if (uNSPSCDisplayPropertyFilter !== undefined)
            url_ += "UNSPSCDisplayPropertyFilter=" + encodeURIComponent("" + uNSPSCDisplayPropertyFilter) + "&";
        if (generalLedgerMappingDisplayPropertyFilter === null)
            throw new Error("The parameter 'generalLedgerMappingDisplayPropertyFilter' cannot be null.");
        else if (generalLedgerMappingDisplayPropertyFilter !== undefined)
            url_ += "GeneralLedgerMappingDisplayPropertyFilter=" + encodeURIComponent("" + generalLedgerMappingDisplayPropertyFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetMaterialForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetMaterialForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaterialForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMaterialForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialForView(id: string | undefined): Observable<GetMaterialForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Materials/GetMaterialForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMaterialForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMaterialForViewDto>;
        }));
    }

    protected processGetMaterialForView(response: HttpResponseBase): Observable<GetMaterialForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaterialForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaterialForEdit(id: string | undefined): Observable<GetMaterialForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Materials/GetMaterialForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMaterialForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMaterialForEditOutput>;
        }));
    }

    protected processGetMaterialForEdit(response: HttpResponseBase): Observable<GetMaterialForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaterialForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditMaterialDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Materials/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Materials/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param materialNoFilter (optional) 
     * @param materialNameFilter (optional) 
     * @param materialNameSAPFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sizeFilter (optional) 
     * @param uoMFilter (optional) 
     * @param brandFilter (optional) 
     * @param materialGroupDisplayPropertyFilter (optional) 
     * @param uNSPSCDisplayPropertyFilter (optional) 
     * @param generalLedgerMappingDisplayPropertyFilter (optional) 
     * @return Success
     */
    getMaterialsToExcel(filter: string | undefined, materialNoFilter: string | undefined, materialNameFilter: string | undefined, materialNameSAPFilter: string | undefined, descriptionFilter: string | undefined, sizeFilter: string | undefined, uoMFilter: string | undefined, brandFilter: string | undefined, materialGroupDisplayPropertyFilter: string | undefined, uNSPSCDisplayPropertyFilter: string | undefined, generalLedgerMappingDisplayPropertyFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Materials/GetMaterialsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (materialNoFilter === null)
            throw new Error("The parameter 'materialNoFilter' cannot be null.");
        else if (materialNoFilter !== undefined)
            url_ += "MaterialNoFilter=" + encodeURIComponent("" + materialNoFilter) + "&";
        if (materialNameFilter === null)
            throw new Error("The parameter 'materialNameFilter' cannot be null.");
        else if (materialNameFilter !== undefined)
            url_ += "MaterialNameFilter=" + encodeURIComponent("" + materialNameFilter) + "&";
        if (materialNameSAPFilter === null)
            throw new Error("The parameter 'materialNameSAPFilter' cannot be null.");
        else if (materialNameSAPFilter !== undefined)
            url_ += "MaterialNameSAPFilter=" + encodeURIComponent("" + materialNameSAPFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (sizeFilter === null)
            throw new Error("The parameter 'sizeFilter' cannot be null.");
        else if (sizeFilter !== undefined)
            url_ += "SizeFilter=" + encodeURIComponent("" + sizeFilter) + "&";
        if (uoMFilter === null)
            throw new Error("The parameter 'uoMFilter' cannot be null.");
        else if (uoMFilter !== undefined)
            url_ += "UoMFilter=" + encodeURIComponent("" + uoMFilter) + "&";
        if (brandFilter === null)
            throw new Error("The parameter 'brandFilter' cannot be null.");
        else if (brandFilter !== undefined)
            url_ += "BrandFilter=" + encodeURIComponent("" + brandFilter) + "&";
        if (materialGroupDisplayPropertyFilter === null)
            throw new Error("The parameter 'materialGroupDisplayPropertyFilter' cannot be null.");
        else if (materialGroupDisplayPropertyFilter !== undefined)
            url_ += "MaterialGroupDisplayPropertyFilter=" + encodeURIComponent("" + materialGroupDisplayPropertyFilter) + "&";
        if (uNSPSCDisplayPropertyFilter === null)
            throw new Error("The parameter 'uNSPSCDisplayPropertyFilter' cannot be null.");
        else if (uNSPSCDisplayPropertyFilter !== undefined)
            url_ += "UNSPSCDisplayPropertyFilter=" + encodeURIComponent("" + uNSPSCDisplayPropertyFilter) + "&";
        if (generalLedgerMappingDisplayPropertyFilter === null)
            throw new Error("The parameter 'generalLedgerMappingDisplayPropertyFilter' cannot be null.");
        else if (generalLedgerMappingDisplayPropertyFilter !== undefined)
            url_ += "GeneralLedgerMappingDisplayPropertyFilter=" + encodeURIComponent("" + generalLedgerMappingDisplayPropertyFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaterialsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaterialsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetMaterialsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMaterialGroupForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMaterialMaterialGroupLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Materials/GetAllMaterialGroupForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMaterialGroupForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMaterialGroupForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMaterialMaterialGroupLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMaterialMaterialGroupLookupTableDto>;
        }));
    }

    protected processGetAllMaterialGroupForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMaterialMaterialGroupLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMaterialMaterialGroupLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUNSPSCForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMaterialUNSPSCLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Materials/GetAllUNSPSCForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUNSPSCForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUNSPSCForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMaterialUNSPSCLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMaterialUNSPSCLookupTableDto>;
        }));
    }

    protected processGetAllUNSPSCForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMaterialUNSPSCLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMaterialUNSPSCLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllGeneralLedgerMappingForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMaterialGeneralLedgerMappingLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Materials/GetAllGeneralLedgerMappingForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGeneralLedgerMappingForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGeneralLedgerMappingForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMaterialGeneralLedgerMappingLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMaterialGeneralLedgerMappingLookupTableDto>;
        }));
    }

    protected processGetAllGeneralLedgerMappingForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMaterialGeneralLedgerMappingLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMaterialGeneralLedgerMappingLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeImageMainFile(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Materials/RemoveImageMainFile?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveImageMainFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveImageMainFile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveImageMainFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | undefined, startDate: DateTime | undefined, endDate: DateTime | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationsOutput>;
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    shouldUserUpdateApp(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Notification/ShouldUserUpdateApp";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processShouldUserUpdateApp(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processShouldUserUpdateApp(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processShouldUserUpdateApp(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    setAllAvailableVersionNotificationAsRead(): Observable<SetNotificationAsReadOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllAvailableVersionNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllAvailableVersionNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllAvailableVersionNotificationAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SetNotificationAsReadOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SetNotificationAsReadOutput>;
        }));
    }

    protected processSetAllAvailableVersionNotificationAsRead(response: HttpResponseBase): Observable<SetNotificationAsReadOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SetNotificationAsReadOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    setNotificationAsRead(body: EntityDtoOfGuid | undefined): Observable<SetNotificationAsReadOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SetNotificationAsReadOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SetNotificationAsReadOutput>;
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<SetNotificationAsReadOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SetNotificationAsReadOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotificationSettingsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotificationSettingsOutput>;
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateNotificationSettings(body: UpdateNotificationSettingsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    deleteAllUserNotifications(state: UserNotificationState | undefined, startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteAllUserNotifications?";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotifications(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMassNotificationUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetAllUserForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMassNotificationUserLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMassNotificationUserLookupTableDto>;
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMassNotificationUserLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMassNotificationUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllOrganizationUnitForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetAllOrganizationUnitForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOrganizationUnitForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOrganizationUnitForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto>;
        }));
    }

    protected processGetAllOrganizationUnitForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createMassNotification(body: CreateMassNotificationInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/CreateMassNotification";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateMassNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateMassNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateMassNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    createNewVersionReleasedNotification(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/CreateNewVersionReleasedNotification";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateNewVersionReleasedNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateNewVersionReleasedNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateNewVersionReleasedNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllNotifiers(): Observable<string[]> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetAllNotifiers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllNotifiers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllNotifiers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string[]>;
        }));
    }

    protected processGetAllNotifiers(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getNotificationsPublishedByUser(startDate: DateTime | undefined, endDate: DateTime | undefined): Observable<GetPublishedNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationsPublishedByUser?";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationsPublishedByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationsPublishedByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPublishedNotificationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPublishedNotificationsOutput>;
        }));
    }

    protected processGetNotificationsPublishedByUser(response: HttpResponseBase): Observable<GetPublishedNotificationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPublishedNotificationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfOrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfOrganizationUnitDto>;
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfOrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrganizationUnitUserListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrganizationUnitUserListDto>;
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfOrganizationUnitRoleListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfOrganizationUnitRoleListDto>;
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrganizationUnit(body: CreateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateOrganizationUnit(body: UpdateOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    moveOrganizationUnit(body: MoveOrganizationUnitInput | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto>;
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | undefined, organizationUnitId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId === null)
            throw new Error("The parameter 'roleId' cannot be null.");
        else if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&";
        if (organizationUnitId === null)
            throw new Error("The parameter 'organizationUnitId' cannot be null.");
        else if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(body: UsersToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(body: RolesToOrganizationUnitInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findUsers(body: FindOrganizationUnitUsersInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    findRoles(body: FindOrganizationUnitRolesInput | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfNameValueDto>;
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAll(): Observable<OrganizationUnitDto[]> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<OrganizationUnitDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<OrganizationUnitDto[]>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<OrganizationUnitDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(OrganizationUnitDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' cannot be null.");
        else if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentInfoDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentInfoDto>;
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPayment(body: CreatePaymentDto | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<number>;
                }
            } else
                return _observableThrow(response_) as any as Observable<number>;
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelPayment(body: CancelPaymentDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfSubscriptionPaymentListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfSubscriptionPaymentListDto>;
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled === null)
            throw new Error("The parameter 'recurringPaymentsEnabled' cannot be null.");
        else if (recurringPaymentsEnabled !== undefined)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PaymentGatewayModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PaymentGatewayModel[]>;
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    switchBetweenFreeEditions(upgradeEditionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/SwitchBetweenFreeEditions?";
        if (upgradeEditionId === null)
            throw new Error("The parameter 'upgradeEditionId' cannot be null.");
        else if (upgradeEditionId !== undefined)
            url_ += "upgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchBetweenFreeEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchBetweenFreeEditions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSwitchBetweenFreeEditions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    upgradeSubscriptionCostsLessThenMinAmount(editionId: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSubscriptionCostsLessThenMinAmount?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSubscriptionCostsLessThenMinAmount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSubscriptionCostsLessThenMinAmount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpgradeSubscriptionCostsLessThenMinAmount(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    hasAnyPayment(): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Payment/HasAnyPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHasAnyPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHasAnyPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processHasAnyPayment(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalOrderId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | undefined, paypalOrderId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&";
        if (paypalOrderId === null)
            throw new Error("The parameter 'paypalOrderId' cannot be null.");
        else if (paypalOrderId !== undefined)
            url_ += "paypalOrderId=" + encodeURIComponent("" + paypalOrderId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PayPalConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PayPalConfigurationDto>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayPalConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfFlatPermissionWithLevelDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfFlatPermissionWithLevelDto>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentUserProfileEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentUserProfileEditDto>;
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUserProfileEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    disableGoogleAuthenticator(body: VerifyAuthenticatorCodeInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/DisableGoogleAuthenticator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableGoogleAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableGoogleAuthenticator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisableGoogleAuthenticator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    viewRecoveryCodes(body: VerifyAuthenticatorCodeInput | undefined): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ViewRecoveryCodes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processViewRecoveryCodes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processViewRecoveryCodes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
        }));
    }

    protected processViewRecoveryCodes(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    generateGoogleAuthenticatorKey(): Observable<GenerateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GenerateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateGoogleAuthenticatorKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GenerateGoogleAuthenticatorKeyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GenerateGoogleAuthenticatorKeyOutput>;
        }));
    }

    protected processGenerateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<GenerateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GenerateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateGoogleAuthenticatorKey(body: UpdateGoogleAuthenticatorKeyInput | undefined): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateGoogleAuthenticatorKeyOutput>;
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendVerificationSms(body: SendVerificationSmsInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifySmsCode(body: VerifySmsCodeInputDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateCurrentUserProfile(body: CurrentUserProfileEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changePassword(body: ChangePasswordInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateProfilePicture(body: UpdateProfilePictureInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyAuthenticatorCode(body: VerifyAuthenticatorCodeInput | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifyAuthenticatorCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyAuthenticatorCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyAuthenticatorCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processVerifyAuthenticatorCode(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPasswordComplexitySettingOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPasswordComplexitySettingOutput>;
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPasswordComplexitySettingOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param username (optional) 
     * @return Success
     */
    getProfilePictureByUserName(username: string | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureByUserName?";
        if (username === null)
            throw new Error("The parameter 'username' cannot be null.");
        else if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUserName(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePictureByUserName(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePicture(userId: number | undefined, tenantId: number | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePicture?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&";
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePicture(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetFriendProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userId (optional) 
     * @return Success
     */
    getProfilePictureByUser(userId: number | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureByUser?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureByUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfilePictureOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfilePictureOutput>;
        }));
    }

    protected processGetProfilePictureByUser(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeLanguage(body: ChangeUserLanguageDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getRoles(body: GetRolesInput | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfRoleListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfRoleListDto>;
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRoleForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRoleForEditOutput>;
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateRole(body: CreateOrUpdateRoleInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class RptProcurementAdjustsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param purchasingDocumentFilter (optional) 
     * @param isContractFilter (optional) 
     * @param isAdjustFilter (optional) 
     * @param maxDayAdjustFilter (optional) 
     * @param minDayAdjustFilter (optional) 
     * @param remarkFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, purchasingDocumentFilter: string | undefined, isContractFilter: number | undefined, isAdjustFilter: number | undefined, maxDayAdjustFilter: number | undefined, minDayAdjustFilter: number | undefined, remarkFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetRptProcurementAdjustForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RptProcurementAdjusts/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (purchasingDocumentFilter === null)
            throw new Error("The parameter 'purchasingDocumentFilter' cannot be null.");
        else if (purchasingDocumentFilter !== undefined)
            url_ += "PurchasingDocumentFilter=" + encodeURIComponent("" + purchasingDocumentFilter) + "&";
        if (isContractFilter === null)
            throw new Error("The parameter 'isContractFilter' cannot be null.");
        else if (isContractFilter !== undefined)
            url_ += "IsContractFilter=" + encodeURIComponent("" + isContractFilter) + "&";
        if (isAdjustFilter === null)
            throw new Error("The parameter 'isAdjustFilter' cannot be null.");
        else if (isAdjustFilter !== undefined)
            url_ += "IsAdjustFilter=" + encodeURIComponent("" + isAdjustFilter) + "&";
        if (maxDayAdjustFilter === null)
            throw new Error("The parameter 'maxDayAdjustFilter' cannot be null.");
        else if (maxDayAdjustFilter !== undefined)
            url_ += "MaxDayAdjustFilter=" + encodeURIComponent("" + maxDayAdjustFilter) + "&";
        if (minDayAdjustFilter === null)
            throw new Error("The parameter 'minDayAdjustFilter' cannot be null.");
        else if (minDayAdjustFilter !== undefined)
            url_ += "MinDayAdjustFilter=" + encodeURIComponent("" + minDayAdjustFilter) + "&";
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetRptProcurementAdjustForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetRptProcurementAdjustForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRptProcurementAdjustForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetRptProcurementAdjustForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRptProcurementAdjustForView(id: string | undefined): Observable<GetRptProcurementAdjustForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RptProcurementAdjusts/GetRptProcurementAdjustForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRptProcurementAdjustForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRptProcurementAdjustForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRptProcurementAdjustForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRptProcurementAdjustForViewDto>;
        }));
    }

    protected processGetRptProcurementAdjustForView(response: HttpResponseBase): Observable<GetRptProcurementAdjustForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRptProcurementAdjustForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRptProcurementAdjustForEdit(id: string | undefined): Observable<GetRptProcurementAdjustForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RptProcurementAdjusts/GetRptProcurementAdjustForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRptProcurementAdjustForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRptProcurementAdjustForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRptProcurementAdjustForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRptProcurementAdjustForEditOutput>;
        }));
    }

    protected processGetRptProcurementAdjustForEdit(response: HttpResponseBase): Observable<GetRptProcurementAdjustForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRptProcurementAdjustForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditRptProcurementAdjustDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RptProcurementAdjusts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RptProcurementAdjusts/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param purchasingDocumentFilter (optional) 
     * @param isContractFilter (optional) 
     * @param isAdjustFilter (optional) 
     * @param maxDayAdjustFilter (optional) 
     * @param minDayAdjustFilter (optional) 
     * @param remarkFilter (optional) 
     * @return Success
     */
    getRptProcurementAdjustsToExcel(filter: string | undefined, purchasingDocumentFilter: string | undefined, isContractFilter: number | undefined, isAdjustFilter: number | undefined, maxDayAdjustFilter: number | undefined, minDayAdjustFilter: number | undefined, remarkFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/RptProcurementAdjusts/GetRptProcurementAdjustsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (purchasingDocumentFilter === null)
            throw new Error("The parameter 'purchasingDocumentFilter' cannot be null.");
        else if (purchasingDocumentFilter !== undefined)
            url_ += "PurchasingDocumentFilter=" + encodeURIComponent("" + purchasingDocumentFilter) + "&";
        if (isContractFilter === null)
            throw new Error("The parameter 'isContractFilter' cannot be null.");
        else if (isContractFilter !== undefined)
            url_ += "IsContractFilter=" + encodeURIComponent("" + isContractFilter) + "&";
        if (isAdjustFilter === null)
            throw new Error("The parameter 'isAdjustFilter' cannot be null.");
        else if (isAdjustFilter !== undefined)
            url_ += "IsAdjustFilter=" + encodeURIComponent("" + isAdjustFilter) + "&";
        if (maxDayAdjustFilter === null)
            throw new Error("The parameter 'maxDayAdjustFilter' cannot be null.");
        else if (maxDayAdjustFilter !== undefined)
            url_ += "MaxDayAdjustFilter=" + encodeURIComponent("" + maxDayAdjustFilter) + "&";
        if (minDayAdjustFilter === null)
            throw new Error("The parameter 'minDayAdjustFilter' cannot be null.");
        else if (minDayAdjustFilter !== undefined)
            url_ += "MinDayAdjustFilter=" + encodeURIComponent("" + minDayAdjustFilter) + "&";
        if (remarkFilter === null)
            throw new Error("The parameter 'remarkFilter' cannot be null.");
        else if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRptProcurementAdjustsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRptProcurementAdjustsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetRptProcurementAdjustsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SAPSynchServiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    synchronizeFromSAP(body: CostCenterSynchDto | undefined): Observable<DtoResponseModel> {
        let url_ = this.baseUrl + "/api/services/app/SAPSynchService/SynchronizeFromSAP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSynchronizeFromSAP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSynchronizeFromSAP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DtoResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DtoResponseModel>;
        }));
    }

    protected processSynchronizeFromSAP(response: HttpResponseBase): Observable<DtoResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DtoResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    purchasingDocumentHeader(body: PurchasingOrderSynchDto | undefined): Observable<DtoResponseModel> {
        let url_ = this.baseUrl + "/api/services/app/SAPSynchService/PurchasingDocumentHeader";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPurchasingDocumentHeader(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPurchasingDocumentHeader(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DtoResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DtoResponseModel>;
        }));
    }

    protected processPurchasingDocumentHeader(response: HttpResponseBase): Observable<DtoResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DtoResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    purchasingDocumentItem(body: PurchasingOrderSynchDto | undefined): Observable<DtoResponseModel> {
        let url_ = this.baseUrl + "/api/services/app/SAPSynchService/PurchasingDocumentItem";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPurchasingDocumentItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPurchasingDocumentItem(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DtoResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DtoResponseModel>;
        }));
    }

    protected processPurchasingDocumentItem(response: HttpResponseBase): Observable<DtoResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DtoResponseModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetCurrentLoginInformationsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetCurrentLoginInformationsOutput>;
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UpdateUserSignInTokenOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UpdateUserSignInTokenOutput>;
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StripeConfigurationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StripeConfigurationDto>;
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripeConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param stripeSessionId (optional) 
     * @return Success
     */
    getPayment(stripeSessionId: string | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPayment?";
        if (stripeSessionId === null)
            throw new Error("The parameter 'stripeSessionId' cannot be null.");
        else if (stripeSessionId !== undefined)
            url_ += "StripeSessionId=" + encodeURIComponent("" + stripeSessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SubscriptionPaymentDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SubscriptionPaymentDto>;
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPaymentSession(body: StripeCreatePaymentSessionInput | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreatePaymentSession";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePaymentSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePaymentSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processCreatePaymentSession(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPaymentResult(paymentId: number | undefined): Observable<StripePaymentResultOutput> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetPaymentResult?";
        if (paymentId === null)
            throw new Error("The parameter 'paymentId' cannot be null.");
        else if (paymentId !== undefined)
            url_ += "PaymentId=" + encodeURIComponent("" + paymentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentResult(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentResult(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StripePaymentResultOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StripePaymentResultOutput>;
        }));
    }

    protected processGetPaymentResult(response: HttpResponseBase): Observable<StripePaymentResultOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripePaymentResultOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | undefined, subscriptionEndDateStart: DateTime | undefined, subscriptionEndDateEnd: DateTime | undefined, creationDateStart: DateTime | undefined, creationDateEnd: DateTime | undefined, editionId: number | undefined, editionIdSpecified: boolean | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (subscriptionEndDateStart === null)
            throw new Error("The parameter 'subscriptionEndDateStart' cannot be null.");
        else if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toString() : "") + "&";
        if (subscriptionEndDateEnd === null)
            throw new Error("The parameter 'subscriptionEndDateEnd' cannot be null.");
        else if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toString() : "") + "&";
        if (creationDateStart === null)
            throw new Error("The parameter 'creationDateStart' cannot be null.");
        else if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toString() : "") + "&";
        if (creationDateEnd === null)
            throw new Error("The parameter 'creationDateEnd' cannot be null.");
        else if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toString() : "") + "&";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&";
        if (editionIdSpecified === null)
            throw new Error("The parameter 'editionIdSpecified' cannot be null.");
        else if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTenantListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTenantListDto>;
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTenantListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createTenant(body: CreateTenantInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantEditDto>;
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenant(body: TenantEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTenantFeaturesEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTenantFeaturesEditOutput>;
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateTenantFeatures(body: UpdateTenantFeaturesInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockTenantAdmin(body: EntityDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantCustomizationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param tenantId (optional) 
     * @param extension (optional) 
     * @return Success
     */
    getTenantLogo(skin: string, tenantId: number | undefined, extension: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/TenantCustomization/GetTenantLogo/{skin}/{tenantId}/{extension}?";
        if (skin === undefined || skin === null)
            throw new Error("The parameter 'skin' must be defined.");
        url_ = url_.replace("{skin}", encodeURIComponent("" + skin));
        if (tenantId === null)
            throw new Error("The parameter 'tenantId' cannot be null.");
        else if (tenantId !== undefined)
            url_ += "tenantId=" + encodeURIComponent("" + tenantId) + "&";
        if (extension === null)
            throw new Error("The parameter 'extension' cannot be null.");
        else if (extension !== undefined)
            url_ += "extension=" + encodeURIComponent("" + extension) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processGetTenantLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetMemberActivityOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetMemberActivityOutput>;
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberActivityOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDashboardDataOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDashboardDataOutput>;
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDashboardDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getTopStats(): Observable<GetTopStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetTopStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTopStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTopStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTopStatsOutput>;
        }));
    }

    protected processGetTopStats(response: HttpResponseBase): Observable<GetTopStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTopStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getProfitShare(): Observable<GetProfitShareOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetProfitShare";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfitShare(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfitShare(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetProfitShareOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetProfitShareOutput>;
        }));
    }

    protected processGetProfitShare(response: HttpResponseBase): Observable<GetProfitShareOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfitShareOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getDailySales(): Observable<GetDailySalesOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDailySales";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDailySales(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDailySales(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetDailySalesOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetDailySalesOutput>;
        }));
    }

    protected processGetDailySales(response: HttpResponseBase): Observable<GetDailySalesOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDailySalesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSalesSummaryOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSalesSummaryOutput>;
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSalesSummaryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetRegionalStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetRegionalStatsOutput>;
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRegionalStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGeneralStatsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGeneralStatsOutput>;
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    registerTenant(body: RegisterTenantInput | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterTenantOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterTenantOutput>;
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterTenantOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditionsSelectOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditionsSelectOutput>;
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionsSelectOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId === null)
            throw new Error("The parameter 'editionId' cannot be null.");
        else if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<EditionSelectDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<EditionSelectDto>;
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TenantSettingsEditDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TenantSettingsEditDto>;
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAllSettings(body: TenantSettingsEditDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    clearDarkLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearDarkLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearDarkLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearDarkLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearDarkLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    clearLightLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLightLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLightLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLightLogo(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearLightLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTestEmail(body: SendTestEmailInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getEnabledSocialLoginSettings(): Observable<ExternalLoginSettingsDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetEnabledSocialLoginSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnabledSocialLoginSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnabledSocialLoginSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginSettingsDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginSettingsDto>;
        }));
    }

    protected processGetEnabledSocialLoginSettings(response: HttpResponseBase): Observable<ExternalLoginSettingsDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalLoginSettingsDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfNameValueDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfNameValueDto>;
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId === null)
            throw new Error("The parameter 'selectedTimezoneId' cannot be null.");
        else if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ComboboxItemDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ComboboxItemDto[]>;
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    authenticate(body: AuthenticateModel | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AuthenticateResultModel>;
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken === null)
            throw new Error("The parameter 'refreshToken' cannot be null.");
        else if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefreshTokenResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefreshTokenResult>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(body: SendTwoFactorAuthCodeModel | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken === null)
            throw new Error("The parameter 'impersonationToken' cannot be null.");
        else if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonatedAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonatedAuthenticateResultModel>;
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param userDelegationId (optional) 
     * @param impersonationToken (optional) 
     * @return Success
     */
    delegatedImpersonatedAuthenticate(userDelegationId: number | undefined, impersonationToken: string | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/DelegatedImpersonatedAuthenticate?";
        if (userDelegationId === null)
            throw new Error("The parameter 'userDelegationId' cannot be null.");
        else if (userDelegationId !== undefined)
            url_ += "userDelegationId=" + encodeURIComponent("" + userDelegationId) + "&";
        if (impersonationToken === null)
            throw new Error("The parameter 'impersonationToken' cannot be null.");
        else if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegatedImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegatedImpersonatedAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImpersonatedAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImpersonatedAuthenticateResultModel>;
        }));
    }

    protected processDelegatedImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken === null)
            throw new Error("The parameter 'switchAccountToken' cannot be null.");
        else if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SwitchedAccountAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SwitchedAccountAuthenticateResultModel>;
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalLoginProviderInfoModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalLoginProviderInfoModel[]>;
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    externalAuthenticate(body: ExternalAuthenticateModel | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ExternalAuthenticateResultModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ExternalAuthenticateResultModel>;
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | undefined, severity: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message === null)
            throw new Error("The parameter 'message' cannot be null.");
        else if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&";
        if (severity === null)
            throw new Error("The parameter 'severity' cannot be null.");
        else if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TransferBudgetItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param periodFromFilter (optional) 
     * @param maxAmountFromFilter (optional) 
     * @param minAmountFromFilter (optional) 
     * @param periodToFilter (optional) 
     * @param maxAmountToFilter (optional) 
     * @param minAmountToFilter (optional) 
     * @param transferBudgetDisplayPropertyFilter (optional) 
     * @param costCenterDisplayPropertyFilter (optional) 
     * @param costCenterDisplayProperty2Filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, periodFromFilter: string | undefined, maxAmountFromFilter: number | undefined, minAmountFromFilter: number | undefined, periodToFilter: string | undefined, maxAmountToFilter: number | undefined, minAmountToFilter: number | undefined, transferBudgetDisplayPropertyFilter: string | undefined, costCenterDisplayPropertyFilter: string | undefined, costCenterDisplayProperty2Filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTransferBudgetItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgetItems/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (periodFromFilter === null)
            throw new Error("The parameter 'periodFromFilter' cannot be null.");
        else if (periodFromFilter !== undefined)
            url_ += "PeriodFromFilter=" + encodeURIComponent("" + periodFromFilter) + "&";
        if (maxAmountFromFilter === null)
            throw new Error("The parameter 'maxAmountFromFilter' cannot be null.");
        else if (maxAmountFromFilter !== undefined)
            url_ += "MaxAmountFromFilter=" + encodeURIComponent("" + maxAmountFromFilter) + "&";
        if (minAmountFromFilter === null)
            throw new Error("The parameter 'minAmountFromFilter' cannot be null.");
        else if (minAmountFromFilter !== undefined)
            url_ += "MinAmountFromFilter=" + encodeURIComponent("" + minAmountFromFilter) + "&";
        if (periodToFilter === null)
            throw new Error("The parameter 'periodToFilter' cannot be null.");
        else if (periodToFilter !== undefined)
            url_ += "PeriodToFilter=" + encodeURIComponent("" + periodToFilter) + "&";
        if (maxAmountToFilter === null)
            throw new Error("The parameter 'maxAmountToFilter' cannot be null.");
        else if (maxAmountToFilter !== undefined)
            url_ += "MaxAmountToFilter=" + encodeURIComponent("" + maxAmountToFilter) + "&";
        if (minAmountToFilter === null)
            throw new Error("The parameter 'minAmountToFilter' cannot be null.");
        else if (minAmountToFilter !== undefined)
            url_ += "MinAmountToFilter=" + encodeURIComponent("" + minAmountToFilter) + "&";
        if (transferBudgetDisplayPropertyFilter === null)
            throw new Error("The parameter 'transferBudgetDisplayPropertyFilter' cannot be null.");
        else if (transferBudgetDisplayPropertyFilter !== undefined)
            url_ += "TransferBudgetDisplayPropertyFilter=" + encodeURIComponent("" + transferBudgetDisplayPropertyFilter) + "&";
        if (costCenterDisplayPropertyFilter === null)
            throw new Error("The parameter 'costCenterDisplayPropertyFilter' cannot be null.");
        else if (costCenterDisplayPropertyFilter !== undefined)
            url_ += "CostCenterDisplayPropertyFilter=" + encodeURIComponent("" + costCenterDisplayPropertyFilter) + "&";
        if (costCenterDisplayProperty2Filter === null)
            throw new Error("The parameter 'costCenterDisplayProperty2Filter' cannot be null.");
        else if (costCenterDisplayProperty2Filter !== undefined)
            url_ += "CostCenterDisplayProperty2Filter=" + encodeURIComponent("" + costCenterDisplayProperty2Filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetTransferBudgetItemForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetTransferBudgetItemForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTransferBudgetItemForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTransferBudgetItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTransferBudgetItemForView(id: string | undefined): Observable<GetTransferBudgetItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgetItems/GetTransferBudgetItemForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransferBudgetItemForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransferBudgetItemForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTransferBudgetItemForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTransferBudgetItemForViewDto>;
        }));
    }

    protected processGetTransferBudgetItemForView(response: HttpResponseBase): Observable<GetTransferBudgetItemForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTransferBudgetItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTransferBudgetItemForEdit(id: string | undefined): Observable<GetTransferBudgetItemForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgetItems/GetTransferBudgetItemForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransferBudgetItemForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransferBudgetItemForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTransferBudgetItemForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTransferBudgetItemForEditOutput>;
        }));
    }

    protected processGetTransferBudgetItemForEdit(response: HttpResponseBase): Observable<GetTransferBudgetItemForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTransferBudgetItemForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTransferBudgetItemDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgetItems/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgetItems/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param periodFromFilter (optional) 
     * @param maxAmountFromFilter (optional) 
     * @param minAmountFromFilter (optional) 
     * @param periodToFilter (optional) 
     * @param maxAmountToFilter (optional) 
     * @param minAmountToFilter (optional) 
     * @param transferBudgetDisplayPropertyFilter (optional) 
     * @param costCenterDisplayPropertyFilter (optional) 
     * @param costCenterDisplayProperty2Filter (optional) 
     * @return Success
     */
    getTransferBudgetItemsToExcel(filter: string | undefined, periodFromFilter: string | undefined, maxAmountFromFilter: number | undefined, minAmountFromFilter: number | undefined, periodToFilter: string | undefined, maxAmountToFilter: number | undefined, minAmountToFilter: number | undefined, transferBudgetDisplayPropertyFilter: string | undefined, costCenterDisplayPropertyFilter: string | undefined, costCenterDisplayProperty2Filter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgetItems/GetTransferBudgetItemsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (periodFromFilter === null)
            throw new Error("The parameter 'periodFromFilter' cannot be null.");
        else if (periodFromFilter !== undefined)
            url_ += "PeriodFromFilter=" + encodeURIComponent("" + periodFromFilter) + "&";
        if (maxAmountFromFilter === null)
            throw new Error("The parameter 'maxAmountFromFilter' cannot be null.");
        else if (maxAmountFromFilter !== undefined)
            url_ += "MaxAmountFromFilter=" + encodeURIComponent("" + maxAmountFromFilter) + "&";
        if (minAmountFromFilter === null)
            throw new Error("The parameter 'minAmountFromFilter' cannot be null.");
        else if (minAmountFromFilter !== undefined)
            url_ += "MinAmountFromFilter=" + encodeURIComponent("" + minAmountFromFilter) + "&";
        if (periodToFilter === null)
            throw new Error("The parameter 'periodToFilter' cannot be null.");
        else if (periodToFilter !== undefined)
            url_ += "PeriodToFilter=" + encodeURIComponent("" + periodToFilter) + "&";
        if (maxAmountToFilter === null)
            throw new Error("The parameter 'maxAmountToFilter' cannot be null.");
        else if (maxAmountToFilter !== undefined)
            url_ += "MaxAmountToFilter=" + encodeURIComponent("" + maxAmountToFilter) + "&";
        if (minAmountToFilter === null)
            throw new Error("The parameter 'minAmountToFilter' cannot be null.");
        else if (minAmountToFilter !== undefined)
            url_ += "MinAmountToFilter=" + encodeURIComponent("" + minAmountToFilter) + "&";
        if (transferBudgetDisplayPropertyFilter === null)
            throw new Error("The parameter 'transferBudgetDisplayPropertyFilter' cannot be null.");
        else if (transferBudgetDisplayPropertyFilter !== undefined)
            url_ += "TransferBudgetDisplayPropertyFilter=" + encodeURIComponent("" + transferBudgetDisplayPropertyFilter) + "&";
        if (costCenterDisplayPropertyFilter === null)
            throw new Error("The parameter 'costCenterDisplayPropertyFilter' cannot be null.");
        else if (costCenterDisplayPropertyFilter !== undefined)
            url_ += "CostCenterDisplayPropertyFilter=" + encodeURIComponent("" + costCenterDisplayPropertyFilter) + "&";
        if (costCenterDisplayProperty2Filter === null)
            throw new Error("The parameter 'costCenterDisplayProperty2Filter' cannot be null.");
        else if (costCenterDisplayProperty2Filter !== undefined)
            url_ += "CostCenterDisplayProperty2Filter=" + encodeURIComponent("" + costCenterDisplayProperty2Filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransferBudgetItemsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransferBudgetItemsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetTransferBudgetItemsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllTransferBudgetForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTransferBudgetItemTransferBudgetLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgetItems/GetAllTransferBudgetForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllTransferBudgetForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllTransferBudgetForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTransferBudgetItemTransferBudgetLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTransferBudgetItemTransferBudgetLookupTableDto>;
        }));
    }

    protected processGetAllTransferBudgetForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTransferBudgetItemTransferBudgetLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTransferBudgetItemTransferBudgetLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCostCenterForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTransferBudgetItemCostCenterLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgetItems/GetAllCostCenterForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCostCenterForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCostCenterForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTransferBudgetItemCostCenterLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTransferBudgetItemCostCenterLookupTableDto>;
        }));
    }

    protected processGetAllCostCenterForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTransferBudgetItemCostCenterLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTransferBudgetItemCostCenterLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TransferBudgetsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param documentNoFilter (optional) 
     * @param departmentFilter (optional) 
     * @param divisionFilter (optional) 
     * @param purposeFilter (optional) 
     * @param projectActivitiesFilter (optional) 
     * @param reasonFilter (optional) 
     * @param scopeofWorkFilter (optional) 
     * @param locationFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, documentNoFilter: string | undefined, departmentFilter: string | undefined, divisionFilter: string | undefined, purposeFilter: string | undefined, projectActivitiesFilter: string | undefined, reasonFilter: string | undefined, scopeofWorkFilter: string | undefined, locationFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTransferBudgetForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgets/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (documentNoFilter === null)
            throw new Error("The parameter 'documentNoFilter' cannot be null.");
        else if (documentNoFilter !== undefined)
            url_ += "DocumentNoFilter=" + encodeURIComponent("" + documentNoFilter) + "&";
        if (departmentFilter === null)
            throw new Error("The parameter 'departmentFilter' cannot be null.");
        else if (departmentFilter !== undefined)
            url_ += "DepartmentFilter=" + encodeURIComponent("" + departmentFilter) + "&";
        if (divisionFilter === null)
            throw new Error("The parameter 'divisionFilter' cannot be null.");
        else if (divisionFilter !== undefined)
            url_ += "DivisionFilter=" + encodeURIComponent("" + divisionFilter) + "&";
        if (purposeFilter === null)
            throw new Error("The parameter 'purposeFilter' cannot be null.");
        else if (purposeFilter !== undefined)
            url_ += "PurposeFilter=" + encodeURIComponent("" + purposeFilter) + "&";
        if (projectActivitiesFilter === null)
            throw new Error("The parameter 'projectActivitiesFilter' cannot be null.");
        else if (projectActivitiesFilter !== undefined)
            url_ += "ProjectActivitiesFilter=" + encodeURIComponent("" + projectActivitiesFilter) + "&";
        if (reasonFilter === null)
            throw new Error("The parameter 'reasonFilter' cannot be null.");
        else if (reasonFilter !== undefined)
            url_ += "ReasonFilter=" + encodeURIComponent("" + reasonFilter) + "&";
        if (scopeofWorkFilter === null)
            throw new Error("The parameter 'scopeofWorkFilter' cannot be null.");
        else if (scopeofWorkFilter !== undefined)
            url_ += "ScopeofWorkFilter=" + encodeURIComponent("" + scopeofWorkFilter) + "&";
        if (locationFilter === null)
            throw new Error("The parameter 'locationFilter' cannot be null.");
        else if (locationFilter !== undefined)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetTransferBudgetForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetTransferBudgetForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTransferBudgetForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTransferBudgetForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTransferBudgetForView(id: string | undefined): Observable<GetTransferBudgetForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgets/GetTransferBudgetForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransferBudgetForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransferBudgetForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTransferBudgetForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTransferBudgetForViewDto>;
        }));
    }

    protected processGetTransferBudgetForView(response: HttpResponseBase): Observable<GetTransferBudgetForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTransferBudgetForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTransferBudgetForEdit(id: string | undefined): Observable<GetTransferBudgetForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgets/GetTransferBudgetForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransferBudgetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransferBudgetForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTransferBudgetForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTransferBudgetForEditOutput>;
        }));
    }

    protected processGetTransferBudgetForEdit(response: HttpResponseBase): Observable<GetTransferBudgetForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTransferBudgetForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTransferBudgetDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgets/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgets/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param documentNoFilter (optional) 
     * @param departmentFilter (optional) 
     * @param divisionFilter (optional) 
     * @param purposeFilter (optional) 
     * @param projectActivitiesFilter (optional) 
     * @param reasonFilter (optional) 
     * @param scopeofWorkFilter (optional) 
     * @param locationFilter (optional) 
     * @return Success
     */
    getTransferBudgetsToExcel(filter: string | undefined, documentNoFilter: string | undefined, departmentFilter: string | undefined, divisionFilter: string | undefined, purposeFilter: string | undefined, projectActivitiesFilter: string | undefined, reasonFilter: string | undefined, scopeofWorkFilter: string | undefined, locationFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TransferBudgets/GetTransferBudgetsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (documentNoFilter === null)
            throw new Error("The parameter 'documentNoFilter' cannot be null.");
        else if (documentNoFilter !== undefined)
            url_ += "DocumentNoFilter=" + encodeURIComponent("" + documentNoFilter) + "&";
        if (departmentFilter === null)
            throw new Error("The parameter 'departmentFilter' cannot be null.");
        else if (departmentFilter !== undefined)
            url_ += "DepartmentFilter=" + encodeURIComponent("" + departmentFilter) + "&";
        if (divisionFilter === null)
            throw new Error("The parameter 'divisionFilter' cannot be null.");
        else if (divisionFilter !== undefined)
            url_ += "DivisionFilter=" + encodeURIComponent("" + divisionFilter) + "&";
        if (purposeFilter === null)
            throw new Error("The parameter 'purposeFilter' cannot be null.");
        else if (purposeFilter !== undefined)
            url_ += "PurposeFilter=" + encodeURIComponent("" + purposeFilter) + "&";
        if (projectActivitiesFilter === null)
            throw new Error("The parameter 'projectActivitiesFilter' cannot be null.");
        else if (projectActivitiesFilter !== undefined)
            url_ += "ProjectActivitiesFilter=" + encodeURIComponent("" + projectActivitiesFilter) + "&";
        if (reasonFilter === null)
            throw new Error("The parameter 'reasonFilter' cannot be null.");
        else if (reasonFilter !== undefined)
            url_ += "ReasonFilter=" + encodeURIComponent("" + reasonFilter) + "&";
        if (scopeofWorkFilter === null)
            throw new Error("The parameter 'scopeofWorkFilter' cannot be null.");
        else if (scopeofWorkFilter !== undefined)
            url_ += "ScopeofWorkFilter=" + encodeURIComponent("" + scopeofWorkFilter) + "&";
        if (locationFilter === null)
            throw new Error("The parameter 'locationFilter' cannot be null.");
        else if (locationFilter !== undefined)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransferBudgetsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransferBudgetsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetTransferBudgetsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TravelRequestsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param requestNoFilter (optional) 
     * @param travelStatusFilter (optional) 
     * @param travelTypeFilter (optional) 
     * @param maxRequestDateFilter (optional) 
     * @param minRequestDateFilter (optional) 
     * @param maxRequestPlanDateFilter (optional) 
     * @param minRequestPlanDateFilter (optional) 
     * @param campFilter (optional) 
     * @param transportBusFilter (optional) 
     * @param maxCreatedDateFilter (optional) 
     * @param minCreatedDateFilter (optional) 
     * @param userNameFilter (optional) 
     * @param airportDisplayPropertyFilter (optional) 
     * @param airportDisplayProperty2Filter (optional) 
     * @param userName2Filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, requestNoFilter: string | undefined, travelStatusFilter: number | undefined, travelTypeFilter: number | undefined, maxRequestDateFilter: DateTime | undefined, minRequestDateFilter: DateTime | undefined, maxRequestPlanDateFilter: DateTime | undefined, minRequestPlanDateFilter: DateTime | undefined, campFilter: string | undefined, transportBusFilter: string | undefined, maxCreatedDateFilter: DateTime | undefined, minCreatedDateFilter: DateTime | undefined, userNameFilter: string | undefined, airportDisplayPropertyFilter: string | undefined, airportDisplayProperty2Filter: string | undefined, userName2Filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetTravelRequestForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelRequests/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (requestNoFilter === null)
            throw new Error("The parameter 'requestNoFilter' cannot be null.");
        else if (requestNoFilter !== undefined)
            url_ += "RequestNoFilter=" + encodeURIComponent("" + requestNoFilter) + "&";
        if (travelStatusFilter === null)
            throw new Error("The parameter 'travelStatusFilter' cannot be null.");
        else if (travelStatusFilter !== undefined)
            url_ += "TravelStatusFilter=" + encodeURIComponent("" + travelStatusFilter) + "&";
        if (travelTypeFilter === null)
            throw new Error("The parameter 'travelTypeFilter' cannot be null.");
        else if (travelTypeFilter !== undefined)
            url_ += "TravelTypeFilter=" + encodeURIComponent("" + travelTypeFilter) + "&";
        if (maxRequestDateFilter === null)
            throw new Error("The parameter 'maxRequestDateFilter' cannot be null.");
        else if (maxRequestDateFilter !== undefined)
            url_ += "MaxRequestDateFilter=" + encodeURIComponent(maxRequestDateFilter ? "" + maxRequestDateFilter.toString() : "") + "&";
        if (minRequestDateFilter === null)
            throw new Error("The parameter 'minRequestDateFilter' cannot be null.");
        else if (minRequestDateFilter !== undefined)
            url_ += "MinRequestDateFilter=" + encodeURIComponent(minRequestDateFilter ? "" + minRequestDateFilter.toString() : "") + "&";
        if (maxRequestPlanDateFilter === null)
            throw new Error("The parameter 'maxRequestPlanDateFilter' cannot be null.");
        else if (maxRequestPlanDateFilter !== undefined)
            url_ += "MaxRequestPlanDateFilter=" + encodeURIComponent(maxRequestPlanDateFilter ? "" + maxRequestPlanDateFilter.toString() : "") + "&";
        if (minRequestPlanDateFilter === null)
            throw new Error("The parameter 'minRequestPlanDateFilter' cannot be null.");
        else if (minRequestPlanDateFilter !== undefined)
            url_ += "MinRequestPlanDateFilter=" + encodeURIComponent(minRequestPlanDateFilter ? "" + minRequestPlanDateFilter.toString() : "") + "&";
        if (campFilter === null)
            throw new Error("The parameter 'campFilter' cannot be null.");
        else if (campFilter !== undefined)
            url_ += "CampFilter=" + encodeURIComponent("" + campFilter) + "&";
        if (transportBusFilter === null)
            throw new Error("The parameter 'transportBusFilter' cannot be null.");
        else if (transportBusFilter !== undefined)
            url_ += "TransportBusFilter=" + encodeURIComponent("" + transportBusFilter) + "&";
        if (maxCreatedDateFilter === null)
            throw new Error("The parameter 'maxCreatedDateFilter' cannot be null.");
        else if (maxCreatedDateFilter !== undefined)
            url_ += "MaxCreatedDateFilter=" + encodeURIComponent(maxCreatedDateFilter ? "" + maxCreatedDateFilter.toString() : "") + "&";
        if (minCreatedDateFilter === null)
            throw new Error("The parameter 'minCreatedDateFilter' cannot be null.");
        else if (minCreatedDateFilter !== undefined)
            url_ += "MinCreatedDateFilter=" + encodeURIComponent(minCreatedDateFilter ? "" + minCreatedDateFilter.toString() : "") + "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        if (airportDisplayPropertyFilter === null)
            throw new Error("The parameter 'airportDisplayPropertyFilter' cannot be null.");
        else if (airportDisplayPropertyFilter !== undefined)
            url_ += "AirportDisplayPropertyFilter=" + encodeURIComponent("" + airportDisplayPropertyFilter) + "&";
        if (airportDisplayProperty2Filter === null)
            throw new Error("The parameter 'airportDisplayProperty2Filter' cannot be null.");
        else if (airportDisplayProperty2Filter !== undefined)
            url_ += "AirportDisplayProperty2Filter=" + encodeURIComponent("" + airportDisplayProperty2Filter) + "&";
        if (userName2Filter === null)
            throw new Error("The parameter 'userName2Filter' cannot be null.");
        else if (userName2Filter !== undefined)
            url_ += "UserName2Filter=" + encodeURIComponent("" + userName2Filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetTravelRequestForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetTravelRequestForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetTravelRequestForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetTravelRequestForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTravelRequestForView(id: string | undefined): Observable<GetTravelRequestForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelRequests/GetTravelRequestForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTravelRequestForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTravelRequestForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTravelRequestForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTravelRequestForViewDto>;
        }));
    }

    protected processGetTravelRequestForView(response: HttpResponseBase): Observable<GetTravelRequestForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTravelRequestForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTravelRequestForEdit(id: string | undefined): Observable<GetTravelRequestForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/TravelRequests/GetTravelRequestForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTravelRequestForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTravelRequestForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetTravelRequestForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetTravelRequestForEditOutput>;
        }));
    }

    protected processGetTravelRequestForEdit(response: HttpResponseBase): Observable<GetTravelRequestForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTravelRequestForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditTravelRequestDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelRequests/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TravelRequests/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param requestNoFilter (optional) 
     * @param travelStatusFilter (optional) 
     * @param travelTypeFilter (optional) 
     * @param maxRequestDateFilter (optional) 
     * @param minRequestDateFilter (optional) 
     * @param maxRequestPlanDateFilter (optional) 
     * @param minRequestPlanDateFilter (optional) 
     * @param campFilter (optional) 
     * @param transportBusFilter (optional) 
     * @param maxCreatedDateFilter (optional) 
     * @param minCreatedDateFilter (optional) 
     * @param userNameFilter (optional) 
     * @param airportDisplayPropertyFilter (optional) 
     * @param airportDisplayProperty2Filter (optional) 
     * @param userName2Filter (optional) 
     * @return Success
     */
    getTravelRequestsToExcel(filter: string | undefined, requestNoFilter: string | undefined, travelStatusFilter: number | undefined, travelTypeFilter: number | undefined, maxRequestDateFilter: DateTime | undefined, minRequestDateFilter: DateTime | undefined, maxRequestPlanDateFilter: DateTime | undefined, minRequestPlanDateFilter: DateTime | undefined, campFilter: string | undefined, transportBusFilter: string | undefined, maxCreatedDateFilter: DateTime | undefined, minCreatedDateFilter: DateTime | undefined, userNameFilter: string | undefined, airportDisplayPropertyFilter: string | undefined, airportDisplayProperty2Filter: string | undefined, userName2Filter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelRequests/GetTravelRequestsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (requestNoFilter === null)
            throw new Error("The parameter 'requestNoFilter' cannot be null.");
        else if (requestNoFilter !== undefined)
            url_ += "RequestNoFilter=" + encodeURIComponent("" + requestNoFilter) + "&";
        if (travelStatusFilter === null)
            throw new Error("The parameter 'travelStatusFilter' cannot be null.");
        else if (travelStatusFilter !== undefined)
            url_ += "TravelStatusFilter=" + encodeURIComponent("" + travelStatusFilter) + "&";
        if (travelTypeFilter === null)
            throw new Error("The parameter 'travelTypeFilter' cannot be null.");
        else if (travelTypeFilter !== undefined)
            url_ += "TravelTypeFilter=" + encodeURIComponent("" + travelTypeFilter) + "&";
        if (maxRequestDateFilter === null)
            throw new Error("The parameter 'maxRequestDateFilter' cannot be null.");
        else if (maxRequestDateFilter !== undefined)
            url_ += "MaxRequestDateFilter=" + encodeURIComponent(maxRequestDateFilter ? "" + maxRequestDateFilter.toString() : "") + "&";
        if (minRequestDateFilter === null)
            throw new Error("The parameter 'minRequestDateFilter' cannot be null.");
        else if (minRequestDateFilter !== undefined)
            url_ += "MinRequestDateFilter=" + encodeURIComponent(minRequestDateFilter ? "" + minRequestDateFilter.toString() : "") + "&";
        if (maxRequestPlanDateFilter === null)
            throw new Error("The parameter 'maxRequestPlanDateFilter' cannot be null.");
        else if (maxRequestPlanDateFilter !== undefined)
            url_ += "MaxRequestPlanDateFilter=" + encodeURIComponent(maxRequestPlanDateFilter ? "" + maxRequestPlanDateFilter.toString() : "") + "&";
        if (minRequestPlanDateFilter === null)
            throw new Error("The parameter 'minRequestPlanDateFilter' cannot be null.");
        else if (minRequestPlanDateFilter !== undefined)
            url_ += "MinRequestPlanDateFilter=" + encodeURIComponent(minRequestPlanDateFilter ? "" + minRequestPlanDateFilter.toString() : "") + "&";
        if (campFilter === null)
            throw new Error("The parameter 'campFilter' cannot be null.");
        else if (campFilter !== undefined)
            url_ += "CampFilter=" + encodeURIComponent("" + campFilter) + "&";
        if (transportBusFilter === null)
            throw new Error("The parameter 'transportBusFilter' cannot be null.");
        else if (transportBusFilter !== undefined)
            url_ += "TransportBusFilter=" + encodeURIComponent("" + transportBusFilter) + "&";
        if (maxCreatedDateFilter === null)
            throw new Error("The parameter 'maxCreatedDateFilter' cannot be null.");
        else if (maxCreatedDateFilter !== undefined)
            url_ += "MaxCreatedDateFilter=" + encodeURIComponent(maxCreatedDateFilter ? "" + maxCreatedDateFilter.toString() : "") + "&";
        if (minCreatedDateFilter === null)
            throw new Error("The parameter 'minCreatedDateFilter' cannot be null.");
        else if (minCreatedDateFilter !== undefined)
            url_ += "MinCreatedDateFilter=" + encodeURIComponent(minCreatedDateFilter ? "" + minCreatedDateFilter.toString() : "") + "&";
        if (userNameFilter === null)
            throw new Error("The parameter 'userNameFilter' cannot be null.");
        else if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&";
        if (airportDisplayPropertyFilter === null)
            throw new Error("The parameter 'airportDisplayPropertyFilter' cannot be null.");
        else if (airportDisplayPropertyFilter !== undefined)
            url_ += "AirportDisplayPropertyFilter=" + encodeURIComponent("" + airportDisplayPropertyFilter) + "&";
        if (airportDisplayProperty2Filter === null)
            throw new Error("The parameter 'airportDisplayProperty2Filter' cannot be null.");
        else if (airportDisplayProperty2Filter !== undefined)
            url_ += "AirportDisplayProperty2Filter=" + encodeURIComponent("" + airportDisplayProperty2Filter) + "&";
        if (userName2Filter === null)
            throw new Error("The parameter 'userName2Filter' cannot be null.");
        else if (userName2Filter !== undefined)
            url_ += "UserName2Filter=" + encodeURIComponent("" + userName2Filter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTravelRequestsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTravelRequestsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetTravelRequestsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTravelRequestUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelRequests/GetAllUserForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTravelRequestUserLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTravelRequestUserLookupTableDto>;
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTravelRequestUserLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTravelRequestUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAirportForLookupTable(filter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfTravelRequestAirportLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/TravelRequests/GetAllAirportForLookupTable?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAirportForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAirportForLookupTable(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfTravelRequestAirportLookupTableDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfTravelRequestAirportLookupTableDto>;
        }));
    }

    protected processGetAllAirportForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfTravelRequestAirportLookupTableDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTravelRequestAirportLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class TwitterServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRequestToken(): Observable<TwitterGetRequestTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetRequestToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwitterGetRequestTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwitterGetRequestTokenResponse>;
        }));
    }

    protected processGetRequestToken(response: HttpResponseBase): Observable<TwitterGetRequestTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetRequestTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param token (optional) 
     * @param verifier (optional) 
     * @return Success
     */
    getAccessToken(token: string | undefined, verifier: string | undefined): Observable<TwitterGetAccessTokenResponse> {
        let url_ = this.baseUrl + "/api/Twitter/GetAccessToken?";
        if (token === null)
            throw new Error("The parameter 'token' cannot be null.");
        else if (token !== undefined)
            url_ += "token=" + encodeURIComponent("" + token) + "&";
        if (verifier === null)
            throw new Error("The parameter 'verifier' cannot be null.");
        else if (verifier !== undefined)
            url_ += "verifier=" + encodeURIComponent("" + verifier) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccessToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccessToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TwitterGetAccessTokenResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TwitterGetAccessTokenResponse>;
        }));
    }

    protected processGetAccessToken(response: HttpResponseBase): Observable<TwitterGetAccessTokenResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TwitterGetAccessTokenResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ThemeSettingsDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ThemeSettingsDto[]>;
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeSettingsDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName === null)
            throw new Error("The parameter 'themeName' cannot be null.");
        else if (themeName !== undefined)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(body: ThemeSettingsDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isDarkModeActive (optional) 
     * @return Success
     */
    changeDarkModeOfCurrentTheme(isDarkModeActive: boolean | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeDarkModeOfCurrentTheme?";
        if (isDarkModeActive === null)
            throw new Error("The parameter 'isDarkModeActive' cannot be null.");
        else if (isDarkModeActive !== undefined)
            url_ += "isDarkModeActive=" + encodeURIComponent("" + isDarkModeActive) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeDarkModeOfCurrentTheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeDarkModeOfCurrentTheme(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processChangeDarkModeOfCurrentTheme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UNSPSCsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param uNSPSC_CodeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param accountCodeFilter (optional) 
     * @param descriptionIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, uNSPSC_CodeFilter: string | undefined, descriptionFilter: string | undefined, accountCodeFilter: string | undefined, descriptionIdFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetUNSPSCForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UNSPSCs/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (uNSPSC_CodeFilter === null)
            throw new Error("The parameter 'uNSPSC_CodeFilter' cannot be null.");
        else if (uNSPSC_CodeFilter !== undefined)
            url_ += "UNSPSC_CodeFilter=" + encodeURIComponent("" + uNSPSC_CodeFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (accountCodeFilter === null)
            throw new Error("The parameter 'accountCodeFilter' cannot be null.");
        else if (accountCodeFilter !== undefined)
            url_ += "AccountCodeFilter=" + encodeURIComponent("" + accountCodeFilter) + "&";
        if (descriptionIdFilter === null)
            throw new Error("The parameter 'descriptionIdFilter' cannot be null.");
        else if (descriptionIdFilter !== undefined)
            url_ += "DescriptionIdFilter=" + encodeURIComponent("" + descriptionIdFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetUNSPSCForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetUNSPSCForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUNSPSCForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUNSPSCForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUNSPSCForView(id: string | undefined): Observable<GetUNSPSCForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UNSPSCs/GetUNSPSCForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUNSPSCForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUNSPSCForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUNSPSCForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUNSPSCForViewDto>;
        }));
    }

    protected processGetUNSPSCForView(response: HttpResponseBase): Observable<GetUNSPSCForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUNSPSCForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUNSPSCForEdit(id: string | undefined): Observable<GetUNSPSCForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UNSPSCs/GetUNSPSCForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUNSPSCForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUNSPSCForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUNSPSCForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUNSPSCForEditOutput>;
        }));
    }

    protected processGetUNSPSCForEdit(response: HttpResponseBase): Observable<GetUNSPSCForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUNSPSCForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditUNSPSCDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UNSPSCs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UNSPSCs/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param uNSPSC_CodeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param accountCodeFilter (optional) 
     * @param descriptionIdFilter (optional) 
     * @return Success
     */
    getUNSPSCsToExcel(filter: string | undefined, uNSPSC_CodeFilter: string | undefined, descriptionFilter: string | undefined, accountCodeFilter: string | undefined, descriptionIdFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/UNSPSCs/GetUNSPSCsToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (uNSPSC_CodeFilter === null)
            throw new Error("The parameter 'uNSPSC_CodeFilter' cannot be null.");
        else if (uNSPSC_CodeFilter !== undefined)
            url_ += "UNSPSC_CodeFilter=" + encodeURIComponent("" + uNSPSC_CodeFilter) + "&";
        if (descriptionFilter === null)
            throw new Error("The parameter 'descriptionFilter' cannot be null.");
        else if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&";
        if (accountCodeFilter === null)
            throw new Error("The parameter 'accountCodeFilter' cannot be null.");
        else if (accountCodeFilter !== undefined)
            url_ += "AccountCodeFilter=" + encodeURIComponent("" + accountCodeFilter) + "&";
        if (descriptionIdFilter === null)
            throw new Error("The parameter 'descriptionIdFilter' cannot be null.");
        else if (descriptionIdFilter !== undefined)
            url_ += "DescriptionIdFilter=" + encodeURIComponent("" + descriptionIdFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUNSPSCsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUNSPSCsToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetUNSPSCsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUsers(body: GetUsersInput | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserListDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserListDto>;
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getUsersToExcel(filter: string | undefined, permissions: string[] | undefined, role: number | undefined, onlyLockedUsers: boolean | undefined, sorting: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (permissions === null)
            throw new Error("The parameter 'permissions' cannot be null.");
        else if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (onlyLockedUsers === null)
            throw new Error("The parameter 'onlyLockedUsers' cannot be null.");
        else if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserForEditOutput>;
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUserPermissionsForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUserPermissionsForEditOutput>;
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateUserPermissions(body: UpdateUserPermissionsInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrUpdateUser(body: CreateOrUpdateUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlockUser(body: EntityDtoOfInt64 | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserDelegationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getDelegatedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined): Observable<PagedResultDtoOfUserDelegationDto> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetDelegatedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDelegatedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDelegatedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserDelegationDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserDelegationDto>;
        }));
    }

    protected processGetDelegatedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserDelegationDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserDelegationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    delegateNewUser(body: CreateUserDelegationDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/DelegateNewUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelegateNewUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelegateNewUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelegateNewUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    removeDelegation(id: number | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/RemoveDelegation?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveDelegation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveDelegation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRemoveDelegation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getActiveUserDelegations(): Observable<UserDelegationDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UserDelegation/GetActiveUserDelegations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveUserDelegations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveUserDelegations(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserDelegationDto[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserDelegationDto[]>;
        }));
    }

    protected processGetActiveUserDelegations(response: HttpResponseBase): Observable<UserDelegationDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserDelegationDto.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    linkToUser(body: LinkToUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | undefined, skipCount: number | undefined, sorting: string | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfLinkedUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfLinkedUserDto>;
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfLinkedUserDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfLinkedUserDto>;
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    unlinkUser(body: UnlinkUserInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param result (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserLoginAttempts(filter: string | undefined, startDate: DateTime | undefined, endDate: DateTime | undefined, result: AbpLoginResultType | undefined, sorting: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetUserLoginAttempts?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.");
        else if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toString() : "") + "&";
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.");
        else if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toString() : "") + "&";
        if (result === null)
            throw new Error("The parameter 'result' cannot be null.");
        else if (result !== undefined)
            url_ += "Result=" + encodeURIComponent("" + result) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserLoginAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfUserLoginAttemptDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfUserLoginAttemptDto>;
        }));
    }

    protected processGetUserLoginAttempts(response: HttpResponseBase): Observable<PagedResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebhookEventServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    get(id: string | undefined): Observable<WebhookEvent> {
        let url_ = this.baseUrl + "/api/services/app/WebhookEvent/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebhookEvent>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebhookEvent>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WebhookEvent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookEvent.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebhookSendAttemptServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param subscriptionId (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAllSendAttempts(subscriptionId: string | undefined, maxResultCount: number | undefined, skipCount: number | undefined): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttempts?";
        if (subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' cannot be null.");
        else if (subscriptionId !== undefined)
            url_ += "SubscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttempts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetAllSendAttemptsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetAllSendAttemptsOutput>;
        }));
    }

    protected processGetAllSendAttempts(response: HttpResponseBase): Observable<PagedResultDtoOfGetAllSendAttemptsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAllSendAttemptsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAllSendAttemptsOfWebhookEvent(id: string | undefined): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/GetAllSendAttemptsOfWebhookEvent?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSendAttemptsOfWebhookEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSendAttemptsOfWebhookEvent(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput>;
        }));
    }

    protected processGetAllSendAttemptsOfWebhookEvent(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param sendAttemptId (optional) 
     * @return Success
     */
    resend(sendAttemptId: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSendAttempt/Resend?";
        if (sendAttemptId === null)
            throw new Error("The parameter 'sendAttemptId' cannot be null.");
        else if (sendAttemptId !== undefined)
            url_ += "sendAttemptId=" + encodeURIComponent("" + sendAttemptId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResend(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResend(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResend(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebhookSubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    publishTestWebhook(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/PublishTestWebhook";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPublishTestWebhook(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPublishTestWebhook(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processPublishTestWebhook(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllSubscriptions(): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
        }));
    }

    protected processGetAllSubscriptions(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param subscriptionId (optional) 
     * @return Success
     */
    getSubscription(subscriptionId: string | undefined): Observable<WebhookSubscription> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetSubscription?";
        if (subscriptionId === null)
            throw new Error("The parameter 'subscriptionId' cannot be null.");
        else if (subscriptionId !== undefined)
            url_ += "subscriptionId=" + encodeURIComponent("" + subscriptionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebhookSubscription>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebhookSubscription>;
        }));
    }

    protected processGetSubscription(response: HttpResponseBase): Observable<WebhookSubscription> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WebhookSubscription.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    addSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/AddSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processAddSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateSubscription(body: WebhookSubscription | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    activateWebhookSubscription(body: ActivateWebhookSubscriptionInput | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/ActivateWebhookSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateWebhookSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateWebhookSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processActivateWebhookSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    isSubscribed(webhookName: string | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/IsSubscribed?";
        if (webhookName === null)
            throw new Error("The parameter 'webhookName' cannot be null.");
        else if (webhookName !== undefined)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsSubscribed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsSubscribed(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<boolean>;
                }
            } else
                return _observableThrow(response_) as any as Observable<boolean>;
        }));
    }

    protected processIsSubscribed(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param webhookName (optional) 
     * @return Success
     */
    getAllSubscriptionsIfFeaturesGranted(webhookName: string | undefined): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllSubscriptionsIfFeaturesGranted?";
        if (webhookName === null)
            throw new Error("The parameter 'webhookName' cannot be null.");
        else if (webhookName !== undefined)
            url_ += "webhookName=" + encodeURIComponent("" + webhookName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubscriptionsIfFeaturesGranted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubscriptionsIfFeaturesGranted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllSubscriptionsOutput>;
        }));
    }

    protected processGetAllSubscriptionsIfFeaturesGranted(response: HttpResponseBase): Observable<ListResultDtoOfGetAllSubscriptionsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllSubscriptionsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getAllAvailableWebhooks(): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebhookSubscription/GetAllAvailableWebhooks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAvailableWebhooks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAvailableWebhooks(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ListResultDtoOfGetAllAvailableWebhooksOutput>;
        }));
    }

    protected processGetAllAvailableWebhooks(response: HttpResponseBase): Observable<ListResultDtoOfGetAllAvailableWebhooksOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfGetAllAvailableWebhooksOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetLatestWebLogsOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetLatestWebLogsOutput>;
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLatestWebLogsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ZMM020RServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param purchaseRequisitionFilter (optional) 
     * @param documentTypeFilter (optional) 
     * @param documentTypeTextFilter (optional) 
     * @param itemRequisitionFilter (optional) 
     * @param processingStatusCodeFilter (optional) 
     * @param processingStatusFilter (optional) 
     * @param deletionIndicatorFilter (optional) 
     * @param itemCategoryFilter (optional) 
     * @param accountAssignmentFilter (optional) 
     * @param materialFilter (optional) 
     * @param shortTextFilter (optional) 
     * @param maxQuantityRequestedFilter (optional) 
     * @param minQuantityRequestedFilter (optional) 
     * @param unitOfMeasureFilter (optional) 
     * @param serviceItemFilter (optional) 
     * @param serviceFilter (optional) 
     * @param serviceShortTextFilter (optional) 
     * @param maxQuantityServiceFilter (optional) 
     * @param minQuantityServiceFilter (optional) 
     * @param unitOfMeasureServiceFilter (optional) 
     * @param maxDeliveryDateFilter (optional) 
     * @param minDeliveryDateFilter (optional) 
     * @param materialGroupFilter (optional) 
     * @param plantFilter (optional) 
     * @param storageLocationFilter (optional) 
     * @param purchaseGroupFilter (optional) 
     * @param requisitionerFilter (optional) 
     * @param requisitionerNameFilter (optional) 
     * @param purchasingDocumentFilter (optional) 
     * @param maxPurchaseOrderDateFilter (optional) 
     * @param minPurchaseOrderDateFilter (optional) 
     * @param outlineAgreementFilter (optional) 
     * @param princAgreementItemFilter (optional) 
     * @param purchasingInfoRecFilter (optional) 
     * @param statusFilter (optional) 
     * @param createdByFilter (optional) 
     * @param currencyFilter (optional) 
     * @param entrySheetFilter (optional) 
     * @param goodsReceiptFilter (optional) 
     * @param supplierCodeFilter (optional) 
     * @param supplierNameFilter (optional) 
     * @param releaseIndicatorFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxValuationPriceFilter (optional) 
     * @param minValuationPriceFilter (optional) 
     * @param itemTextFilter (optional) 
     * @param longTextFilter (optional) 
     * @param maxFirstApprovalDateFilter (optional) 
     * @param minFirstApprovalDateFilter (optional) 
     * @param firstApprovalNameFilter (optional) 
     * @param maxLastApprovalDateFilter (optional) 
     * @param minLastApprovalDateFilter (optional) 
     * @param lastApprovalNameFilter (optional) 
     * @param costCenterFilter (optional) 
     * @param costCenterDescriptionFilter (optional) 
     * @param wBSElementFilter (optional) 
     * @param assetFilter (optional) 
     * @param fundsCenterFilter (optional) 
     * @param maxRemainQuantityFilter (optional) 
     * @param minRemainQuantityFilter (optional) 
     * @param maxCreatedDateFilter (optional) 
     * @param minCreatedDateFilter (optional) 
     * @param maxUpdatedDateFilter (optional) 
     * @param minUpdatedDateFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, purchaseRequisitionFilter: string | undefined, documentTypeFilter: string | undefined, documentTypeTextFilter: string | undefined, itemRequisitionFilter: string | undefined, processingStatusCodeFilter: string | undefined, processingStatusFilter: string | undefined, deletionIndicatorFilter: string | undefined, itemCategoryFilter: string | undefined, accountAssignmentFilter: string | undefined, materialFilter: string | undefined, shortTextFilter: string | undefined, maxQuantityRequestedFilter: number | undefined, minQuantityRequestedFilter: number | undefined, unitOfMeasureFilter: string | undefined, serviceItemFilter: string | undefined, serviceFilter: string | undefined, serviceShortTextFilter: string | undefined, maxQuantityServiceFilter: number | undefined, minQuantityServiceFilter: number | undefined, unitOfMeasureServiceFilter: string | undefined, maxDeliveryDateFilter: DateTime | undefined, minDeliveryDateFilter: DateTime | undefined, materialGroupFilter: string | undefined, plantFilter: string | undefined, storageLocationFilter: string | undefined, purchaseGroupFilter: string | undefined, requisitionerFilter: string | undefined, requisitionerNameFilter: string | undefined, purchasingDocumentFilter: string | undefined, maxPurchaseOrderDateFilter: DateTime | undefined, minPurchaseOrderDateFilter: DateTime | undefined, outlineAgreementFilter: string | undefined, princAgreementItemFilter: string | undefined, purchasingInfoRecFilter: string | undefined, statusFilter: string | undefined, createdByFilter: string | undefined, currencyFilter: string | undefined, entrySheetFilter: string | undefined, goodsReceiptFilter: string | undefined, supplierCodeFilter: string | undefined, supplierNameFilter: string | undefined, releaseIndicatorFilter: string | undefined, maxUnitPriceFilter: number | undefined, minUnitPriceFilter: number | undefined, maxValuationPriceFilter: number | undefined, minValuationPriceFilter: number | undefined, itemTextFilter: string | undefined, longTextFilter: string | undefined, maxFirstApprovalDateFilter: DateTime | undefined, minFirstApprovalDateFilter: DateTime | undefined, firstApprovalNameFilter: string | undefined, maxLastApprovalDateFilter: DateTime | undefined, minLastApprovalDateFilter: DateTime | undefined, lastApprovalNameFilter: string | undefined, costCenterFilter: string | undefined, costCenterDescriptionFilter: string | undefined, wBSElementFilter: string | undefined, assetFilter: string | undefined, fundsCenterFilter: string | undefined, maxRemainQuantityFilter: number | undefined, minRemainQuantityFilter: number | undefined, maxCreatedDateFilter: DateTime | undefined, minCreatedDateFilter: DateTime | undefined, maxUpdatedDateFilter: DateTime | undefined, minUpdatedDateFilter: DateTime | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetZMM020RForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ZMM020R/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (purchaseRequisitionFilter === null)
            throw new Error("The parameter 'purchaseRequisitionFilter' cannot be null.");
        else if (purchaseRequisitionFilter !== undefined)
            url_ += "PurchaseRequisitionFilter=" + encodeURIComponent("" + purchaseRequisitionFilter) + "&";
        if (documentTypeFilter === null)
            throw new Error("The parameter 'documentTypeFilter' cannot be null.");
        else if (documentTypeFilter !== undefined)
            url_ += "DocumentTypeFilter=" + encodeURIComponent("" + documentTypeFilter) + "&";
        if (documentTypeTextFilter === null)
            throw new Error("The parameter 'documentTypeTextFilter' cannot be null.");
        else if (documentTypeTextFilter !== undefined)
            url_ += "DocumentTypeTextFilter=" + encodeURIComponent("" + documentTypeTextFilter) + "&";
        if (itemRequisitionFilter === null)
            throw new Error("The parameter 'itemRequisitionFilter' cannot be null.");
        else if (itemRequisitionFilter !== undefined)
            url_ += "ItemRequisitionFilter=" + encodeURIComponent("" + itemRequisitionFilter) + "&";
        if (processingStatusCodeFilter === null)
            throw new Error("The parameter 'processingStatusCodeFilter' cannot be null.");
        else if (processingStatusCodeFilter !== undefined)
            url_ += "ProcessingStatusCodeFilter=" + encodeURIComponent("" + processingStatusCodeFilter) + "&";
        if (processingStatusFilter === null)
            throw new Error("The parameter 'processingStatusFilter' cannot be null.");
        else if (processingStatusFilter !== undefined)
            url_ += "ProcessingStatusFilter=" + encodeURIComponent("" + processingStatusFilter) + "&";
        if (deletionIndicatorFilter === null)
            throw new Error("The parameter 'deletionIndicatorFilter' cannot be null.");
        else if (deletionIndicatorFilter !== undefined)
            url_ += "DeletionIndicatorFilter=" + encodeURIComponent("" + deletionIndicatorFilter) + "&";
        if (itemCategoryFilter === null)
            throw new Error("The parameter 'itemCategoryFilter' cannot be null.");
        else if (itemCategoryFilter !== undefined)
            url_ += "ItemCategoryFilter=" + encodeURIComponent("" + itemCategoryFilter) + "&";
        if (accountAssignmentFilter === null)
            throw new Error("The parameter 'accountAssignmentFilter' cannot be null.");
        else if (accountAssignmentFilter !== undefined)
            url_ += "AccountAssignmentFilter=" + encodeURIComponent("" + accountAssignmentFilter) + "&";
        if (materialFilter === null)
            throw new Error("The parameter 'materialFilter' cannot be null.");
        else if (materialFilter !== undefined)
            url_ += "MaterialFilter=" + encodeURIComponent("" + materialFilter) + "&";
        if (shortTextFilter === null)
            throw new Error("The parameter 'shortTextFilter' cannot be null.");
        else if (shortTextFilter !== undefined)
            url_ += "ShortTextFilter=" + encodeURIComponent("" + shortTextFilter) + "&";
        if (maxQuantityRequestedFilter === null)
            throw new Error("The parameter 'maxQuantityRequestedFilter' cannot be null.");
        else if (maxQuantityRequestedFilter !== undefined)
            url_ += "MaxQuantityRequestedFilter=" + encodeURIComponent("" + maxQuantityRequestedFilter) + "&";
        if (minQuantityRequestedFilter === null)
            throw new Error("The parameter 'minQuantityRequestedFilter' cannot be null.");
        else if (minQuantityRequestedFilter !== undefined)
            url_ += "MinQuantityRequestedFilter=" + encodeURIComponent("" + minQuantityRequestedFilter) + "&";
        if (unitOfMeasureFilter === null)
            throw new Error("The parameter 'unitOfMeasureFilter' cannot be null.");
        else if (unitOfMeasureFilter !== undefined)
            url_ += "UnitOfMeasureFilter=" + encodeURIComponent("" + unitOfMeasureFilter) + "&";
        if (serviceItemFilter === null)
            throw new Error("The parameter 'serviceItemFilter' cannot be null.");
        else if (serviceItemFilter !== undefined)
            url_ += "ServiceItemFilter=" + encodeURIComponent("" + serviceItemFilter) + "&";
        if (serviceFilter === null)
            throw new Error("The parameter 'serviceFilter' cannot be null.");
        else if (serviceFilter !== undefined)
            url_ += "ServiceFilter=" + encodeURIComponent("" + serviceFilter) + "&";
        if (serviceShortTextFilter === null)
            throw new Error("The parameter 'serviceShortTextFilter' cannot be null.");
        else if (serviceShortTextFilter !== undefined)
            url_ += "ServiceShortTextFilter=" + encodeURIComponent("" + serviceShortTextFilter) + "&";
        if (maxQuantityServiceFilter === null)
            throw new Error("The parameter 'maxQuantityServiceFilter' cannot be null.");
        else if (maxQuantityServiceFilter !== undefined)
            url_ += "MaxQuantityServiceFilter=" + encodeURIComponent("" + maxQuantityServiceFilter) + "&";
        if (minQuantityServiceFilter === null)
            throw new Error("The parameter 'minQuantityServiceFilter' cannot be null.");
        else if (minQuantityServiceFilter !== undefined)
            url_ += "MinQuantityServiceFilter=" + encodeURIComponent("" + minQuantityServiceFilter) + "&";
        if (unitOfMeasureServiceFilter === null)
            throw new Error("The parameter 'unitOfMeasureServiceFilter' cannot be null.");
        else if (unitOfMeasureServiceFilter !== undefined)
            url_ += "UnitOfMeasureServiceFilter=" + encodeURIComponent("" + unitOfMeasureServiceFilter) + "&";
        if (maxDeliveryDateFilter === null)
            throw new Error("The parameter 'maxDeliveryDateFilter' cannot be null.");
        else if (maxDeliveryDateFilter !== undefined)
            url_ += "MaxDeliveryDateFilter=" + encodeURIComponent(maxDeliveryDateFilter ? "" + maxDeliveryDateFilter.toString() : "") + "&";
        if (minDeliveryDateFilter === null)
            throw new Error("The parameter 'minDeliveryDateFilter' cannot be null.");
        else if (minDeliveryDateFilter !== undefined)
            url_ += "MinDeliveryDateFilter=" + encodeURIComponent(minDeliveryDateFilter ? "" + minDeliveryDateFilter.toString() : "") + "&";
        if (materialGroupFilter === null)
            throw new Error("The parameter 'materialGroupFilter' cannot be null.");
        else if (materialGroupFilter !== undefined)
            url_ += "MaterialGroupFilter=" + encodeURIComponent("" + materialGroupFilter) + "&";
        if (plantFilter === null)
            throw new Error("The parameter 'plantFilter' cannot be null.");
        else if (plantFilter !== undefined)
            url_ += "PlantFilter=" + encodeURIComponent("" + plantFilter) + "&";
        if (storageLocationFilter === null)
            throw new Error("The parameter 'storageLocationFilter' cannot be null.");
        else if (storageLocationFilter !== undefined)
            url_ += "StorageLocationFilter=" + encodeURIComponent("" + storageLocationFilter) + "&";
        if (purchaseGroupFilter === null)
            throw new Error("The parameter 'purchaseGroupFilter' cannot be null.");
        else if (purchaseGroupFilter !== undefined)
            url_ += "PurchaseGroupFilter=" + encodeURIComponent("" + purchaseGroupFilter) + "&";
        if (requisitionerFilter === null)
            throw new Error("The parameter 'requisitionerFilter' cannot be null.");
        else if (requisitionerFilter !== undefined)
            url_ += "RequisitionerFilter=" + encodeURIComponent("" + requisitionerFilter) + "&";
        if (requisitionerNameFilter === null)
            throw new Error("The parameter 'requisitionerNameFilter' cannot be null.");
        else if (requisitionerNameFilter !== undefined)
            url_ += "RequisitionerNameFilter=" + encodeURIComponent("" + requisitionerNameFilter) + "&";
        if (purchasingDocumentFilter === null)
            throw new Error("The parameter 'purchasingDocumentFilter' cannot be null.");
        else if (purchasingDocumentFilter !== undefined)
            url_ += "PurchasingDocumentFilter=" + encodeURIComponent("" + purchasingDocumentFilter) + "&";
        if (maxPurchaseOrderDateFilter === null)
            throw new Error("The parameter 'maxPurchaseOrderDateFilter' cannot be null.");
        else if (maxPurchaseOrderDateFilter !== undefined)
            url_ += "MaxPurchaseOrderDateFilter=" + encodeURIComponent(maxPurchaseOrderDateFilter ? "" + maxPurchaseOrderDateFilter.toString() : "") + "&";
        if (minPurchaseOrderDateFilter === null)
            throw new Error("The parameter 'minPurchaseOrderDateFilter' cannot be null.");
        else if (minPurchaseOrderDateFilter !== undefined)
            url_ += "MinPurchaseOrderDateFilter=" + encodeURIComponent(minPurchaseOrderDateFilter ? "" + minPurchaseOrderDateFilter.toString() : "") + "&";
        if (outlineAgreementFilter === null)
            throw new Error("The parameter 'outlineAgreementFilter' cannot be null.");
        else if (outlineAgreementFilter !== undefined)
            url_ += "OutlineAgreementFilter=" + encodeURIComponent("" + outlineAgreementFilter) + "&";
        if (princAgreementItemFilter === null)
            throw new Error("The parameter 'princAgreementItemFilter' cannot be null.");
        else if (princAgreementItemFilter !== undefined)
            url_ += "PrincAgreementItemFilter=" + encodeURIComponent("" + princAgreementItemFilter) + "&";
        if (purchasingInfoRecFilter === null)
            throw new Error("The parameter 'purchasingInfoRecFilter' cannot be null.");
        else if (purchasingInfoRecFilter !== undefined)
            url_ += "PurchasingInfoRecFilter=" + encodeURIComponent("" + purchasingInfoRecFilter) + "&";
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&";
        if (createdByFilter === null)
            throw new Error("The parameter 'createdByFilter' cannot be null.");
        else if (createdByFilter !== undefined)
            url_ += "CreatedByFilter=" + encodeURIComponent("" + createdByFilter) + "&";
        if (currencyFilter === null)
            throw new Error("The parameter 'currencyFilter' cannot be null.");
        else if (currencyFilter !== undefined)
            url_ += "CurrencyFilter=" + encodeURIComponent("" + currencyFilter) + "&";
        if (entrySheetFilter === null)
            throw new Error("The parameter 'entrySheetFilter' cannot be null.");
        else if (entrySheetFilter !== undefined)
            url_ += "EntrySheetFilter=" + encodeURIComponent("" + entrySheetFilter) + "&";
        if (goodsReceiptFilter === null)
            throw new Error("The parameter 'goodsReceiptFilter' cannot be null.");
        else if (goodsReceiptFilter !== undefined)
            url_ += "GoodsReceiptFilter=" + encodeURIComponent("" + goodsReceiptFilter) + "&";
        if (supplierCodeFilter === null)
            throw new Error("The parameter 'supplierCodeFilter' cannot be null.");
        else if (supplierCodeFilter !== undefined)
            url_ += "SupplierCodeFilter=" + encodeURIComponent("" + supplierCodeFilter) + "&";
        if (supplierNameFilter === null)
            throw new Error("The parameter 'supplierNameFilter' cannot be null.");
        else if (supplierNameFilter !== undefined)
            url_ += "SupplierNameFilter=" + encodeURIComponent("" + supplierNameFilter) + "&";
        if (releaseIndicatorFilter === null)
            throw new Error("The parameter 'releaseIndicatorFilter' cannot be null.");
        else if (releaseIndicatorFilter !== undefined)
            url_ += "ReleaseIndicatorFilter=" + encodeURIComponent("" + releaseIndicatorFilter) + "&";
        if (maxUnitPriceFilter === null)
            throw new Error("The parameter 'maxUnitPriceFilter' cannot be null.");
        else if (maxUnitPriceFilter !== undefined)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&";
        if (minUnitPriceFilter === null)
            throw new Error("The parameter 'minUnitPriceFilter' cannot be null.");
        else if (minUnitPriceFilter !== undefined)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&";
        if (maxValuationPriceFilter === null)
            throw new Error("The parameter 'maxValuationPriceFilter' cannot be null.");
        else if (maxValuationPriceFilter !== undefined)
            url_ += "MaxValuationPriceFilter=" + encodeURIComponent("" + maxValuationPriceFilter) + "&";
        if (minValuationPriceFilter === null)
            throw new Error("The parameter 'minValuationPriceFilter' cannot be null.");
        else if (minValuationPriceFilter !== undefined)
            url_ += "MinValuationPriceFilter=" + encodeURIComponent("" + minValuationPriceFilter) + "&";
        if (itemTextFilter === null)
            throw new Error("The parameter 'itemTextFilter' cannot be null.");
        else if (itemTextFilter !== undefined)
            url_ += "ItemTextFilter=" + encodeURIComponent("" + itemTextFilter) + "&";
        if (longTextFilter === null)
            throw new Error("The parameter 'longTextFilter' cannot be null.");
        else if (longTextFilter !== undefined)
            url_ += "LongTextFilter=" + encodeURIComponent("" + longTextFilter) + "&";
        if (maxFirstApprovalDateFilter === null)
            throw new Error("The parameter 'maxFirstApprovalDateFilter' cannot be null.");
        else if (maxFirstApprovalDateFilter !== undefined)
            url_ += "MaxFirstApprovalDateFilter=" + encodeURIComponent(maxFirstApprovalDateFilter ? "" + maxFirstApprovalDateFilter.toString() : "") + "&";
        if (minFirstApprovalDateFilter === null)
            throw new Error("The parameter 'minFirstApprovalDateFilter' cannot be null.");
        else if (minFirstApprovalDateFilter !== undefined)
            url_ += "MinFirstApprovalDateFilter=" + encodeURIComponent(minFirstApprovalDateFilter ? "" + minFirstApprovalDateFilter.toString() : "") + "&";
        if (firstApprovalNameFilter === null)
            throw new Error("The parameter 'firstApprovalNameFilter' cannot be null.");
        else if (firstApprovalNameFilter !== undefined)
            url_ += "FirstApprovalNameFilter=" + encodeURIComponent("" + firstApprovalNameFilter) + "&";
        if (maxLastApprovalDateFilter === null)
            throw new Error("The parameter 'maxLastApprovalDateFilter' cannot be null.");
        else if (maxLastApprovalDateFilter !== undefined)
            url_ += "MaxLastApprovalDateFilter=" + encodeURIComponent(maxLastApprovalDateFilter ? "" + maxLastApprovalDateFilter.toString() : "") + "&";
        if (minLastApprovalDateFilter === null)
            throw new Error("The parameter 'minLastApprovalDateFilter' cannot be null.");
        else if (minLastApprovalDateFilter !== undefined)
            url_ += "MinLastApprovalDateFilter=" + encodeURIComponent(minLastApprovalDateFilter ? "" + minLastApprovalDateFilter.toString() : "") + "&";
        if (lastApprovalNameFilter === null)
            throw new Error("The parameter 'lastApprovalNameFilter' cannot be null.");
        else if (lastApprovalNameFilter !== undefined)
            url_ += "LastApprovalNameFilter=" + encodeURIComponent("" + lastApprovalNameFilter) + "&";
        if (costCenterFilter === null)
            throw new Error("The parameter 'costCenterFilter' cannot be null.");
        else if (costCenterFilter !== undefined)
            url_ += "CostCenterFilter=" + encodeURIComponent("" + costCenterFilter) + "&";
        if (costCenterDescriptionFilter === null)
            throw new Error("The parameter 'costCenterDescriptionFilter' cannot be null.");
        else if (costCenterDescriptionFilter !== undefined)
            url_ += "CostCenterDescriptionFilter=" + encodeURIComponent("" + costCenterDescriptionFilter) + "&";
        if (wBSElementFilter === null)
            throw new Error("The parameter 'wBSElementFilter' cannot be null.");
        else if (wBSElementFilter !== undefined)
            url_ += "WBSElementFilter=" + encodeURIComponent("" + wBSElementFilter) + "&";
        if (assetFilter === null)
            throw new Error("The parameter 'assetFilter' cannot be null.");
        else if (assetFilter !== undefined)
            url_ += "AssetFilter=" + encodeURIComponent("" + assetFilter) + "&";
        if (fundsCenterFilter === null)
            throw new Error("The parameter 'fundsCenterFilter' cannot be null.");
        else if (fundsCenterFilter !== undefined)
            url_ += "FundsCenterFilter=" + encodeURIComponent("" + fundsCenterFilter) + "&";
        if (maxRemainQuantityFilter === null)
            throw new Error("The parameter 'maxRemainQuantityFilter' cannot be null.");
        else if (maxRemainQuantityFilter !== undefined)
            url_ += "MaxRemainQuantityFilter=" + encodeURIComponent("" + maxRemainQuantityFilter) + "&";
        if (minRemainQuantityFilter === null)
            throw new Error("The parameter 'minRemainQuantityFilter' cannot be null.");
        else if (minRemainQuantityFilter !== undefined)
            url_ += "MinRemainQuantityFilter=" + encodeURIComponent("" + minRemainQuantityFilter) + "&";
        if (maxCreatedDateFilter === null)
            throw new Error("The parameter 'maxCreatedDateFilter' cannot be null.");
        else if (maxCreatedDateFilter !== undefined)
            url_ += "MaxCreatedDateFilter=" + encodeURIComponent(maxCreatedDateFilter ? "" + maxCreatedDateFilter.toString() : "") + "&";
        if (minCreatedDateFilter === null)
            throw new Error("The parameter 'minCreatedDateFilter' cannot be null.");
        else if (minCreatedDateFilter !== undefined)
            url_ += "MinCreatedDateFilter=" + encodeURIComponent(minCreatedDateFilter ? "" + minCreatedDateFilter.toString() : "") + "&";
        if (maxUpdatedDateFilter === null)
            throw new Error("The parameter 'maxUpdatedDateFilter' cannot be null.");
        else if (maxUpdatedDateFilter !== undefined)
            url_ += "MaxUpdatedDateFilter=" + encodeURIComponent(maxUpdatedDateFilter ? "" + maxUpdatedDateFilter.toString() : "") + "&";
        if (minUpdatedDateFilter === null)
            throw new Error("The parameter 'minUpdatedDateFilter' cannot be null.");
        else if (minUpdatedDateFilter !== undefined)
            url_ += "MinUpdatedDateFilter=" + encodeURIComponent(minUpdatedDateFilter ? "" + minUpdatedDateFilter.toString() : "") + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetZMM020RForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetZMM020RForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetZMM020RForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetZMM020RForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getZMM020RForView(id: string | undefined): Observable<GetZMM020RForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ZMM020R/GetZMM020RForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZMM020RForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZMM020RForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetZMM020RForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetZMM020RForViewDto>;
        }));
    }

    protected processGetZMM020RForView(response: HttpResponseBase): Observable<GetZMM020RForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetZMM020RForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getZMM020RForEdit(id: string | undefined): Observable<GetZMM020RForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ZMM020R/GetZMM020RForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZMM020RForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZMM020RForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetZMM020RForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetZMM020RForEditOutput>;
        }));
    }

    protected processGetZMM020RForEdit(response: HttpResponseBase): Observable<GetZMM020RForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetZMM020RForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditZMM020RDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ZMM020R/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ZMM020R/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param purchaseRequisitionFilter (optional) 
     * @param documentTypeFilter (optional) 
     * @param documentTypeTextFilter (optional) 
     * @param itemRequisitionFilter (optional) 
     * @param processingStatusCodeFilter (optional) 
     * @param processingStatusFilter (optional) 
     * @param deletionIndicatorFilter (optional) 
     * @param itemCategoryFilter (optional) 
     * @param accountAssignmentFilter (optional) 
     * @param materialFilter (optional) 
     * @param shortTextFilter (optional) 
     * @param maxQuantityRequestedFilter (optional) 
     * @param minQuantityRequestedFilter (optional) 
     * @param unitOfMeasureFilter (optional) 
     * @param serviceItemFilter (optional) 
     * @param serviceFilter (optional) 
     * @param serviceShortTextFilter (optional) 
     * @param maxQuantityServiceFilter (optional) 
     * @param minQuantityServiceFilter (optional) 
     * @param unitOfMeasureServiceFilter (optional) 
     * @param maxDeliveryDateFilter (optional) 
     * @param minDeliveryDateFilter (optional) 
     * @param materialGroupFilter (optional) 
     * @param plantFilter (optional) 
     * @param storageLocationFilter (optional) 
     * @param purchaseGroupFilter (optional) 
     * @param requisitionerFilter (optional) 
     * @param requisitionerNameFilter (optional) 
     * @param purchasingDocumentFilter (optional) 
     * @param maxPurchaseOrderDateFilter (optional) 
     * @param minPurchaseOrderDateFilter (optional) 
     * @param outlineAgreementFilter (optional) 
     * @param princAgreementItemFilter (optional) 
     * @param purchasingInfoRecFilter (optional) 
     * @param statusFilter (optional) 
     * @param createdByFilter (optional) 
     * @param currencyFilter (optional) 
     * @param entrySheetFilter (optional) 
     * @param goodsReceiptFilter (optional) 
     * @param supplierCodeFilter (optional) 
     * @param supplierNameFilter (optional) 
     * @param releaseIndicatorFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxValuationPriceFilter (optional) 
     * @param minValuationPriceFilter (optional) 
     * @param itemTextFilter (optional) 
     * @param longTextFilter (optional) 
     * @param maxFirstApprovalDateFilter (optional) 
     * @param minFirstApprovalDateFilter (optional) 
     * @param firstApprovalNameFilter (optional) 
     * @param maxLastApprovalDateFilter (optional) 
     * @param minLastApprovalDateFilter (optional) 
     * @param lastApprovalNameFilter (optional) 
     * @param costCenterFilter (optional) 
     * @param costCenterDescriptionFilter (optional) 
     * @param wBSElementFilter (optional) 
     * @param assetFilter (optional) 
     * @param fundsCenterFilter (optional) 
     * @param maxRemainQuantityFilter (optional) 
     * @param minRemainQuantityFilter (optional) 
     * @param maxCreatedDateFilter (optional) 
     * @param minCreatedDateFilter (optional) 
     * @param maxUpdatedDateFilter (optional) 
     * @param minUpdatedDateFilter (optional) 
     * @return Success
     */
    getZMM020RToExcel(filter: string | undefined, purchaseRequisitionFilter: string | undefined, documentTypeFilter: string | undefined, documentTypeTextFilter: string | undefined, itemRequisitionFilter: string | undefined, processingStatusCodeFilter: string | undefined, processingStatusFilter: string | undefined, deletionIndicatorFilter: string | undefined, itemCategoryFilter: string | undefined, accountAssignmentFilter: string | undefined, materialFilter: string | undefined, shortTextFilter: string | undefined, maxQuantityRequestedFilter: number | undefined, minQuantityRequestedFilter: number | undefined, unitOfMeasureFilter: string | undefined, serviceItemFilter: string | undefined, serviceFilter: string | undefined, serviceShortTextFilter: string | undefined, maxQuantityServiceFilter: number | undefined, minQuantityServiceFilter: number | undefined, unitOfMeasureServiceFilter: string | undefined, maxDeliveryDateFilter: DateTime | undefined, minDeliveryDateFilter: DateTime | undefined, materialGroupFilter: string | undefined, plantFilter: string | undefined, storageLocationFilter: string | undefined, purchaseGroupFilter: string | undefined, requisitionerFilter: string | undefined, requisitionerNameFilter: string | undefined, purchasingDocumentFilter: string | undefined, maxPurchaseOrderDateFilter: DateTime | undefined, minPurchaseOrderDateFilter: DateTime | undefined, outlineAgreementFilter: string | undefined, princAgreementItemFilter: string | undefined, purchasingInfoRecFilter: string | undefined, statusFilter: string | undefined, createdByFilter: string | undefined, currencyFilter: string | undefined, entrySheetFilter: string | undefined, goodsReceiptFilter: string | undefined, supplierCodeFilter: string | undefined, supplierNameFilter: string | undefined, releaseIndicatorFilter: string | undefined, maxUnitPriceFilter: number | undefined, minUnitPriceFilter: number | undefined, maxValuationPriceFilter: number | undefined, minValuationPriceFilter: number | undefined, itemTextFilter: string | undefined, longTextFilter: string | undefined, maxFirstApprovalDateFilter: DateTime | undefined, minFirstApprovalDateFilter: DateTime | undefined, firstApprovalNameFilter: string | undefined, maxLastApprovalDateFilter: DateTime | undefined, minLastApprovalDateFilter: DateTime | undefined, lastApprovalNameFilter: string | undefined, costCenterFilter: string | undefined, costCenterDescriptionFilter: string | undefined, wBSElementFilter: string | undefined, assetFilter: string | undefined, fundsCenterFilter: string | undefined, maxRemainQuantityFilter: number | undefined, minRemainQuantityFilter: number | undefined, maxCreatedDateFilter: DateTime | undefined, minCreatedDateFilter: DateTime | undefined, maxUpdatedDateFilter: DateTime | undefined, minUpdatedDateFilter: DateTime | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ZMM020R/GetZMM020RToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (purchaseRequisitionFilter === null)
            throw new Error("The parameter 'purchaseRequisitionFilter' cannot be null.");
        else if (purchaseRequisitionFilter !== undefined)
            url_ += "PurchaseRequisitionFilter=" + encodeURIComponent("" + purchaseRequisitionFilter) + "&";
        if (documentTypeFilter === null)
            throw new Error("The parameter 'documentTypeFilter' cannot be null.");
        else if (documentTypeFilter !== undefined)
            url_ += "DocumentTypeFilter=" + encodeURIComponent("" + documentTypeFilter) + "&";
        if (documentTypeTextFilter === null)
            throw new Error("The parameter 'documentTypeTextFilter' cannot be null.");
        else if (documentTypeTextFilter !== undefined)
            url_ += "DocumentTypeTextFilter=" + encodeURIComponent("" + documentTypeTextFilter) + "&";
        if (itemRequisitionFilter === null)
            throw new Error("The parameter 'itemRequisitionFilter' cannot be null.");
        else if (itemRequisitionFilter !== undefined)
            url_ += "ItemRequisitionFilter=" + encodeURIComponent("" + itemRequisitionFilter) + "&";
        if (processingStatusCodeFilter === null)
            throw new Error("The parameter 'processingStatusCodeFilter' cannot be null.");
        else if (processingStatusCodeFilter !== undefined)
            url_ += "ProcessingStatusCodeFilter=" + encodeURIComponent("" + processingStatusCodeFilter) + "&";
        if (processingStatusFilter === null)
            throw new Error("The parameter 'processingStatusFilter' cannot be null.");
        else if (processingStatusFilter !== undefined)
            url_ += "ProcessingStatusFilter=" + encodeURIComponent("" + processingStatusFilter) + "&";
        if (deletionIndicatorFilter === null)
            throw new Error("The parameter 'deletionIndicatorFilter' cannot be null.");
        else if (deletionIndicatorFilter !== undefined)
            url_ += "DeletionIndicatorFilter=" + encodeURIComponent("" + deletionIndicatorFilter) + "&";
        if (itemCategoryFilter === null)
            throw new Error("The parameter 'itemCategoryFilter' cannot be null.");
        else if (itemCategoryFilter !== undefined)
            url_ += "ItemCategoryFilter=" + encodeURIComponent("" + itemCategoryFilter) + "&";
        if (accountAssignmentFilter === null)
            throw new Error("The parameter 'accountAssignmentFilter' cannot be null.");
        else if (accountAssignmentFilter !== undefined)
            url_ += "AccountAssignmentFilter=" + encodeURIComponent("" + accountAssignmentFilter) + "&";
        if (materialFilter === null)
            throw new Error("The parameter 'materialFilter' cannot be null.");
        else if (materialFilter !== undefined)
            url_ += "MaterialFilter=" + encodeURIComponent("" + materialFilter) + "&";
        if (shortTextFilter === null)
            throw new Error("The parameter 'shortTextFilter' cannot be null.");
        else if (shortTextFilter !== undefined)
            url_ += "ShortTextFilter=" + encodeURIComponent("" + shortTextFilter) + "&";
        if (maxQuantityRequestedFilter === null)
            throw new Error("The parameter 'maxQuantityRequestedFilter' cannot be null.");
        else if (maxQuantityRequestedFilter !== undefined)
            url_ += "MaxQuantityRequestedFilter=" + encodeURIComponent("" + maxQuantityRequestedFilter) + "&";
        if (minQuantityRequestedFilter === null)
            throw new Error("The parameter 'minQuantityRequestedFilter' cannot be null.");
        else if (minQuantityRequestedFilter !== undefined)
            url_ += "MinQuantityRequestedFilter=" + encodeURIComponent("" + minQuantityRequestedFilter) + "&";
        if (unitOfMeasureFilter === null)
            throw new Error("The parameter 'unitOfMeasureFilter' cannot be null.");
        else if (unitOfMeasureFilter !== undefined)
            url_ += "UnitOfMeasureFilter=" + encodeURIComponent("" + unitOfMeasureFilter) + "&";
        if (serviceItemFilter === null)
            throw new Error("The parameter 'serviceItemFilter' cannot be null.");
        else if (serviceItemFilter !== undefined)
            url_ += "ServiceItemFilter=" + encodeURIComponent("" + serviceItemFilter) + "&";
        if (serviceFilter === null)
            throw new Error("The parameter 'serviceFilter' cannot be null.");
        else if (serviceFilter !== undefined)
            url_ += "ServiceFilter=" + encodeURIComponent("" + serviceFilter) + "&";
        if (serviceShortTextFilter === null)
            throw new Error("The parameter 'serviceShortTextFilter' cannot be null.");
        else if (serviceShortTextFilter !== undefined)
            url_ += "ServiceShortTextFilter=" + encodeURIComponent("" + serviceShortTextFilter) + "&";
        if (maxQuantityServiceFilter === null)
            throw new Error("The parameter 'maxQuantityServiceFilter' cannot be null.");
        else if (maxQuantityServiceFilter !== undefined)
            url_ += "MaxQuantityServiceFilter=" + encodeURIComponent("" + maxQuantityServiceFilter) + "&";
        if (minQuantityServiceFilter === null)
            throw new Error("The parameter 'minQuantityServiceFilter' cannot be null.");
        else if (minQuantityServiceFilter !== undefined)
            url_ += "MinQuantityServiceFilter=" + encodeURIComponent("" + minQuantityServiceFilter) + "&";
        if (unitOfMeasureServiceFilter === null)
            throw new Error("The parameter 'unitOfMeasureServiceFilter' cannot be null.");
        else if (unitOfMeasureServiceFilter !== undefined)
            url_ += "UnitOfMeasureServiceFilter=" + encodeURIComponent("" + unitOfMeasureServiceFilter) + "&";
        if (maxDeliveryDateFilter === null)
            throw new Error("The parameter 'maxDeliveryDateFilter' cannot be null.");
        else if (maxDeliveryDateFilter !== undefined)
            url_ += "MaxDeliveryDateFilter=" + encodeURIComponent(maxDeliveryDateFilter ? "" + maxDeliveryDateFilter.toString() : "") + "&";
        if (minDeliveryDateFilter === null)
            throw new Error("The parameter 'minDeliveryDateFilter' cannot be null.");
        else if (minDeliveryDateFilter !== undefined)
            url_ += "MinDeliveryDateFilter=" + encodeURIComponent(minDeliveryDateFilter ? "" + minDeliveryDateFilter.toString() : "") + "&";
        if (materialGroupFilter === null)
            throw new Error("The parameter 'materialGroupFilter' cannot be null.");
        else if (materialGroupFilter !== undefined)
            url_ += "MaterialGroupFilter=" + encodeURIComponent("" + materialGroupFilter) + "&";
        if (plantFilter === null)
            throw new Error("The parameter 'plantFilter' cannot be null.");
        else if (plantFilter !== undefined)
            url_ += "PlantFilter=" + encodeURIComponent("" + plantFilter) + "&";
        if (storageLocationFilter === null)
            throw new Error("The parameter 'storageLocationFilter' cannot be null.");
        else if (storageLocationFilter !== undefined)
            url_ += "StorageLocationFilter=" + encodeURIComponent("" + storageLocationFilter) + "&";
        if (purchaseGroupFilter === null)
            throw new Error("The parameter 'purchaseGroupFilter' cannot be null.");
        else if (purchaseGroupFilter !== undefined)
            url_ += "PurchaseGroupFilter=" + encodeURIComponent("" + purchaseGroupFilter) + "&";
        if (requisitionerFilter === null)
            throw new Error("The parameter 'requisitionerFilter' cannot be null.");
        else if (requisitionerFilter !== undefined)
            url_ += "RequisitionerFilter=" + encodeURIComponent("" + requisitionerFilter) + "&";
        if (requisitionerNameFilter === null)
            throw new Error("The parameter 'requisitionerNameFilter' cannot be null.");
        else if (requisitionerNameFilter !== undefined)
            url_ += "RequisitionerNameFilter=" + encodeURIComponent("" + requisitionerNameFilter) + "&";
        if (purchasingDocumentFilter === null)
            throw new Error("The parameter 'purchasingDocumentFilter' cannot be null.");
        else if (purchasingDocumentFilter !== undefined)
            url_ += "PurchasingDocumentFilter=" + encodeURIComponent("" + purchasingDocumentFilter) + "&";
        if (maxPurchaseOrderDateFilter === null)
            throw new Error("The parameter 'maxPurchaseOrderDateFilter' cannot be null.");
        else if (maxPurchaseOrderDateFilter !== undefined)
            url_ += "MaxPurchaseOrderDateFilter=" + encodeURIComponent(maxPurchaseOrderDateFilter ? "" + maxPurchaseOrderDateFilter.toString() : "") + "&";
        if (minPurchaseOrderDateFilter === null)
            throw new Error("The parameter 'minPurchaseOrderDateFilter' cannot be null.");
        else if (minPurchaseOrderDateFilter !== undefined)
            url_ += "MinPurchaseOrderDateFilter=" + encodeURIComponent(minPurchaseOrderDateFilter ? "" + minPurchaseOrderDateFilter.toString() : "") + "&";
        if (outlineAgreementFilter === null)
            throw new Error("The parameter 'outlineAgreementFilter' cannot be null.");
        else if (outlineAgreementFilter !== undefined)
            url_ += "OutlineAgreementFilter=" + encodeURIComponent("" + outlineAgreementFilter) + "&";
        if (princAgreementItemFilter === null)
            throw new Error("The parameter 'princAgreementItemFilter' cannot be null.");
        else if (princAgreementItemFilter !== undefined)
            url_ += "PrincAgreementItemFilter=" + encodeURIComponent("" + princAgreementItemFilter) + "&";
        if (purchasingInfoRecFilter === null)
            throw new Error("The parameter 'purchasingInfoRecFilter' cannot be null.");
        else if (purchasingInfoRecFilter !== undefined)
            url_ += "PurchasingInfoRecFilter=" + encodeURIComponent("" + purchasingInfoRecFilter) + "&";
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&";
        if (createdByFilter === null)
            throw new Error("The parameter 'createdByFilter' cannot be null.");
        else if (createdByFilter !== undefined)
            url_ += "CreatedByFilter=" + encodeURIComponent("" + createdByFilter) + "&";
        if (currencyFilter === null)
            throw new Error("The parameter 'currencyFilter' cannot be null.");
        else if (currencyFilter !== undefined)
            url_ += "CurrencyFilter=" + encodeURIComponent("" + currencyFilter) + "&";
        if (entrySheetFilter === null)
            throw new Error("The parameter 'entrySheetFilter' cannot be null.");
        else if (entrySheetFilter !== undefined)
            url_ += "EntrySheetFilter=" + encodeURIComponent("" + entrySheetFilter) + "&";
        if (goodsReceiptFilter === null)
            throw new Error("The parameter 'goodsReceiptFilter' cannot be null.");
        else if (goodsReceiptFilter !== undefined)
            url_ += "GoodsReceiptFilter=" + encodeURIComponent("" + goodsReceiptFilter) + "&";
        if (supplierCodeFilter === null)
            throw new Error("The parameter 'supplierCodeFilter' cannot be null.");
        else if (supplierCodeFilter !== undefined)
            url_ += "SupplierCodeFilter=" + encodeURIComponent("" + supplierCodeFilter) + "&";
        if (supplierNameFilter === null)
            throw new Error("The parameter 'supplierNameFilter' cannot be null.");
        else if (supplierNameFilter !== undefined)
            url_ += "SupplierNameFilter=" + encodeURIComponent("" + supplierNameFilter) + "&";
        if (releaseIndicatorFilter === null)
            throw new Error("The parameter 'releaseIndicatorFilter' cannot be null.");
        else if (releaseIndicatorFilter !== undefined)
            url_ += "ReleaseIndicatorFilter=" + encodeURIComponent("" + releaseIndicatorFilter) + "&";
        if (maxUnitPriceFilter === null)
            throw new Error("The parameter 'maxUnitPriceFilter' cannot be null.");
        else if (maxUnitPriceFilter !== undefined)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&";
        if (minUnitPriceFilter === null)
            throw new Error("The parameter 'minUnitPriceFilter' cannot be null.");
        else if (minUnitPriceFilter !== undefined)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&";
        if (maxValuationPriceFilter === null)
            throw new Error("The parameter 'maxValuationPriceFilter' cannot be null.");
        else if (maxValuationPriceFilter !== undefined)
            url_ += "MaxValuationPriceFilter=" + encodeURIComponent("" + maxValuationPriceFilter) + "&";
        if (minValuationPriceFilter === null)
            throw new Error("The parameter 'minValuationPriceFilter' cannot be null.");
        else if (minValuationPriceFilter !== undefined)
            url_ += "MinValuationPriceFilter=" + encodeURIComponent("" + minValuationPriceFilter) + "&";
        if (itemTextFilter === null)
            throw new Error("The parameter 'itemTextFilter' cannot be null.");
        else if (itemTextFilter !== undefined)
            url_ += "ItemTextFilter=" + encodeURIComponent("" + itemTextFilter) + "&";
        if (longTextFilter === null)
            throw new Error("The parameter 'longTextFilter' cannot be null.");
        else if (longTextFilter !== undefined)
            url_ += "LongTextFilter=" + encodeURIComponent("" + longTextFilter) + "&";
        if (maxFirstApprovalDateFilter === null)
            throw new Error("The parameter 'maxFirstApprovalDateFilter' cannot be null.");
        else if (maxFirstApprovalDateFilter !== undefined)
            url_ += "MaxFirstApprovalDateFilter=" + encodeURIComponent(maxFirstApprovalDateFilter ? "" + maxFirstApprovalDateFilter.toString() : "") + "&";
        if (minFirstApprovalDateFilter === null)
            throw new Error("The parameter 'minFirstApprovalDateFilter' cannot be null.");
        else if (minFirstApprovalDateFilter !== undefined)
            url_ += "MinFirstApprovalDateFilter=" + encodeURIComponent(minFirstApprovalDateFilter ? "" + minFirstApprovalDateFilter.toString() : "") + "&";
        if (firstApprovalNameFilter === null)
            throw new Error("The parameter 'firstApprovalNameFilter' cannot be null.");
        else if (firstApprovalNameFilter !== undefined)
            url_ += "FirstApprovalNameFilter=" + encodeURIComponent("" + firstApprovalNameFilter) + "&";
        if (maxLastApprovalDateFilter === null)
            throw new Error("The parameter 'maxLastApprovalDateFilter' cannot be null.");
        else if (maxLastApprovalDateFilter !== undefined)
            url_ += "MaxLastApprovalDateFilter=" + encodeURIComponent(maxLastApprovalDateFilter ? "" + maxLastApprovalDateFilter.toString() : "") + "&";
        if (minLastApprovalDateFilter === null)
            throw new Error("The parameter 'minLastApprovalDateFilter' cannot be null.");
        else if (minLastApprovalDateFilter !== undefined)
            url_ += "MinLastApprovalDateFilter=" + encodeURIComponent(minLastApprovalDateFilter ? "" + minLastApprovalDateFilter.toString() : "") + "&";
        if (lastApprovalNameFilter === null)
            throw new Error("The parameter 'lastApprovalNameFilter' cannot be null.");
        else if (lastApprovalNameFilter !== undefined)
            url_ += "LastApprovalNameFilter=" + encodeURIComponent("" + lastApprovalNameFilter) + "&";
        if (costCenterFilter === null)
            throw new Error("The parameter 'costCenterFilter' cannot be null.");
        else if (costCenterFilter !== undefined)
            url_ += "CostCenterFilter=" + encodeURIComponent("" + costCenterFilter) + "&";
        if (costCenterDescriptionFilter === null)
            throw new Error("The parameter 'costCenterDescriptionFilter' cannot be null.");
        else if (costCenterDescriptionFilter !== undefined)
            url_ += "CostCenterDescriptionFilter=" + encodeURIComponent("" + costCenterDescriptionFilter) + "&";
        if (wBSElementFilter === null)
            throw new Error("The parameter 'wBSElementFilter' cannot be null.");
        else if (wBSElementFilter !== undefined)
            url_ += "WBSElementFilter=" + encodeURIComponent("" + wBSElementFilter) + "&";
        if (assetFilter === null)
            throw new Error("The parameter 'assetFilter' cannot be null.");
        else if (assetFilter !== undefined)
            url_ += "AssetFilter=" + encodeURIComponent("" + assetFilter) + "&";
        if (fundsCenterFilter === null)
            throw new Error("The parameter 'fundsCenterFilter' cannot be null.");
        else if (fundsCenterFilter !== undefined)
            url_ += "FundsCenterFilter=" + encodeURIComponent("" + fundsCenterFilter) + "&";
        if (maxRemainQuantityFilter === null)
            throw new Error("The parameter 'maxRemainQuantityFilter' cannot be null.");
        else if (maxRemainQuantityFilter !== undefined)
            url_ += "MaxRemainQuantityFilter=" + encodeURIComponent("" + maxRemainQuantityFilter) + "&";
        if (minRemainQuantityFilter === null)
            throw new Error("The parameter 'minRemainQuantityFilter' cannot be null.");
        else if (minRemainQuantityFilter !== undefined)
            url_ += "MinRemainQuantityFilter=" + encodeURIComponent("" + minRemainQuantityFilter) + "&";
        if (maxCreatedDateFilter === null)
            throw new Error("The parameter 'maxCreatedDateFilter' cannot be null.");
        else if (maxCreatedDateFilter !== undefined)
            url_ += "MaxCreatedDateFilter=" + encodeURIComponent(maxCreatedDateFilter ? "" + maxCreatedDateFilter.toString() : "") + "&";
        if (minCreatedDateFilter === null)
            throw new Error("The parameter 'minCreatedDateFilter' cannot be null.");
        else if (minCreatedDateFilter !== undefined)
            url_ += "MinCreatedDateFilter=" + encodeURIComponent(minCreatedDateFilter ? "" + minCreatedDateFilter.toString() : "") + "&";
        if (maxUpdatedDateFilter === null)
            throw new Error("The parameter 'maxUpdatedDateFilter' cannot be null.");
        else if (maxUpdatedDateFilter !== undefined)
            url_ += "MaxUpdatedDateFilter=" + encodeURIComponent(maxUpdatedDateFilter ? "" + maxUpdatedDateFilter.toString() : "") + "&";
        if (minUpdatedDateFilter === null)
            throw new Error("The parameter 'minUpdatedDateFilter' cannot be null.");
        else if (minUpdatedDateFilter !== undefined)
            url_ += "MinUpdatedDateFilter=" + encodeURIComponent(minUpdatedDateFilter ? "" + minUpdatedDateFilter.toString() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZMM020RToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZMM020RToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetZMM020RToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ZMM021RServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param purchasingDocumentFilter (optional) 
     * @param purchasingDocTypeFilter (optional) 
     * @param purchasingDocTypeDescriptionFilter (optional) 
     * @param itemFilter (optional) 
     * @param lineNumberFilter (optional) 
     * @param deletionIndicatorFilter (optional) 
     * @param maxDocumentDateFilter (optional) 
     * @param minDocumentDateFilter (optional) 
     * @param maxCreatedOnFilter (optional) 
     * @param minCreatedOnFilter (optional) 
     * @param purchaseRequisitionFilter (optional) 
     * @param itemPRFilter (optional) 
     * @param supplierCodeFilter (optional) 
     * @param supplierNameFilter (optional) 
     * @param addressFilter (optional) 
     * @param itemNoFilter (optional) 
     * @param materialGroupFilter (optional) 
     * @param shortTextFilter (optional) 
     * @param maxOrderQuantityFilter (optional) 
     * @param minOrderQuantityFilter (optional) 
     * @param orderUnitFilter (optional) 
     * @param currencyFilter (optional) 
     * @param maxDeliveryDateFilter (optional) 
     * @param minDeliveryDateFilter (optional) 
     * @param maxNetPriceFilter (optional) 
     * @param minNetPriceFilter (optional) 
     * @param maxNetOrderValueFilter (optional) 
     * @param minNetOrderValueFilter (optional) 
     * @param maxDemurrageFilter (optional) 
     * @param minDemurrageFilter (optional) 
     * @param maxGrossPriceFilter (optional) 
     * @param minGrossPriceFilter (optional) 
     * @param maxTotalDiscountFilter (optional) 
     * @param minTotalDiscountFilter (optional) 
     * @param maxFreightCostFilter (optional) 
     * @param minFreightCostFilter (optional) 
     * @param releaseIndicatorFilter (optional) 
     * @param plantFilter (optional) 
     * @param purchasingGroupFilter (optional) 
     * @param taxCodeFilter (optional) 
     * @param collectiveNumberFilter (optional) 
     * @param itemCategoryFilter (optional) 
     * @param accountAssignmentFilter (optional) 
     * @param outlineAgreementFilter (optional) 
     * @param rFQNoFilter (optional) 
     * @param maxQtyPendingFilter (optional) 
     * @param minQtyPendingFilter (optional) 
     * @param materialServiceFilter (optional) 
     * @param approvalStatusFilter (optional) 
     * @param pOStatusFilter (optional) 
     * @param periodFilter (optional) 
     * @param commentVendorFilter (optional) 
     * @param itemTextFilter (optional) 
     * @param longTextFilter (optional) 
     * @param ourReferenceFilter (optional) 
     * @param maxPRFinalFirstApprovalDateFilter (optional) 
     * @param minPRFinalFirstApprovalDateFilter (optional) 
     * @param maxPRFinalLastApprovalDateFilter (optional) 
     * @param minPRFinalLastApprovalDateFilter (optional) 
     * @param maxPOFirstApprovalDateFilter (optional) 
     * @param minPOFirstApprovalDateFilter (optional) 
     * @param maxPOLastApprovalDateFilter (optional) 
     * @param minPOLastApprovalDateFilter (optional) 
     * @param pOApprovalNameFilter (optional) 
     * @param buyerCodeFilter (optional) 
     * @param buyerNameFilter (optional) 
     * @param pICDeptFilter (optional) 
     * @param pICSectFilter (optional) 
     * @param fuelAllocationFilter (optional) 
     * @param costCenterFilter (optional) 
     * @param costCenterDescriptionFilter (optional) 
     * @param wBSElementFilter (optional) 
     * @param assetNoFilter (optional) 
     * @param fundCenterFilter (optional) 
     * @param maxCreatedDateFilter (optional) 
     * @param minCreatedDateFilter (optional) 
     * @param maxUpdatedDateFilter (optional) 
     * @param minUpdatedDateFilter (optional) 
     * @param documentIdFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | undefined, purchasingDocumentFilter: string | undefined, purchasingDocTypeFilter: string | undefined, purchasingDocTypeDescriptionFilter: string | undefined, itemFilter: string | undefined, lineNumberFilter: string | undefined, deletionIndicatorFilter: string | undefined, maxDocumentDateFilter: DateTime | undefined, minDocumentDateFilter: DateTime | undefined, maxCreatedOnFilter: DateTime | undefined, minCreatedOnFilter: DateTime | undefined, purchaseRequisitionFilter: string | undefined, itemPRFilter: string | undefined, supplierCodeFilter: string | undefined, supplierNameFilter: string | undefined, addressFilter: string | undefined, itemNoFilter: string | undefined, materialGroupFilter: string | undefined, shortTextFilter: string | undefined, maxOrderQuantityFilter: number | undefined, minOrderQuantityFilter: number | undefined, orderUnitFilter: string | undefined, currencyFilter: string | undefined, maxDeliveryDateFilter: DateTime | undefined, minDeliveryDateFilter: DateTime | undefined, maxNetPriceFilter: number | undefined, minNetPriceFilter: number | undefined, maxNetOrderValueFilter: number | undefined, minNetOrderValueFilter: number | undefined, maxDemurrageFilter: number | undefined, minDemurrageFilter: number | undefined, maxGrossPriceFilter: number | undefined, minGrossPriceFilter: number | undefined, maxTotalDiscountFilter: number | undefined, minTotalDiscountFilter: number | undefined, maxFreightCostFilter: number | undefined, minFreightCostFilter: number | undefined, releaseIndicatorFilter: string | undefined, plantFilter: string | undefined, purchasingGroupFilter: string | undefined, taxCodeFilter: string | undefined, collectiveNumberFilter: string | undefined, itemCategoryFilter: string | undefined, accountAssignmentFilter: string | undefined, outlineAgreementFilter: string | undefined, rFQNoFilter: string | undefined, maxQtyPendingFilter: number | undefined, minQtyPendingFilter: number | undefined, materialServiceFilter: string | undefined, approvalStatusFilter: string | undefined, pOStatusFilter: string | undefined, periodFilter: string | undefined, commentVendorFilter: string | undefined, itemTextFilter: string | undefined, longTextFilter: string | undefined, ourReferenceFilter: string | undefined, maxPRFinalFirstApprovalDateFilter: DateTime | undefined, minPRFinalFirstApprovalDateFilter: DateTime | undefined, maxPRFinalLastApprovalDateFilter: DateTime | undefined, minPRFinalLastApprovalDateFilter: DateTime | undefined, maxPOFirstApprovalDateFilter: DateTime | undefined, minPOFirstApprovalDateFilter: DateTime | undefined, maxPOLastApprovalDateFilter: DateTime | undefined, minPOLastApprovalDateFilter: DateTime | undefined, pOApprovalNameFilter: string | undefined, buyerCodeFilter: string | undefined, buyerNameFilter: string | undefined, pICDeptFilter: string | undefined, pICSectFilter: string | undefined, fuelAllocationFilter: string | undefined, costCenterFilter: string | undefined, costCenterDescriptionFilter: string | undefined, wBSElementFilter: string | undefined, assetNoFilter: string | undefined, fundCenterFilter: string | undefined, maxCreatedDateFilter: DateTime | undefined, minCreatedDateFilter: DateTime | undefined, maxUpdatedDateFilter: DateTime | undefined, minUpdatedDateFilter: DateTime | undefined, documentIdFilter: string | undefined, sorting: string | undefined, skipCount: number | undefined, maxResultCount: number | undefined): Observable<PagedResultDtoOfGetZMM021RForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ZMM021R/GetAll?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (purchasingDocumentFilter === null)
            throw new Error("The parameter 'purchasingDocumentFilter' cannot be null.");
        else if (purchasingDocumentFilter !== undefined)
            url_ += "PurchasingDocumentFilter=" + encodeURIComponent("" + purchasingDocumentFilter) + "&";
        if (purchasingDocTypeFilter === null)
            throw new Error("The parameter 'purchasingDocTypeFilter' cannot be null.");
        else if (purchasingDocTypeFilter !== undefined)
            url_ += "PurchasingDocTypeFilter=" + encodeURIComponent("" + purchasingDocTypeFilter) + "&";
        if (purchasingDocTypeDescriptionFilter === null)
            throw new Error("The parameter 'purchasingDocTypeDescriptionFilter' cannot be null.");
        else if (purchasingDocTypeDescriptionFilter !== undefined)
            url_ += "PurchasingDocTypeDescriptionFilter=" + encodeURIComponent("" + purchasingDocTypeDescriptionFilter) + "&";
        if (itemFilter === null)
            throw new Error("The parameter 'itemFilter' cannot be null.");
        else if (itemFilter !== undefined)
            url_ += "ItemFilter=" + encodeURIComponent("" + itemFilter) + "&";
        if (lineNumberFilter === null)
            throw new Error("The parameter 'lineNumberFilter' cannot be null.");
        else if (lineNumberFilter !== undefined)
            url_ += "LineNumberFilter=" + encodeURIComponent("" + lineNumberFilter) + "&";
        if (deletionIndicatorFilter === null)
            throw new Error("The parameter 'deletionIndicatorFilter' cannot be null.");
        else if (deletionIndicatorFilter !== undefined)
            url_ += "DeletionIndicatorFilter=" + encodeURIComponent("" + deletionIndicatorFilter) + "&";
        if (maxDocumentDateFilter === null)
            throw new Error("The parameter 'maxDocumentDateFilter' cannot be null.");
        else if (maxDocumentDateFilter !== undefined)
            url_ += "MaxDocumentDateFilter=" + encodeURIComponent(maxDocumentDateFilter ? "" + maxDocumentDateFilter.toString() : "") + "&";
        if (minDocumentDateFilter === null)
            throw new Error("The parameter 'minDocumentDateFilter' cannot be null.");
        else if (minDocumentDateFilter !== undefined)
            url_ += "MinDocumentDateFilter=" + encodeURIComponent(minDocumentDateFilter ? "" + minDocumentDateFilter.toString() : "") + "&";
        if (maxCreatedOnFilter === null)
            throw new Error("The parameter 'maxCreatedOnFilter' cannot be null.");
        else if (maxCreatedOnFilter !== undefined)
            url_ += "MaxCreatedOnFilter=" + encodeURIComponent(maxCreatedOnFilter ? "" + maxCreatedOnFilter.toString() : "") + "&";
        if (minCreatedOnFilter === null)
            throw new Error("The parameter 'minCreatedOnFilter' cannot be null.");
        else if (minCreatedOnFilter !== undefined)
            url_ += "MinCreatedOnFilter=" + encodeURIComponent(minCreatedOnFilter ? "" + minCreatedOnFilter.toString() : "") + "&";
        if (purchaseRequisitionFilter === null)
            throw new Error("The parameter 'purchaseRequisitionFilter' cannot be null.");
        else if (purchaseRequisitionFilter !== undefined)
            url_ += "PurchaseRequisitionFilter=" + encodeURIComponent("" + purchaseRequisitionFilter) + "&";
        if (itemPRFilter === null)
            throw new Error("The parameter 'itemPRFilter' cannot be null.");
        else if (itemPRFilter !== undefined)
            url_ += "ItemPRFilter=" + encodeURIComponent("" + itemPRFilter) + "&";
        if (supplierCodeFilter === null)
            throw new Error("The parameter 'supplierCodeFilter' cannot be null.");
        else if (supplierCodeFilter !== undefined)
            url_ += "SupplierCodeFilter=" + encodeURIComponent("" + supplierCodeFilter) + "&";
        if (supplierNameFilter === null)
            throw new Error("The parameter 'supplierNameFilter' cannot be null.");
        else if (supplierNameFilter !== undefined)
            url_ += "SupplierNameFilter=" + encodeURIComponent("" + supplierNameFilter) + "&";
        if (addressFilter === null)
            throw new Error("The parameter 'addressFilter' cannot be null.");
        else if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&";
        if (itemNoFilter === null)
            throw new Error("The parameter 'itemNoFilter' cannot be null.");
        else if (itemNoFilter !== undefined)
            url_ += "ItemNoFilter=" + encodeURIComponent("" + itemNoFilter) + "&";
        if (materialGroupFilter === null)
            throw new Error("The parameter 'materialGroupFilter' cannot be null.");
        else if (materialGroupFilter !== undefined)
            url_ += "MaterialGroupFilter=" + encodeURIComponent("" + materialGroupFilter) + "&";
        if (shortTextFilter === null)
            throw new Error("The parameter 'shortTextFilter' cannot be null.");
        else if (shortTextFilter !== undefined)
            url_ += "ShortTextFilter=" + encodeURIComponent("" + shortTextFilter) + "&";
        if (maxOrderQuantityFilter === null)
            throw new Error("The parameter 'maxOrderQuantityFilter' cannot be null.");
        else if (maxOrderQuantityFilter !== undefined)
            url_ += "MaxOrderQuantityFilter=" + encodeURIComponent("" + maxOrderQuantityFilter) + "&";
        if (minOrderQuantityFilter === null)
            throw new Error("The parameter 'minOrderQuantityFilter' cannot be null.");
        else if (minOrderQuantityFilter !== undefined)
            url_ += "MinOrderQuantityFilter=" + encodeURIComponent("" + minOrderQuantityFilter) + "&";
        if (orderUnitFilter === null)
            throw new Error("The parameter 'orderUnitFilter' cannot be null.");
        else if (orderUnitFilter !== undefined)
            url_ += "OrderUnitFilter=" + encodeURIComponent("" + orderUnitFilter) + "&";
        if (currencyFilter === null)
            throw new Error("The parameter 'currencyFilter' cannot be null.");
        else if (currencyFilter !== undefined)
            url_ += "CurrencyFilter=" + encodeURIComponent("" + currencyFilter) + "&";
        if (maxDeliveryDateFilter === null)
            throw new Error("The parameter 'maxDeliveryDateFilter' cannot be null.");
        else if (maxDeliveryDateFilter !== undefined)
            url_ += "MaxDeliveryDateFilter=" + encodeURIComponent(maxDeliveryDateFilter ? "" + maxDeliveryDateFilter.toString() : "") + "&";
        if (minDeliveryDateFilter === null)
            throw new Error("The parameter 'minDeliveryDateFilter' cannot be null.");
        else if (minDeliveryDateFilter !== undefined)
            url_ += "MinDeliveryDateFilter=" + encodeURIComponent(minDeliveryDateFilter ? "" + minDeliveryDateFilter.toString() : "") + "&";
        if (maxNetPriceFilter === null)
            throw new Error("The parameter 'maxNetPriceFilter' cannot be null.");
        else if (maxNetPriceFilter !== undefined)
            url_ += "MaxNetPriceFilter=" + encodeURIComponent("" + maxNetPriceFilter) + "&";
        if (minNetPriceFilter === null)
            throw new Error("The parameter 'minNetPriceFilter' cannot be null.");
        else if (minNetPriceFilter !== undefined)
            url_ += "MinNetPriceFilter=" + encodeURIComponent("" + minNetPriceFilter) + "&";
        if (maxNetOrderValueFilter === null)
            throw new Error("The parameter 'maxNetOrderValueFilter' cannot be null.");
        else if (maxNetOrderValueFilter !== undefined)
            url_ += "MaxNetOrderValueFilter=" + encodeURIComponent("" + maxNetOrderValueFilter) + "&";
        if (minNetOrderValueFilter === null)
            throw new Error("The parameter 'minNetOrderValueFilter' cannot be null.");
        else if (minNetOrderValueFilter !== undefined)
            url_ += "MinNetOrderValueFilter=" + encodeURIComponent("" + minNetOrderValueFilter) + "&";
        if (maxDemurrageFilter === null)
            throw new Error("The parameter 'maxDemurrageFilter' cannot be null.");
        else if (maxDemurrageFilter !== undefined)
            url_ += "MaxDemurrageFilter=" + encodeURIComponent("" + maxDemurrageFilter) + "&";
        if (minDemurrageFilter === null)
            throw new Error("The parameter 'minDemurrageFilter' cannot be null.");
        else if (minDemurrageFilter !== undefined)
            url_ += "MinDemurrageFilter=" + encodeURIComponent("" + minDemurrageFilter) + "&";
        if (maxGrossPriceFilter === null)
            throw new Error("The parameter 'maxGrossPriceFilter' cannot be null.");
        else if (maxGrossPriceFilter !== undefined)
            url_ += "MaxGrossPriceFilter=" + encodeURIComponent("" + maxGrossPriceFilter) + "&";
        if (minGrossPriceFilter === null)
            throw new Error("The parameter 'minGrossPriceFilter' cannot be null.");
        else if (minGrossPriceFilter !== undefined)
            url_ += "MinGrossPriceFilter=" + encodeURIComponent("" + minGrossPriceFilter) + "&";
        if (maxTotalDiscountFilter === null)
            throw new Error("The parameter 'maxTotalDiscountFilter' cannot be null.");
        else if (maxTotalDiscountFilter !== undefined)
            url_ += "MaxTotalDiscountFilter=" + encodeURIComponent("" + maxTotalDiscountFilter) + "&";
        if (minTotalDiscountFilter === null)
            throw new Error("The parameter 'minTotalDiscountFilter' cannot be null.");
        else if (minTotalDiscountFilter !== undefined)
            url_ += "MinTotalDiscountFilter=" + encodeURIComponent("" + minTotalDiscountFilter) + "&";
        if (maxFreightCostFilter === null)
            throw new Error("The parameter 'maxFreightCostFilter' cannot be null.");
        else if (maxFreightCostFilter !== undefined)
            url_ += "MaxFreightCostFilter=" + encodeURIComponent("" + maxFreightCostFilter) + "&";
        if (minFreightCostFilter === null)
            throw new Error("The parameter 'minFreightCostFilter' cannot be null.");
        else if (minFreightCostFilter !== undefined)
            url_ += "MinFreightCostFilter=" + encodeURIComponent("" + minFreightCostFilter) + "&";
        if (releaseIndicatorFilter === null)
            throw new Error("The parameter 'releaseIndicatorFilter' cannot be null.");
        else if (releaseIndicatorFilter !== undefined)
            url_ += "ReleaseIndicatorFilter=" + encodeURIComponent("" + releaseIndicatorFilter) + "&";
        if (plantFilter === null)
            throw new Error("The parameter 'plantFilter' cannot be null.");
        else if (plantFilter !== undefined)
            url_ += "PlantFilter=" + encodeURIComponent("" + plantFilter) + "&";
        if (purchasingGroupFilter === null)
            throw new Error("The parameter 'purchasingGroupFilter' cannot be null.");
        else if (purchasingGroupFilter !== undefined)
            url_ += "PurchasingGroupFilter=" + encodeURIComponent("" + purchasingGroupFilter) + "&";
        if (taxCodeFilter === null)
            throw new Error("The parameter 'taxCodeFilter' cannot be null.");
        else if (taxCodeFilter !== undefined)
            url_ += "TaxCodeFilter=" + encodeURIComponent("" + taxCodeFilter) + "&";
        if (collectiveNumberFilter === null)
            throw new Error("The parameter 'collectiveNumberFilter' cannot be null.");
        else if (collectiveNumberFilter !== undefined)
            url_ += "CollectiveNumberFilter=" + encodeURIComponent("" + collectiveNumberFilter) + "&";
        if (itemCategoryFilter === null)
            throw new Error("The parameter 'itemCategoryFilter' cannot be null.");
        else if (itemCategoryFilter !== undefined)
            url_ += "ItemCategoryFilter=" + encodeURIComponent("" + itemCategoryFilter) + "&";
        if (accountAssignmentFilter === null)
            throw new Error("The parameter 'accountAssignmentFilter' cannot be null.");
        else if (accountAssignmentFilter !== undefined)
            url_ += "AccountAssignmentFilter=" + encodeURIComponent("" + accountAssignmentFilter) + "&";
        if (outlineAgreementFilter === null)
            throw new Error("The parameter 'outlineAgreementFilter' cannot be null.");
        else if (outlineAgreementFilter !== undefined)
            url_ += "OutlineAgreementFilter=" + encodeURIComponent("" + outlineAgreementFilter) + "&";
        if (rFQNoFilter === null)
            throw new Error("The parameter 'rFQNoFilter' cannot be null.");
        else if (rFQNoFilter !== undefined)
            url_ += "RFQNoFilter=" + encodeURIComponent("" + rFQNoFilter) + "&";
        if (maxQtyPendingFilter === null)
            throw new Error("The parameter 'maxQtyPendingFilter' cannot be null.");
        else if (maxQtyPendingFilter !== undefined)
            url_ += "MaxQtyPendingFilter=" + encodeURIComponent("" + maxQtyPendingFilter) + "&";
        if (minQtyPendingFilter === null)
            throw new Error("The parameter 'minQtyPendingFilter' cannot be null.");
        else if (minQtyPendingFilter !== undefined)
            url_ += "MinQtyPendingFilter=" + encodeURIComponent("" + minQtyPendingFilter) + "&";
        if (materialServiceFilter === null)
            throw new Error("The parameter 'materialServiceFilter' cannot be null.");
        else if (materialServiceFilter !== undefined)
            url_ += "MaterialServiceFilter=" + encodeURIComponent("" + materialServiceFilter) + "&";
        if (approvalStatusFilter === null)
            throw new Error("The parameter 'approvalStatusFilter' cannot be null.");
        else if (approvalStatusFilter !== undefined)
            url_ += "ApprovalStatusFilter=" + encodeURIComponent("" + approvalStatusFilter) + "&";
        if (pOStatusFilter === null)
            throw new Error("The parameter 'pOStatusFilter' cannot be null.");
        else if (pOStatusFilter !== undefined)
            url_ += "POStatusFilter=" + encodeURIComponent("" + pOStatusFilter) + "&";
        if (periodFilter === null)
            throw new Error("The parameter 'periodFilter' cannot be null.");
        else if (periodFilter !== undefined)
            url_ += "PeriodFilter=" + encodeURIComponent("" + periodFilter) + "&";
        if (commentVendorFilter === null)
            throw new Error("The parameter 'commentVendorFilter' cannot be null.");
        else if (commentVendorFilter !== undefined)
            url_ += "CommentVendorFilter=" + encodeURIComponent("" + commentVendorFilter) + "&";
        if (itemTextFilter === null)
            throw new Error("The parameter 'itemTextFilter' cannot be null.");
        else if (itemTextFilter !== undefined)
            url_ += "ItemTextFilter=" + encodeURIComponent("" + itemTextFilter) + "&";
        if (longTextFilter === null)
            throw new Error("The parameter 'longTextFilter' cannot be null.");
        else if (longTextFilter !== undefined)
            url_ += "LongTextFilter=" + encodeURIComponent("" + longTextFilter) + "&";
        if (ourReferenceFilter === null)
            throw new Error("The parameter 'ourReferenceFilter' cannot be null.");
        else if (ourReferenceFilter !== undefined)
            url_ += "OurReferenceFilter=" + encodeURIComponent("" + ourReferenceFilter) + "&";
        if (maxPRFinalFirstApprovalDateFilter === null)
            throw new Error("The parameter 'maxPRFinalFirstApprovalDateFilter' cannot be null.");
        else if (maxPRFinalFirstApprovalDateFilter !== undefined)
            url_ += "MaxPRFinalFirstApprovalDateFilter=" + encodeURIComponent(maxPRFinalFirstApprovalDateFilter ? "" + maxPRFinalFirstApprovalDateFilter.toString() : "") + "&";
        if (minPRFinalFirstApprovalDateFilter === null)
            throw new Error("The parameter 'minPRFinalFirstApprovalDateFilter' cannot be null.");
        else if (minPRFinalFirstApprovalDateFilter !== undefined)
            url_ += "MinPRFinalFirstApprovalDateFilter=" + encodeURIComponent(minPRFinalFirstApprovalDateFilter ? "" + minPRFinalFirstApprovalDateFilter.toString() : "") + "&";
        if (maxPRFinalLastApprovalDateFilter === null)
            throw new Error("The parameter 'maxPRFinalLastApprovalDateFilter' cannot be null.");
        else if (maxPRFinalLastApprovalDateFilter !== undefined)
            url_ += "MaxPRFinalLastApprovalDateFilter=" + encodeURIComponent(maxPRFinalLastApprovalDateFilter ? "" + maxPRFinalLastApprovalDateFilter.toString() : "") + "&";
        if (minPRFinalLastApprovalDateFilter === null)
            throw new Error("The parameter 'minPRFinalLastApprovalDateFilter' cannot be null.");
        else if (minPRFinalLastApprovalDateFilter !== undefined)
            url_ += "MinPRFinalLastApprovalDateFilter=" + encodeURIComponent(minPRFinalLastApprovalDateFilter ? "" + minPRFinalLastApprovalDateFilter.toString() : "") + "&";
        if (maxPOFirstApprovalDateFilter === null)
            throw new Error("The parameter 'maxPOFirstApprovalDateFilter' cannot be null.");
        else if (maxPOFirstApprovalDateFilter !== undefined)
            url_ += "MaxPOFirstApprovalDateFilter=" + encodeURIComponent(maxPOFirstApprovalDateFilter ? "" + maxPOFirstApprovalDateFilter.toString() : "") + "&";
        if (minPOFirstApprovalDateFilter === null)
            throw new Error("The parameter 'minPOFirstApprovalDateFilter' cannot be null.");
        else if (minPOFirstApprovalDateFilter !== undefined)
            url_ += "MinPOFirstApprovalDateFilter=" + encodeURIComponent(minPOFirstApprovalDateFilter ? "" + minPOFirstApprovalDateFilter.toString() : "") + "&";
        if (maxPOLastApprovalDateFilter === null)
            throw new Error("The parameter 'maxPOLastApprovalDateFilter' cannot be null.");
        else if (maxPOLastApprovalDateFilter !== undefined)
            url_ += "MaxPOLastApprovalDateFilter=" + encodeURIComponent(maxPOLastApprovalDateFilter ? "" + maxPOLastApprovalDateFilter.toString() : "") + "&";
        if (minPOLastApprovalDateFilter === null)
            throw new Error("The parameter 'minPOLastApprovalDateFilter' cannot be null.");
        else if (minPOLastApprovalDateFilter !== undefined)
            url_ += "MinPOLastApprovalDateFilter=" + encodeURIComponent(minPOLastApprovalDateFilter ? "" + minPOLastApprovalDateFilter.toString() : "") + "&";
        if (pOApprovalNameFilter === null)
            throw new Error("The parameter 'pOApprovalNameFilter' cannot be null.");
        else if (pOApprovalNameFilter !== undefined)
            url_ += "POApprovalNameFilter=" + encodeURIComponent("" + pOApprovalNameFilter) + "&";
        if (buyerCodeFilter === null)
            throw new Error("The parameter 'buyerCodeFilter' cannot be null.");
        else if (buyerCodeFilter !== undefined)
            url_ += "BuyerCodeFilter=" + encodeURIComponent("" + buyerCodeFilter) + "&";
        if (buyerNameFilter === null)
            throw new Error("The parameter 'buyerNameFilter' cannot be null.");
        else if (buyerNameFilter !== undefined)
            url_ += "BuyerNameFilter=" + encodeURIComponent("" + buyerNameFilter) + "&";
        if (pICDeptFilter === null)
            throw new Error("The parameter 'pICDeptFilter' cannot be null.");
        else if (pICDeptFilter !== undefined)
            url_ += "PICDeptFilter=" + encodeURIComponent("" + pICDeptFilter) + "&";
        if (pICSectFilter === null)
            throw new Error("The parameter 'pICSectFilter' cannot be null.");
        else if (pICSectFilter !== undefined)
            url_ += "PICSectFilter=" + encodeURIComponent("" + pICSectFilter) + "&";
        if (fuelAllocationFilter === null)
            throw new Error("The parameter 'fuelAllocationFilter' cannot be null.");
        else if (fuelAllocationFilter !== undefined)
            url_ += "FuelAllocationFilter=" + encodeURIComponent("" + fuelAllocationFilter) + "&";
        if (costCenterFilter === null)
            throw new Error("The parameter 'costCenterFilter' cannot be null.");
        else if (costCenterFilter !== undefined)
            url_ += "CostCenterFilter=" + encodeURIComponent("" + costCenterFilter) + "&";
        if (costCenterDescriptionFilter === null)
            throw new Error("The parameter 'costCenterDescriptionFilter' cannot be null.");
        else if (costCenterDescriptionFilter !== undefined)
            url_ += "CostCenterDescriptionFilter=" + encodeURIComponent("" + costCenterDescriptionFilter) + "&";
        if (wBSElementFilter === null)
            throw new Error("The parameter 'wBSElementFilter' cannot be null.");
        else if (wBSElementFilter !== undefined)
            url_ += "WBSElementFilter=" + encodeURIComponent("" + wBSElementFilter) + "&";
        if (assetNoFilter === null)
            throw new Error("The parameter 'assetNoFilter' cannot be null.");
        else if (assetNoFilter !== undefined)
            url_ += "AssetNoFilter=" + encodeURIComponent("" + assetNoFilter) + "&";
        if (fundCenterFilter === null)
            throw new Error("The parameter 'fundCenterFilter' cannot be null.");
        else if (fundCenterFilter !== undefined)
            url_ += "FundCenterFilter=" + encodeURIComponent("" + fundCenterFilter) + "&";
        if (maxCreatedDateFilter === null)
            throw new Error("The parameter 'maxCreatedDateFilter' cannot be null.");
        else if (maxCreatedDateFilter !== undefined)
            url_ += "MaxCreatedDateFilter=" + encodeURIComponent(maxCreatedDateFilter ? "" + maxCreatedDateFilter.toString() : "") + "&";
        if (minCreatedDateFilter === null)
            throw new Error("The parameter 'minCreatedDateFilter' cannot be null.");
        else if (minCreatedDateFilter !== undefined)
            url_ += "MinCreatedDateFilter=" + encodeURIComponent(minCreatedDateFilter ? "" + minCreatedDateFilter.toString() : "") + "&";
        if (maxUpdatedDateFilter === null)
            throw new Error("The parameter 'maxUpdatedDateFilter' cannot be null.");
        else if (maxUpdatedDateFilter !== undefined)
            url_ += "MaxUpdatedDateFilter=" + encodeURIComponent(maxUpdatedDateFilter ? "" + maxUpdatedDateFilter.toString() : "") + "&";
        if (minUpdatedDateFilter === null)
            throw new Error("The parameter 'minUpdatedDateFilter' cannot be null.");
        else if (minUpdatedDateFilter !== undefined)
            url_ += "MinUpdatedDateFilter=" + encodeURIComponent(minUpdatedDateFilter ? "" + minUpdatedDateFilter.toString() : "") + "&";
        if (documentIdFilter === null)
            throw new Error("The parameter 'documentIdFilter' cannot be null.");
        else if (documentIdFilter !== undefined)
            url_ += "DocumentIdFilter=" + encodeURIComponent("" + documentIdFilter) + "&";
        if (sorting === null)
            throw new Error("The parameter 'sorting' cannot be null.");
        else if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&";
        if (skipCount === null)
            throw new Error("The parameter 'skipCount' cannot be null.");
        else if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&";
        if (maxResultCount === null)
            throw new Error("The parameter 'maxResultCount' cannot be null.");
        else if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PagedResultDtoOfGetZMM021RForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PagedResultDtoOfGetZMM021RForViewDto>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetZMM021RForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetZMM021RForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getZMM021RForView(id: string | undefined): Observable<GetZMM021RForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ZMM021R/GetZMM021RForView?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZMM021RForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZMM021RForView(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetZMM021RForViewDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetZMM021RForViewDto>;
        }));
    }

    protected processGetZMM021RForView(response: HttpResponseBase): Observable<GetZMM021RForViewDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetZMM021RForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getZMM021RForEdit(id: string | undefined): Observable<GetZMM021RForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ZMM021R/GetZMM021RForEdit?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZMM021RForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZMM021RForEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetZMM021RForEditOutput>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetZMM021RForEditOutput>;
        }));
    }

    protected processGetZMM021RForEdit(response: HttpResponseBase): Observable<GetZMM021RForEditOutput> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetZMM021RForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createOrEdit(body: CreateOrEditZMM021RDto | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ZMM021R/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json-patch+json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: string | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ZMM021R/Delete?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param filter (optional) 
     * @param purchasingDocumentFilter (optional) 
     * @param purchasingDocTypeFilter (optional) 
     * @param purchasingDocTypeDescriptionFilter (optional) 
     * @param itemFilter (optional) 
     * @param lineNumberFilter (optional) 
     * @param deletionIndicatorFilter (optional) 
     * @param maxDocumentDateFilter (optional) 
     * @param minDocumentDateFilter (optional) 
     * @param maxCreatedOnFilter (optional) 
     * @param minCreatedOnFilter (optional) 
     * @param purchaseRequisitionFilter (optional) 
     * @param itemPRFilter (optional) 
     * @param supplierCodeFilter (optional) 
     * @param supplierNameFilter (optional) 
     * @param addressFilter (optional) 
     * @param itemNoFilter (optional) 
     * @param materialGroupFilter (optional) 
     * @param shortTextFilter (optional) 
     * @param maxOrderQuantityFilter (optional) 
     * @param minOrderQuantityFilter (optional) 
     * @param orderUnitFilter (optional) 
     * @param currencyFilter (optional) 
     * @param maxDeliveryDateFilter (optional) 
     * @param minDeliveryDateFilter (optional) 
     * @param maxNetPriceFilter (optional) 
     * @param minNetPriceFilter (optional) 
     * @param maxNetOrderValueFilter (optional) 
     * @param minNetOrderValueFilter (optional) 
     * @param maxDemurrageFilter (optional) 
     * @param minDemurrageFilter (optional) 
     * @param maxGrossPriceFilter (optional) 
     * @param minGrossPriceFilter (optional) 
     * @param maxTotalDiscountFilter (optional) 
     * @param minTotalDiscountFilter (optional) 
     * @param maxFreightCostFilter (optional) 
     * @param minFreightCostFilter (optional) 
     * @param releaseIndicatorFilter (optional) 
     * @param plantFilter (optional) 
     * @param purchasingGroupFilter (optional) 
     * @param taxCodeFilter (optional) 
     * @param collectiveNumberFilter (optional) 
     * @param itemCategoryFilter (optional) 
     * @param accountAssignmentFilter (optional) 
     * @param outlineAgreementFilter (optional) 
     * @param rFQNoFilter (optional) 
     * @param maxQtyPendingFilter (optional) 
     * @param minQtyPendingFilter (optional) 
     * @param materialServiceFilter (optional) 
     * @param approvalStatusFilter (optional) 
     * @param pOStatusFilter (optional) 
     * @param periodFilter (optional) 
     * @param commentVendorFilter (optional) 
     * @param itemTextFilter (optional) 
     * @param longTextFilter (optional) 
     * @param ourReferenceFilter (optional) 
     * @param maxPRFinalFirstApprovalDateFilter (optional) 
     * @param minPRFinalFirstApprovalDateFilter (optional) 
     * @param maxPRFinalLastApprovalDateFilter (optional) 
     * @param minPRFinalLastApprovalDateFilter (optional) 
     * @param maxPOFirstApprovalDateFilter (optional) 
     * @param minPOFirstApprovalDateFilter (optional) 
     * @param maxPOLastApprovalDateFilter (optional) 
     * @param minPOLastApprovalDateFilter (optional) 
     * @param pOApprovalNameFilter (optional) 
     * @param buyerCodeFilter (optional) 
     * @param buyerNameFilter (optional) 
     * @param pICDeptFilter (optional) 
     * @param pICSectFilter (optional) 
     * @param fuelAllocationFilter (optional) 
     * @param costCenterFilter (optional) 
     * @param costCenterDescriptionFilter (optional) 
     * @param wBSElementFilter (optional) 
     * @param assetNoFilter (optional) 
     * @param fundCenterFilter (optional) 
     * @param maxCreatedDateFilter (optional) 
     * @param minCreatedDateFilter (optional) 
     * @param maxUpdatedDateFilter (optional) 
     * @param minUpdatedDateFilter (optional) 
     * @param documentIdFilter (optional) 
     * @return Success
     */
    getZMM021RToExcel(filter: string | undefined, purchasingDocumentFilter: string | undefined, purchasingDocTypeFilter: string | undefined, purchasingDocTypeDescriptionFilter: string | undefined, itemFilter: string | undefined, lineNumberFilter: string | undefined, deletionIndicatorFilter: string | undefined, maxDocumentDateFilter: DateTime | undefined, minDocumentDateFilter: DateTime | undefined, maxCreatedOnFilter: DateTime | undefined, minCreatedOnFilter: DateTime | undefined, purchaseRequisitionFilter: string | undefined, itemPRFilter: string | undefined, supplierCodeFilter: string | undefined, supplierNameFilter: string | undefined, addressFilter: string | undefined, itemNoFilter: string | undefined, materialGroupFilter: string | undefined, shortTextFilter: string | undefined, maxOrderQuantityFilter: number | undefined, minOrderQuantityFilter: number | undefined, orderUnitFilter: string | undefined, currencyFilter: string | undefined, maxDeliveryDateFilter: DateTime | undefined, minDeliveryDateFilter: DateTime | undefined, maxNetPriceFilter: number | undefined, minNetPriceFilter: number | undefined, maxNetOrderValueFilter: number | undefined, minNetOrderValueFilter: number | undefined, maxDemurrageFilter: number | undefined, minDemurrageFilter: number | undefined, maxGrossPriceFilter: number | undefined, minGrossPriceFilter: number | undefined, maxTotalDiscountFilter: number | undefined, minTotalDiscountFilter: number | undefined, maxFreightCostFilter: number | undefined, minFreightCostFilter: number | undefined, releaseIndicatorFilter: string | undefined, plantFilter: string | undefined, purchasingGroupFilter: string | undefined, taxCodeFilter: string | undefined, collectiveNumberFilter: string | undefined, itemCategoryFilter: string | undefined, accountAssignmentFilter: string | undefined, outlineAgreementFilter: string | undefined, rFQNoFilter: string | undefined, maxQtyPendingFilter: number | undefined, minQtyPendingFilter: number | undefined, materialServiceFilter: string | undefined, approvalStatusFilter: string | undefined, pOStatusFilter: string | undefined, periodFilter: string | undefined, commentVendorFilter: string | undefined, itemTextFilter: string | undefined, longTextFilter: string | undefined, ourReferenceFilter: string | undefined, maxPRFinalFirstApprovalDateFilter: DateTime | undefined, minPRFinalFirstApprovalDateFilter: DateTime | undefined, maxPRFinalLastApprovalDateFilter: DateTime | undefined, minPRFinalLastApprovalDateFilter: DateTime | undefined, maxPOFirstApprovalDateFilter: DateTime | undefined, minPOFirstApprovalDateFilter: DateTime | undefined, maxPOLastApprovalDateFilter: DateTime | undefined, minPOLastApprovalDateFilter: DateTime | undefined, pOApprovalNameFilter: string | undefined, buyerCodeFilter: string | undefined, buyerNameFilter: string | undefined, pICDeptFilter: string | undefined, pICSectFilter: string | undefined, fuelAllocationFilter: string | undefined, costCenterFilter: string | undefined, costCenterDescriptionFilter: string | undefined, wBSElementFilter: string | undefined, assetNoFilter: string | undefined, fundCenterFilter: string | undefined, maxCreatedDateFilter: DateTime | undefined, minCreatedDateFilter: DateTime | undefined, maxUpdatedDateFilter: DateTime | undefined, minUpdatedDateFilter: DateTime | undefined, documentIdFilter: string | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/ZMM021R/GetZMM021RToExcel?";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (purchasingDocumentFilter === null)
            throw new Error("The parameter 'purchasingDocumentFilter' cannot be null.");
        else if (purchasingDocumentFilter !== undefined)
            url_ += "PurchasingDocumentFilter=" + encodeURIComponent("" + purchasingDocumentFilter) + "&";
        if (purchasingDocTypeFilter === null)
            throw new Error("The parameter 'purchasingDocTypeFilter' cannot be null.");
        else if (purchasingDocTypeFilter !== undefined)
            url_ += "PurchasingDocTypeFilter=" + encodeURIComponent("" + purchasingDocTypeFilter) + "&";
        if (purchasingDocTypeDescriptionFilter === null)
            throw new Error("The parameter 'purchasingDocTypeDescriptionFilter' cannot be null.");
        else if (purchasingDocTypeDescriptionFilter !== undefined)
            url_ += "PurchasingDocTypeDescriptionFilter=" + encodeURIComponent("" + purchasingDocTypeDescriptionFilter) + "&";
        if (itemFilter === null)
            throw new Error("The parameter 'itemFilter' cannot be null.");
        else if (itemFilter !== undefined)
            url_ += "ItemFilter=" + encodeURIComponent("" + itemFilter) + "&";
        if (lineNumberFilter === null)
            throw new Error("The parameter 'lineNumberFilter' cannot be null.");
        else if (lineNumberFilter !== undefined)
            url_ += "LineNumberFilter=" + encodeURIComponent("" + lineNumberFilter) + "&";
        if (deletionIndicatorFilter === null)
            throw new Error("The parameter 'deletionIndicatorFilter' cannot be null.");
        else if (deletionIndicatorFilter !== undefined)
            url_ += "DeletionIndicatorFilter=" + encodeURIComponent("" + deletionIndicatorFilter) + "&";
        if (maxDocumentDateFilter === null)
            throw new Error("The parameter 'maxDocumentDateFilter' cannot be null.");
        else if (maxDocumentDateFilter !== undefined)
            url_ += "MaxDocumentDateFilter=" + encodeURIComponent(maxDocumentDateFilter ? "" + maxDocumentDateFilter.toString() : "") + "&";
        if (minDocumentDateFilter === null)
            throw new Error("The parameter 'minDocumentDateFilter' cannot be null.");
        else if (minDocumentDateFilter !== undefined)
            url_ += "MinDocumentDateFilter=" + encodeURIComponent(minDocumentDateFilter ? "" + minDocumentDateFilter.toString() : "") + "&";
        if (maxCreatedOnFilter === null)
            throw new Error("The parameter 'maxCreatedOnFilter' cannot be null.");
        else if (maxCreatedOnFilter !== undefined)
            url_ += "MaxCreatedOnFilter=" + encodeURIComponent(maxCreatedOnFilter ? "" + maxCreatedOnFilter.toString() : "") + "&";
        if (minCreatedOnFilter === null)
            throw new Error("The parameter 'minCreatedOnFilter' cannot be null.");
        else if (minCreatedOnFilter !== undefined)
            url_ += "MinCreatedOnFilter=" + encodeURIComponent(minCreatedOnFilter ? "" + minCreatedOnFilter.toString() : "") + "&";
        if (purchaseRequisitionFilter === null)
            throw new Error("The parameter 'purchaseRequisitionFilter' cannot be null.");
        else if (purchaseRequisitionFilter !== undefined)
            url_ += "PurchaseRequisitionFilter=" + encodeURIComponent("" + purchaseRequisitionFilter) + "&";
        if (itemPRFilter === null)
            throw new Error("The parameter 'itemPRFilter' cannot be null.");
        else if (itemPRFilter !== undefined)
            url_ += "ItemPRFilter=" + encodeURIComponent("" + itemPRFilter) + "&";
        if (supplierCodeFilter === null)
            throw new Error("The parameter 'supplierCodeFilter' cannot be null.");
        else if (supplierCodeFilter !== undefined)
            url_ += "SupplierCodeFilter=" + encodeURIComponent("" + supplierCodeFilter) + "&";
        if (supplierNameFilter === null)
            throw new Error("The parameter 'supplierNameFilter' cannot be null.");
        else if (supplierNameFilter !== undefined)
            url_ += "SupplierNameFilter=" + encodeURIComponent("" + supplierNameFilter) + "&";
        if (addressFilter === null)
            throw new Error("The parameter 'addressFilter' cannot be null.");
        else if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&";
        if (itemNoFilter === null)
            throw new Error("The parameter 'itemNoFilter' cannot be null.");
        else if (itemNoFilter !== undefined)
            url_ += "ItemNoFilter=" + encodeURIComponent("" + itemNoFilter) + "&";
        if (materialGroupFilter === null)
            throw new Error("The parameter 'materialGroupFilter' cannot be null.");
        else if (materialGroupFilter !== undefined)
            url_ += "MaterialGroupFilter=" + encodeURIComponent("" + materialGroupFilter) + "&";
        if (shortTextFilter === null)
            throw new Error("The parameter 'shortTextFilter' cannot be null.");
        else if (shortTextFilter !== undefined)
            url_ += "ShortTextFilter=" + encodeURIComponent("" + shortTextFilter) + "&";
        if (maxOrderQuantityFilter === null)
            throw new Error("The parameter 'maxOrderQuantityFilter' cannot be null.");
        else if (maxOrderQuantityFilter !== undefined)
            url_ += "MaxOrderQuantityFilter=" + encodeURIComponent("" + maxOrderQuantityFilter) + "&";
        if (minOrderQuantityFilter === null)
            throw new Error("The parameter 'minOrderQuantityFilter' cannot be null.");
        else if (minOrderQuantityFilter !== undefined)
            url_ += "MinOrderQuantityFilter=" + encodeURIComponent("" + minOrderQuantityFilter) + "&";
        if (orderUnitFilter === null)
            throw new Error("The parameter 'orderUnitFilter' cannot be null.");
        else if (orderUnitFilter !== undefined)
            url_ += "OrderUnitFilter=" + encodeURIComponent("" + orderUnitFilter) + "&";
        if (currencyFilter === null)
            throw new Error("The parameter 'currencyFilter' cannot be null.");
        else if (currencyFilter !== undefined)
            url_ += "CurrencyFilter=" + encodeURIComponent("" + currencyFilter) + "&";
        if (maxDeliveryDateFilter === null)
            throw new Error("The parameter 'maxDeliveryDateFilter' cannot be null.");
        else if (maxDeliveryDateFilter !== undefined)
            url_ += "MaxDeliveryDateFilter=" + encodeURIComponent(maxDeliveryDateFilter ? "" + maxDeliveryDateFilter.toString() : "") + "&";
        if (minDeliveryDateFilter === null)
            throw new Error("The parameter 'minDeliveryDateFilter' cannot be null.");
        else if (minDeliveryDateFilter !== undefined)
            url_ += "MinDeliveryDateFilter=" + encodeURIComponent(minDeliveryDateFilter ? "" + minDeliveryDateFilter.toString() : "") + "&";
        if (maxNetPriceFilter === null)
            throw new Error("The parameter 'maxNetPriceFilter' cannot be null.");
        else if (maxNetPriceFilter !== undefined)
            url_ += "MaxNetPriceFilter=" + encodeURIComponent("" + maxNetPriceFilter) + "&";
        if (minNetPriceFilter === null)
            throw new Error("The parameter 'minNetPriceFilter' cannot be null.");
        else if (minNetPriceFilter !== undefined)
            url_ += "MinNetPriceFilter=" + encodeURIComponent("" + minNetPriceFilter) + "&";
        if (maxNetOrderValueFilter === null)
            throw new Error("The parameter 'maxNetOrderValueFilter' cannot be null.");
        else if (maxNetOrderValueFilter !== undefined)
            url_ += "MaxNetOrderValueFilter=" + encodeURIComponent("" + maxNetOrderValueFilter) + "&";
        if (minNetOrderValueFilter === null)
            throw new Error("The parameter 'minNetOrderValueFilter' cannot be null.");
        else if (minNetOrderValueFilter !== undefined)
            url_ += "MinNetOrderValueFilter=" + encodeURIComponent("" + minNetOrderValueFilter) + "&";
        if (maxDemurrageFilter === null)
            throw new Error("The parameter 'maxDemurrageFilter' cannot be null.");
        else if (maxDemurrageFilter !== undefined)
            url_ += "MaxDemurrageFilter=" + encodeURIComponent("" + maxDemurrageFilter) + "&";
        if (minDemurrageFilter === null)
            throw new Error("The parameter 'minDemurrageFilter' cannot be null.");
        else if (minDemurrageFilter !== undefined)
            url_ += "MinDemurrageFilter=" + encodeURIComponent("" + minDemurrageFilter) + "&";
        if (maxGrossPriceFilter === null)
            throw new Error("The parameter 'maxGrossPriceFilter' cannot be null.");
        else if (maxGrossPriceFilter !== undefined)
            url_ += "MaxGrossPriceFilter=" + encodeURIComponent("" + maxGrossPriceFilter) + "&";
        if (minGrossPriceFilter === null)
            throw new Error("The parameter 'minGrossPriceFilter' cannot be null.");
        else if (minGrossPriceFilter !== undefined)
            url_ += "MinGrossPriceFilter=" + encodeURIComponent("" + minGrossPriceFilter) + "&";
        if (maxTotalDiscountFilter === null)
            throw new Error("The parameter 'maxTotalDiscountFilter' cannot be null.");
        else if (maxTotalDiscountFilter !== undefined)
            url_ += "MaxTotalDiscountFilter=" + encodeURIComponent("" + maxTotalDiscountFilter) + "&";
        if (minTotalDiscountFilter === null)
            throw new Error("The parameter 'minTotalDiscountFilter' cannot be null.");
        else if (minTotalDiscountFilter !== undefined)
            url_ += "MinTotalDiscountFilter=" + encodeURIComponent("" + minTotalDiscountFilter) + "&";
        if (maxFreightCostFilter === null)
            throw new Error("The parameter 'maxFreightCostFilter' cannot be null.");
        else if (maxFreightCostFilter !== undefined)
            url_ += "MaxFreightCostFilter=" + encodeURIComponent("" + maxFreightCostFilter) + "&";
        if (minFreightCostFilter === null)
            throw new Error("The parameter 'minFreightCostFilter' cannot be null.");
        else if (minFreightCostFilter !== undefined)
            url_ += "MinFreightCostFilter=" + encodeURIComponent("" + minFreightCostFilter) + "&";
        if (releaseIndicatorFilter === null)
            throw new Error("The parameter 'releaseIndicatorFilter' cannot be null.");
        else if (releaseIndicatorFilter !== undefined)
            url_ += "ReleaseIndicatorFilter=" + encodeURIComponent("" + releaseIndicatorFilter) + "&";
        if (plantFilter === null)
            throw new Error("The parameter 'plantFilter' cannot be null.");
        else if (plantFilter !== undefined)
            url_ += "PlantFilter=" + encodeURIComponent("" + plantFilter) + "&";
        if (purchasingGroupFilter === null)
            throw new Error("The parameter 'purchasingGroupFilter' cannot be null.");
        else if (purchasingGroupFilter !== undefined)
            url_ += "PurchasingGroupFilter=" + encodeURIComponent("" + purchasingGroupFilter) + "&";
        if (taxCodeFilter === null)
            throw new Error("The parameter 'taxCodeFilter' cannot be null.");
        else if (taxCodeFilter !== undefined)
            url_ += "TaxCodeFilter=" + encodeURIComponent("" + taxCodeFilter) + "&";
        if (collectiveNumberFilter === null)
            throw new Error("The parameter 'collectiveNumberFilter' cannot be null.");
        else if (collectiveNumberFilter !== undefined)
            url_ += "CollectiveNumberFilter=" + encodeURIComponent("" + collectiveNumberFilter) + "&";
        if (itemCategoryFilter === null)
            throw new Error("The parameter 'itemCategoryFilter' cannot be null.");
        else if (itemCategoryFilter !== undefined)
            url_ += "ItemCategoryFilter=" + encodeURIComponent("" + itemCategoryFilter) + "&";
        if (accountAssignmentFilter === null)
            throw new Error("The parameter 'accountAssignmentFilter' cannot be null.");
        else if (accountAssignmentFilter !== undefined)
            url_ += "AccountAssignmentFilter=" + encodeURIComponent("" + accountAssignmentFilter) + "&";
        if (outlineAgreementFilter === null)
            throw new Error("The parameter 'outlineAgreementFilter' cannot be null.");
        else if (outlineAgreementFilter !== undefined)
            url_ += "OutlineAgreementFilter=" + encodeURIComponent("" + outlineAgreementFilter) + "&";
        if (rFQNoFilter === null)
            throw new Error("The parameter 'rFQNoFilter' cannot be null.");
        else if (rFQNoFilter !== undefined)
            url_ += "RFQNoFilter=" + encodeURIComponent("" + rFQNoFilter) + "&";
        if (maxQtyPendingFilter === null)
            throw new Error("The parameter 'maxQtyPendingFilter' cannot be null.");
        else if (maxQtyPendingFilter !== undefined)
            url_ += "MaxQtyPendingFilter=" + encodeURIComponent("" + maxQtyPendingFilter) + "&";
        if (minQtyPendingFilter === null)
            throw new Error("The parameter 'minQtyPendingFilter' cannot be null.");
        else if (minQtyPendingFilter !== undefined)
            url_ += "MinQtyPendingFilter=" + encodeURIComponent("" + minQtyPendingFilter) + "&";
        if (materialServiceFilter === null)
            throw new Error("The parameter 'materialServiceFilter' cannot be null.");
        else if (materialServiceFilter !== undefined)
            url_ += "MaterialServiceFilter=" + encodeURIComponent("" + materialServiceFilter) + "&";
        if (approvalStatusFilter === null)
            throw new Error("The parameter 'approvalStatusFilter' cannot be null.");
        else if (approvalStatusFilter !== undefined)
            url_ += "ApprovalStatusFilter=" + encodeURIComponent("" + approvalStatusFilter) + "&";
        if (pOStatusFilter === null)
            throw new Error("The parameter 'pOStatusFilter' cannot be null.");
        else if (pOStatusFilter !== undefined)
            url_ += "POStatusFilter=" + encodeURIComponent("" + pOStatusFilter) + "&";
        if (periodFilter === null)
            throw new Error("The parameter 'periodFilter' cannot be null.");
        else if (periodFilter !== undefined)
            url_ += "PeriodFilter=" + encodeURIComponent("" + periodFilter) + "&";
        if (commentVendorFilter === null)
            throw new Error("The parameter 'commentVendorFilter' cannot be null.");
        else if (commentVendorFilter !== undefined)
            url_ += "CommentVendorFilter=" + encodeURIComponent("" + commentVendorFilter) + "&";
        if (itemTextFilter === null)
            throw new Error("The parameter 'itemTextFilter' cannot be null.");
        else if (itemTextFilter !== undefined)
            url_ += "ItemTextFilter=" + encodeURIComponent("" + itemTextFilter) + "&";
        if (longTextFilter === null)
            throw new Error("The parameter 'longTextFilter' cannot be null.");
        else if (longTextFilter !== undefined)
            url_ += "LongTextFilter=" + encodeURIComponent("" + longTextFilter) + "&";
        if (ourReferenceFilter === null)
            throw new Error("The parameter 'ourReferenceFilter' cannot be null.");
        else if (ourReferenceFilter !== undefined)
            url_ += "OurReferenceFilter=" + encodeURIComponent("" + ourReferenceFilter) + "&";
        if (maxPRFinalFirstApprovalDateFilter === null)
            throw new Error("The parameter 'maxPRFinalFirstApprovalDateFilter' cannot be null.");
        else if (maxPRFinalFirstApprovalDateFilter !== undefined)
            url_ += "MaxPRFinalFirstApprovalDateFilter=" + encodeURIComponent(maxPRFinalFirstApprovalDateFilter ? "" + maxPRFinalFirstApprovalDateFilter.toString() : "") + "&";
        if (minPRFinalFirstApprovalDateFilter === null)
            throw new Error("The parameter 'minPRFinalFirstApprovalDateFilter' cannot be null.");
        else if (minPRFinalFirstApprovalDateFilter !== undefined)
            url_ += "MinPRFinalFirstApprovalDateFilter=" + encodeURIComponent(minPRFinalFirstApprovalDateFilter ? "" + minPRFinalFirstApprovalDateFilter.toString() : "") + "&";
        if (maxPRFinalLastApprovalDateFilter === null)
            throw new Error("The parameter 'maxPRFinalLastApprovalDateFilter' cannot be null.");
        else if (maxPRFinalLastApprovalDateFilter !== undefined)
            url_ += "MaxPRFinalLastApprovalDateFilter=" + encodeURIComponent(maxPRFinalLastApprovalDateFilter ? "" + maxPRFinalLastApprovalDateFilter.toString() : "") + "&";
        if (minPRFinalLastApprovalDateFilter === null)
            throw new Error("The parameter 'minPRFinalLastApprovalDateFilter' cannot be null.");
        else if (minPRFinalLastApprovalDateFilter !== undefined)
            url_ += "MinPRFinalLastApprovalDateFilter=" + encodeURIComponent(minPRFinalLastApprovalDateFilter ? "" + minPRFinalLastApprovalDateFilter.toString() : "") + "&";
        if (maxPOFirstApprovalDateFilter === null)
            throw new Error("The parameter 'maxPOFirstApprovalDateFilter' cannot be null.");
        else if (maxPOFirstApprovalDateFilter !== undefined)
            url_ += "MaxPOFirstApprovalDateFilter=" + encodeURIComponent(maxPOFirstApprovalDateFilter ? "" + maxPOFirstApprovalDateFilter.toString() : "") + "&";
        if (minPOFirstApprovalDateFilter === null)
            throw new Error("The parameter 'minPOFirstApprovalDateFilter' cannot be null.");
        else if (minPOFirstApprovalDateFilter !== undefined)
            url_ += "MinPOFirstApprovalDateFilter=" + encodeURIComponent(minPOFirstApprovalDateFilter ? "" + minPOFirstApprovalDateFilter.toString() : "") + "&";
        if (maxPOLastApprovalDateFilter === null)
            throw new Error("The parameter 'maxPOLastApprovalDateFilter' cannot be null.");
        else if (maxPOLastApprovalDateFilter !== undefined)
            url_ += "MaxPOLastApprovalDateFilter=" + encodeURIComponent(maxPOLastApprovalDateFilter ? "" + maxPOLastApprovalDateFilter.toString() : "") + "&";
        if (minPOLastApprovalDateFilter === null)
            throw new Error("The parameter 'minPOLastApprovalDateFilter' cannot be null.");
        else if (minPOLastApprovalDateFilter !== undefined)
            url_ += "MinPOLastApprovalDateFilter=" + encodeURIComponent(minPOLastApprovalDateFilter ? "" + minPOLastApprovalDateFilter.toString() : "") + "&";
        if (pOApprovalNameFilter === null)
            throw new Error("The parameter 'pOApprovalNameFilter' cannot be null.");
        else if (pOApprovalNameFilter !== undefined)
            url_ += "POApprovalNameFilter=" + encodeURIComponent("" + pOApprovalNameFilter) + "&";
        if (buyerCodeFilter === null)
            throw new Error("The parameter 'buyerCodeFilter' cannot be null.");
        else if (buyerCodeFilter !== undefined)
            url_ += "BuyerCodeFilter=" + encodeURIComponent("" + buyerCodeFilter) + "&";
        if (buyerNameFilter === null)
            throw new Error("The parameter 'buyerNameFilter' cannot be null.");
        else if (buyerNameFilter !== undefined)
            url_ += "BuyerNameFilter=" + encodeURIComponent("" + buyerNameFilter) + "&";
        if (pICDeptFilter === null)
            throw new Error("The parameter 'pICDeptFilter' cannot be null.");
        else if (pICDeptFilter !== undefined)
            url_ += "PICDeptFilter=" + encodeURIComponent("" + pICDeptFilter) + "&";
        if (pICSectFilter === null)
            throw new Error("The parameter 'pICSectFilter' cannot be null.");
        else if (pICSectFilter !== undefined)
            url_ += "PICSectFilter=" + encodeURIComponent("" + pICSectFilter) + "&";
        if (fuelAllocationFilter === null)
            throw new Error("The parameter 'fuelAllocationFilter' cannot be null.");
        else if (fuelAllocationFilter !== undefined)
            url_ += "FuelAllocationFilter=" + encodeURIComponent("" + fuelAllocationFilter) + "&";
        if (costCenterFilter === null)
            throw new Error("The parameter 'costCenterFilter' cannot be null.");
        else if (costCenterFilter !== undefined)
            url_ += "CostCenterFilter=" + encodeURIComponent("" + costCenterFilter) + "&";
        if (costCenterDescriptionFilter === null)
            throw new Error("The parameter 'costCenterDescriptionFilter' cannot be null.");
        else if (costCenterDescriptionFilter !== undefined)
            url_ += "CostCenterDescriptionFilter=" + encodeURIComponent("" + costCenterDescriptionFilter) + "&";
        if (wBSElementFilter === null)
            throw new Error("The parameter 'wBSElementFilter' cannot be null.");
        else if (wBSElementFilter !== undefined)
            url_ += "WBSElementFilter=" + encodeURIComponent("" + wBSElementFilter) + "&";
        if (assetNoFilter === null)
            throw new Error("The parameter 'assetNoFilter' cannot be null.");
        else if (assetNoFilter !== undefined)
            url_ += "AssetNoFilter=" + encodeURIComponent("" + assetNoFilter) + "&";
        if (fundCenterFilter === null)
            throw new Error("The parameter 'fundCenterFilter' cannot be null.");
        else if (fundCenterFilter !== undefined)
            url_ += "FundCenterFilter=" + encodeURIComponent("" + fundCenterFilter) + "&";
        if (maxCreatedDateFilter === null)
            throw new Error("The parameter 'maxCreatedDateFilter' cannot be null.");
        else if (maxCreatedDateFilter !== undefined)
            url_ += "MaxCreatedDateFilter=" + encodeURIComponent(maxCreatedDateFilter ? "" + maxCreatedDateFilter.toString() : "") + "&";
        if (minCreatedDateFilter === null)
            throw new Error("The parameter 'minCreatedDateFilter' cannot be null.");
        else if (minCreatedDateFilter !== undefined)
            url_ += "MinCreatedDateFilter=" + encodeURIComponent(minCreatedDateFilter ? "" + minCreatedDateFilter.toString() : "") + "&";
        if (maxUpdatedDateFilter === null)
            throw new Error("The parameter 'maxUpdatedDateFilter' cannot be null.");
        else if (maxUpdatedDateFilter !== undefined)
            url_ += "MaxUpdatedDateFilter=" + encodeURIComponent(maxUpdatedDateFilter ? "" + maxUpdatedDateFilter.toString() : "") + "&";
        if (minUpdatedDateFilter === null)
            throw new Error("The parameter 'minUpdatedDateFilter' cannot be null.");
        else if (minUpdatedDateFilter !== undefined)
            url_ += "MinUpdatedDateFilter=" + encodeURIComponent(minUpdatedDateFilter ? "" + minUpdatedDateFilter.toString() : "") + "&";
        if (documentIdFilter === null)
            throw new Error("The parameter 'documentIdFilter' cannot be null.");
        else if (documentIdFilter !== undefined)
            url_ += "DocumentIdFilter=" + encodeURIComponent("" + documentIdFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetZMM021RToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetZMM021RToExcel(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileDto>;
        }));
    }

    protected processGetZMM021RToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export enum AbpLoginResultType {
    Success = 1,
    InvalidUserNameOrEmailAddress = 2,
    InvalidPassword = 3,
    UserIsNotActive = 4,
    InvalidTenancyName = 5,
    TenantIsNotActive = 6,
    UserEmailIsNotConfirmed = 7,
    UnknownExternalLogin = 8,
    LockedOut = 9,
    UserPhoneNumberIsNotConfirmed = 10,
    FailedForOtherReason = 11,
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.confirmationCode = _data["confirmationCode"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data;
    }
}

export interface IActivateEmailInput {
    userId: number;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ActivateWebhookSubscriptionInput implements IActivateWebhookSubscriptionInput {
    subscriptionId!: string;
    isActive!: boolean;

    constructor(data?: IActivateWebhookSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionId = _data["subscriptionId"];
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): ActivateWebhookSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateWebhookSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionId"] = this.subscriptionId;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IActivateWebhookSubscriptionInput {
    subscriptionId: string;
    isActive: boolean;
}

export class AddNewPageInput implements IAddNewPageInput {
    dashboardName!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IAddNewPageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddNewPageInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["name"] = this.name;
        data["application"] = this.application;
        return data;
    }
}

export interface IAddNewPageInput {
    dashboardName: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class AddNewPageOutput implements IAddNewPageOutput {
    pageId!: string | undefined;

    constructor(data?: IAddNewPageOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.pageId = _data["pageId"];
        }
    }

    static fromJS(data: any): AddNewPageOutput {
        data = typeof data === 'object' ? data : {};
        let result = new AddNewPageOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pageId"] = this.pageId;
        return data;
    }
}

export interface IAddNewPageOutput {
    pageId: string | undefined;
}

export class AddWidgetInput implements IAddWidgetInput {
    widgetId!: string | undefined;
    pageId!: string | undefined;
    dashboardName!: string | undefined;
    width!: number;
    height!: number;
    application!: string | undefined;

    constructor(data?: IAddWidgetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.pageId = _data["pageId"];
            this.dashboardName = _data["dashboardName"];
            this.width = _data["width"];
            this.height = _data["height"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): AddWidgetInput {
        data = typeof data === 'object' ? data : {};
        let result = new AddWidgetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["pageId"] = this.pageId;
        data["dashboardName"] = this.dashboardName;
        data["width"] = this.width;
        data["height"] = this.height;
        data["application"] = this.application;
        return data;
    }
}

export interface IAddWidgetInput {
    widgetId: string | undefined;
    pageId: string | undefined;
    dashboardName: string | undefined;
    width: number;
    height: number;
    application: string | undefined;
}

export class AirportDto implements IAirportDto {
    airportName!: string | undefined;
    iata!: string | undefined;
    city!: string | undefined;
    category!: string | undefined;
    id!: string;

    constructor(data?: IAirportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.airportName = _data["airportName"];
            this.iata = _data["iata"];
            this.city = _data["city"];
            this.category = _data["category"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AirportDto {
        data = typeof data === 'object' ? data : {};
        let result = new AirportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["airportName"] = this.airportName;
        data["iata"] = this.iata;
        data["city"] = this.city;
        data["category"] = this.category;
        data["id"] = this.id;
        return data;
    }
}

export interface IAirportDto {
    airportName: string | undefined;
    iata: string | undefined;
    city: string | undefined;
    category: string | undefined;
    id: string;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverSiteUrl = _data["serverSiteUrl"];
            if (Array.isArray(_data["languages"])) {
                this.languages = [] as any;
                for (let item of _data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: DateTime;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean;
    userDelegationIsEnabled!: boolean;
    twoFactorCodeExpireSeconds!: number;
    features!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.version = _data["version"];
            this.releaseDate = _data["releaseDate"] ? DateTime.fromISO(_data["releaseDate"].toString()) : <any>undefined;
            this.currency = _data["currency"];
            this.currencySign = _data["currencySign"];
            this.allowTenantsToChangeEmailSettings = _data["allowTenantsToChangeEmailSettings"];
            this.userDelegationIsEnabled = _data["userDelegationIsEnabled"];
            this.twoFactorCodeExpireSeconds = _data["twoFactorCodeExpireSeconds"];
            if (_data["features"]) {
                this.features = {} as any;
                for (let key in _data["features"]) {
                    if (_data["features"].hasOwnProperty(key))
                        (<any>this.features)![key] = _data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        data["userDelegationIsEnabled"] = this.userDelegationIsEnabled;
        data["twoFactorCodeExpireSeconds"] = this.twoFactorCodeExpireSeconds;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    (<any>data["features"])[key] = (<any>this.features)[key];
            }
        }
        return data;
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: DateTime;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean;
    userDelegationIsEnabled: boolean;
    twoFactorCodeExpireSeconds: number;
    features: { [key: string]: boolean; } | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.icon = _data["icon"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data;
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean;
    isDeleted!: boolean;
    deleterUserId!: number | undefined;
    deletionTime!: DateTime | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.icon = _data["icon"];
            this.isDisabled = _data["isDisabled"];
            this.isDeleted = _data["isDeleted"];
            this.deleterUserId = _data["deleterUserId"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean;
    isDeleted: boolean;
    deleterUserId: number | undefined;
    deletionTime: DateTime | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: DateTime;
    executionDuration!: number;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.impersonatorTenantId = _data["impersonatorTenantId"];
            this.impersonatorUserId = _data["impersonatorUserId"];
            this.serviceName = _data["serviceName"];
            this.methodName = _data["methodName"];
            this.parameters = _data["parameters"];
            this.executionTime = _data["executionTime"] ? DateTime.fromISO(_data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = _data["executionDuration"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.exception = _data["exception"];
            this.customData = _data["customData"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data;
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: DateTime;
    executionDuration: number;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    captchaResponse!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userNameOrEmailAddress = _data["userNameOrEmailAddress"];
            this.password = _data["password"];
            this.twoFactorVerificationCode = _data["twoFactorVerificationCode"];
            this.rememberClient = _data["rememberClient"];
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.singleSignIn = _data["singleSignIn"];
            this.returnUrl = _data["returnUrl"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    captchaResponse: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    shouldResetPassword!: boolean;
    passwordResetCode!: string | undefined;
    userId!: number;
    requiresTwoFactorVerification!: boolean;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;
    c!: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.shouldResetPassword = _data["shouldResetPassword"];
            this.passwordResetCode = _data["passwordResetCode"];
            this.userId = _data["userId"];
            this.requiresTwoFactorVerification = _data["requiresTwoFactorVerification"];
            if (Array.isArray(_data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of _data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = _data["twoFactorRememberClientToken"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        data["c"] = this.c;
        return data;
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    shouldResetPassword: boolean;
    passwordResetCode: string | undefined;
    userId: number;
    requiresTwoFactorVerification: boolean;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
    c: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IBlockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.gateway = _data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data;
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data;
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data;
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export enum ChartDateInterval {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number;
    tenantId!: number | undefined;
    targetUserId!: number;
    targetTenantId!: number | undefined;
    side!: ChatSide;
    readState!: ChatMessageReadState;
    receiverReadState!: ChatMessageReadState;
    message!: string | undefined;
    creationTime!: DateTime;
    sharedMessageId!: string | undefined;
    id!: number;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
            this.targetUserId = _data["targetUserId"];
            this.targetTenantId = _data["targetTenantId"];
            this.side = _data["side"];
            this.readState = _data["readState"];
            this.receiverReadState = _data["receiverReadState"];
            this.message = _data["message"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = _data["sharedMessageId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data;
    }
}

export interface IChatMessageDto {
    userId: number;
    tenantId: number | undefined;
    targetUserId: number;
    targetTenantId: number | undefined;
    side: ChatSide;
    readState: ChatMessageReadState;
    receiverReadState: ChatMessageReadState;
    message: string | undefined;
    creationTime: DateTime;
    sharedMessageId: string | undefined;
    id: number;
}

export enum ChatMessageReadState {
    Unread = 1,
    Read = 2,
}

export enum ChatSide {
    Sender = 1,
    Receiver = 2,
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isDatabaseExist = _data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data;
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean;
}

export class CleanValuesInput implements ICleanValuesInput {
    dynamicEntityPropertyId!: number;
    entityId!: string | undefined;

    constructor(data?: ICleanValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.entityId = _data["entityId"];
        }
    }

    static fromJS(data: any): CleanValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new CleanValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["entityId"] = this.entityId;
        return data;
    }
}

export interface ICleanValuesInput {
    dynamicEntityPropertyId: number;
    entityId: string | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class CostCenterDto implements ICostCenterDto {
    controllingArea!: string | undefined;
    costCenterName!: string | undefined;
    description!: string | undefined;
    isActive!: boolean;
    costCenterCode!: string | undefined;
    departmentName!: string | undefined;
    period!: string | undefined;
    id!: string;

    constructor(data?: ICostCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.controllingArea = _data["controllingArea"];
            this.costCenterName = _data["costCenterName"];
            this.description = _data["description"];
            this.isActive = _data["isActive"];
            this.costCenterCode = _data["costCenterCode"];
            this.departmentName = _data["departmentName"];
            this.period = _data["period"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CostCenterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controllingArea"] = this.controllingArea;
        data["costCenterName"] = this.costCenterName;
        data["description"] = this.description;
        data["isActive"] = this.isActive;
        data["costCenterCode"] = this.costCenterCode;
        data["departmentName"] = this.departmentName;
        data["period"] = this.period;
        data["id"] = this.id;
        return data;
    }
}

export interface ICostCenterDto {
    controllingArea: string | undefined;
    costCenterName: string | undefined;
    description: string | undefined;
    isActive: boolean;
    costCenterCode: string | undefined;
    departmentName: string | undefined;
    period: string | undefined;
    id: string;
}

export class CostCenterSynchDto implements ICostCenterSynchDto {
    costCenterName!: string | undefined;
    year!: number;

    constructor(data?: ICostCenterSynchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.costCenterName = _data["costCenterName"];
            this.year = _data["year"];
        }
    }

    static fromJS(data: any): CostCenterSynchDto {
        data = typeof data === 'object' ? data : {};
        let result = new CostCenterSynchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["costCenterName"] = this.costCenterName;
        data["year"] = this.year;
        return data;
    }
}

export interface ICostCenterSynchDto {
    costCenterName: string | undefined;
    year: number;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionCreateDto.fromJS(_data["edition"]) : new EditionCreateDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class CreateFriendshipForCurrentTenantInput implements ICreateFriendshipForCurrentTenantInput {
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipForCurrentTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipForCurrentTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipForCurrentTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        return data;
    }
}

export interface ICreateFriendshipForCurrentTenantInput {
    userName: string | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number;
    tenantId: number | undefined;
}

export class CreateFriendshipWithDifferentTenantInput implements ICreateFriendshipWithDifferentTenantInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipWithDifferentTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipWithDifferentTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipWithDifferentTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ICreateFriendshipWithDifferentTenantInput {
    tenancyName: string;
    userName: string | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.subscriptionPaymentId = _data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data;
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number;
}

export class CreateMassNotificationInput implements ICreateMassNotificationInput {
    message!: string | undefined;
    severity!: NotificationSeverity;
    userIds!: number[] | undefined;
    organizationUnitIds!: number[] | undefined;
    targetNotifiers!: string[] | undefined;

    constructor(data?: ICreateMassNotificationInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.severity = _data["severity"];
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            if (Array.isArray(_data["organizationUnitIds"])) {
                this.organizationUnitIds = [] as any;
                for (let item of _data["organizationUnitIds"])
                    this.organizationUnitIds!.push(item);
            }
            if (Array.isArray(_data["targetNotifiers"])) {
                this.targetNotifiers = [] as any;
                for (let item of _data["targetNotifiers"])
                    this.targetNotifiers!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateMassNotificationInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateMassNotificationInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["severity"] = this.severity;
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        if (Array.isArray(this.organizationUnitIds)) {
            data["organizationUnitIds"] = [];
            for (let item of this.organizationUnitIds)
                data["organizationUnitIds"].push(item);
        }
        if (Array.isArray(this.targetNotifiers)) {
            data["targetNotifiers"] = [];
            for (let item of this.targetNotifiers)
                data["targetNotifiers"].push(item);
        }
        return data;
    }
}

export interface ICreateMassNotificationInput {
    message: string | undefined;
    severity: NotificationSeverity;
    userIds: number[] | undefined;
    organizationUnitIds: number[] | undefined;
    targetNotifiers: string[] | undefined;
}

export class CreateOrEditAirportDto implements ICreateOrEditAirportDto {
    airportName!: string;
    iata!: string;
    city!: string | undefined;
    category!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditAirportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.airportName = _data["airportName"];
            this.iata = _data["iata"];
            this.city = _data["city"];
            this.category = _data["category"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAirportDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAirportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["airportName"] = this.airportName;
        data["iata"] = this.iata;
        data["city"] = this.city;
        data["category"] = this.category;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditAirportDto {
    airportName: string;
    iata: string;
    city: string | undefined;
    category: string | undefined;
    id: string | undefined;
}

export class CreateOrEditCostCenterDto implements ICreateOrEditCostCenterDto {
    controllingArea!: string;
    costCenterName!: string;
    description!: string | undefined;
    actState!: string | undefined;
    isActive!: boolean;
    costCenterCode!: string;
    costCenterShort!: string | undefined;
    departmentName!: string | undefined;
    period!: string;
    id!: string | undefined;

    constructor(data?: ICreateOrEditCostCenterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.controllingArea = _data["controllingArea"];
            this.costCenterName = _data["costCenterName"];
            this.description = _data["description"];
            this.actState = _data["actState"];
            this.isActive = _data["isActive"];
            this.costCenterCode = _data["costCenterCode"];
            this.costCenterShort = _data["costCenterShort"];
            this.departmentName = _data["departmentName"];
            this.period = _data["period"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCostCenterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCostCenterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["controllingArea"] = this.controllingArea;
        data["costCenterName"] = this.costCenterName;
        data["description"] = this.description;
        data["actState"] = this.actState;
        data["isActive"] = this.isActive;
        data["costCenterCode"] = this.costCenterCode;
        data["costCenterShort"] = this.costCenterShort;
        data["departmentName"] = this.departmentName;
        data["period"] = this.period;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditCostCenterDto {
    controllingArea: string;
    costCenterName: string;
    description: string | undefined;
    actState: string | undefined;
    isActive: boolean;
    costCenterCode: string;
    costCenterShort: string | undefined;
    departmentName: string | undefined;
    period: string;
    id: string | undefined;
}

export class CreateOrEditDataProductionDto implements ICreateOrEditDataProductionDto {
    intfId!: string | undefined;
    intfSite!: string | undefined;
    intfSession!: string | undefined;
    objectId!: string | undefined;
    messageType!: string | undefined;
    materialDocument!: string | undefined;
    materialDocYear!: number;
    materialDocItem!: number;
    order!: string | undefined;
    reservation!: number;
    purchaseOrder!: string | undefined;
    purchaseOrderItem!: number;
    movementType!: string | undefined;
    movementTypeText!: string | undefined;
    plant!: string | undefined;
    storageLocation!: string | undefined;
    material!: string | undefined;
    materialDescription!: string | undefined;
    vendor!: string | undefined;
    quantity!: number;
    qtyInOrderUnit!: number;
    unitOfEntry!: string | undefined;
    postingDate!: DateTime;
    entryDate!: DateTime;
    timeOfEntry!: string | undefined;
    userName!: string | undefined;
    documentHeaderText!: string | undefined;
    documentDate!: DateTime;
    batch!: string | undefined;
    costCenter!: string | undefined;
    reference!: string | undefined;
    interfaceCreatedDate!: DateTime;
    interfaceCreatedBy!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditDataProductionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.intfId = _data["intfId"];
            this.intfSite = _data["intfSite"];
            this.intfSession = _data["intfSession"];
            this.objectId = _data["objectId"];
            this.messageType = _data["messageType"];
            this.materialDocument = _data["materialDocument"];
            this.materialDocYear = _data["materialDocYear"];
            this.materialDocItem = _data["materialDocItem"];
            this.order = _data["order"];
            this.reservation = _data["reservation"];
            this.purchaseOrder = _data["purchaseOrder"];
            this.purchaseOrderItem = _data["purchaseOrderItem"];
            this.movementType = _data["movementType"];
            this.movementTypeText = _data["movementTypeText"];
            this.plant = _data["plant"];
            this.storageLocation = _data["storageLocation"];
            this.material = _data["material"];
            this.materialDescription = _data["materialDescription"];
            this.vendor = _data["vendor"];
            this.quantity = _data["quantity"];
            this.qtyInOrderUnit = _data["qtyInOrderUnit"];
            this.unitOfEntry = _data["unitOfEntry"];
            this.postingDate = _data["postingDate"] ? DateTime.fromISO(_data["postingDate"].toString()) : <any>undefined;
            this.entryDate = _data["entryDate"] ? DateTime.fromISO(_data["entryDate"].toString()) : <any>undefined;
            this.timeOfEntry = _data["timeOfEntry"];
            this.userName = _data["userName"];
            this.documentHeaderText = _data["documentHeaderText"];
            this.documentDate = _data["documentDate"] ? DateTime.fromISO(_data["documentDate"].toString()) : <any>undefined;
            this.batch = _data["batch"];
            this.costCenter = _data["costCenter"];
            this.reference = _data["reference"];
            this.interfaceCreatedDate = _data["interfaceCreatedDate"] ? DateTime.fromISO(_data["interfaceCreatedDate"].toString()) : <any>undefined;
            this.interfaceCreatedBy = _data["interfaceCreatedBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditDataProductionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditDataProductionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["intfId"] = this.intfId;
        data["intfSite"] = this.intfSite;
        data["intfSession"] = this.intfSession;
        data["objectId"] = this.objectId;
        data["messageType"] = this.messageType;
        data["materialDocument"] = this.materialDocument;
        data["materialDocYear"] = this.materialDocYear;
        data["materialDocItem"] = this.materialDocItem;
        data["order"] = this.order;
        data["reservation"] = this.reservation;
        data["purchaseOrder"] = this.purchaseOrder;
        data["purchaseOrderItem"] = this.purchaseOrderItem;
        data["movementType"] = this.movementType;
        data["movementTypeText"] = this.movementTypeText;
        data["plant"] = this.plant;
        data["storageLocation"] = this.storageLocation;
        data["material"] = this.material;
        data["materialDescription"] = this.materialDescription;
        data["vendor"] = this.vendor;
        data["quantity"] = this.quantity;
        data["qtyInOrderUnit"] = this.qtyInOrderUnit;
        data["unitOfEntry"] = this.unitOfEntry;
        data["postingDate"] = this.postingDate ? this.postingDate.toString() : <any>undefined;
        data["entryDate"] = this.entryDate ? this.entryDate.toString() : <any>undefined;
        data["timeOfEntry"] = this.timeOfEntry;
        data["userName"] = this.userName;
        data["documentHeaderText"] = this.documentHeaderText;
        data["documentDate"] = this.documentDate ? this.documentDate.toString() : <any>undefined;
        data["batch"] = this.batch;
        data["costCenter"] = this.costCenter;
        data["reference"] = this.reference;
        data["interfaceCreatedDate"] = this.interfaceCreatedDate ? this.interfaceCreatedDate.toString() : <any>undefined;
        data["interfaceCreatedBy"] = this.interfaceCreatedBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditDataProductionDto {
    intfId: string | undefined;
    intfSite: string | undefined;
    intfSession: string | undefined;
    objectId: string | undefined;
    messageType: string | undefined;
    materialDocument: string | undefined;
    materialDocYear: number;
    materialDocItem: number;
    order: string | undefined;
    reservation: number;
    purchaseOrder: string | undefined;
    purchaseOrderItem: number;
    movementType: string | undefined;
    movementTypeText: string | undefined;
    plant: string | undefined;
    storageLocation: string | undefined;
    material: string | undefined;
    materialDescription: string | undefined;
    vendor: string | undefined;
    quantity: number;
    qtyInOrderUnit: number;
    unitOfEntry: string | undefined;
    postingDate: DateTime;
    entryDate: DateTime;
    timeOfEntry: string | undefined;
    userName: string | undefined;
    documentHeaderText: string | undefined;
    documentDate: DateTime;
    batch: string | undefined;
    costCenter: string | undefined;
    reference: string | undefined;
    interfaceCreatedDate: DateTime;
    interfaceCreatedBy: string | undefined;
    id: string | undefined;
}

export class CreateOrEditEKPODto implements ICreateOrEditEKPODto {
    mandt!: string | undefined;
    ebeln!: string | undefined;
    ebelp!: number | undefined;
    uniqueid!: string | undefined;
    loekz!: string | undefined;
    statu!: string | undefined;
    aedat!: DateTime | undefined;
    txZ01!: string | undefined;
    matnr!: string | undefined;
    ematn!: string | undefined;
    bukrs!: string | undefined;
    werks!: string | undefined;
    lgort!: string | undefined;
    bednr!: string | undefined;
    matkl!: string | undefined;
    infnr!: string | undefined;
    idnlf!: string | undefined;
    ktmng!: number | undefined;
    menge!: number | undefined;
    meins!: string | undefined;
    bprme!: string | undefined;
    bpumz!: number | undefined;
    bpumn!: number | undefined;
    umrez!: number | undefined;
    umren!: number | undefined;
    netpr!: number | undefined;
    peinh!: number | undefined;
    netwr!: number | undefined;
    brtwr!: number | undefined;
    agdat!: DateTime | undefined;
    webaz!: number | undefined;
    mwskz!: string | undefined;
    bonus!: string | undefined;
    insmk!: string | undefined;
    spinf!: string | undefined;
    prsdr!: string | undefined;
    bwtar!: string | undefined;
    bwtty!: string | undefined;
    abskz!: string | undefined;
    pstyp!: string | undefined;
    knttp!: string | undefined;
    konnr!: string | undefined;
    ktpnr!: number | undefined;
    packno!: number | undefined;
    anfnr!: string | undefined;
    banfn!: string | undefined;
    bnfpo!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditEKPODto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mandt = _data["mandt"];
            this.ebeln = _data["ebeln"];
            this.ebelp = _data["ebelp"];
            this.uniqueid = _data["uniqueid"];
            this.loekz = _data["loekz"];
            this.statu = _data["statu"];
            this.aedat = _data["aedat"] ? DateTime.fromISO(_data["aedat"].toString()) : <any>undefined;
            this.txZ01 = _data["txZ01"];
            this.matnr = _data["matnr"];
            this.ematn = _data["ematn"];
            this.bukrs = _data["bukrs"];
            this.werks = _data["werks"];
            this.lgort = _data["lgort"];
            this.bednr = _data["bednr"];
            this.matkl = _data["matkl"];
            this.infnr = _data["infnr"];
            this.idnlf = _data["idnlf"];
            this.ktmng = _data["ktmng"];
            this.menge = _data["menge"];
            this.meins = _data["meins"];
            this.bprme = _data["bprme"];
            this.bpumz = _data["bpumz"];
            this.bpumn = _data["bpumn"];
            this.umrez = _data["umrez"];
            this.umren = _data["umren"];
            this.netpr = _data["netpr"];
            this.peinh = _data["peinh"];
            this.netwr = _data["netwr"];
            this.brtwr = _data["brtwr"];
            this.agdat = _data["agdat"] ? DateTime.fromISO(_data["agdat"].toString()) : <any>undefined;
            this.webaz = _data["webaz"];
            this.mwskz = _data["mwskz"];
            this.bonus = _data["bonus"];
            this.insmk = _data["insmk"];
            this.spinf = _data["spinf"];
            this.prsdr = _data["prsdr"];
            this.bwtar = _data["bwtar"];
            this.bwtty = _data["bwtty"];
            this.abskz = _data["abskz"];
            this.pstyp = _data["pstyp"];
            this.knttp = _data["knttp"];
            this.konnr = _data["konnr"];
            this.ktpnr = _data["ktpnr"];
            this.packno = _data["packno"];
            this.anfnr = _data["anfnr"];
            this.banfn = _data["banfn"];
            this.bnfpo = _data["bnfpo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEKPODto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEKPODto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandt"] = this.mandt;
        data["ebeln"] = this.ebeln;
        data["ebelp"] = this.ebelp;
        data["uniqueid"] = this.uniqueid;
        data["loekz"] = this.loekz;
        data["statu"] = this.statu;
        data["aedat"] = this.aedat ? this.aedat.toString() : <any>undefined;
        data["txZ01"] = this.txZ01;
        data["matnr"] = this.matnr;
        data["ematn"] = this.ematn;
        data["bukrs"] = this.bukrs;
        data["werks"] = this.werks;
        data["lgort"] = this.lgort;
        data["bednr"] = this.bednr;
        data["matkl"] = this.matkl;
        data["infnr"] = this.infnr;
        data["idnlf"] = this.idnlf;
        data["ktmng"] = this.ktmng;
        data["menge"] = this.menge;
        data["meins"] = this.meins;
        data["bprme"] = this.bprme;
        data["bpumz"] = this.bpumz;
        data["bpumn"] = this.bpumn;
        data["umrez"] = this.umrez;
        data["umren"] = this.umren;
        data["netpr"] = this.netpr;
        data["peinh"] = this.peinh;
        data["netwr"] = this.netwr;
        data["brtwr"] = this.brtwr;
        data["agdat"] = this.agdat ? this.agdat.toString() : <any>undefined;
        data["webaz"] = this.webaz;
        data["mwskz"] = this.mwskz;
        data["bonus"] = this.bonus;
        data["insmk"] = this.insmk;
        data["spinf"] = this.spinf;
        data["prsdr"] = this.prsdr;
        data["bwtar"] = this.bwtar;
        data["bwtty"] = this.bwtty;
        data["abskz"] = this.abskz;
        data["pstyp"] = this.pstyp;
        data["knttp"] = this.knttp;
        data["konnr"] = this.konnr;
        data["ktpnr"] = this.ktpnr;
        data["packno"] = this.packno;
        data["anfnr"] = this.anfnr;
        data["banfn"] = this.banfn;
        data["bnfpo"] = this.bnfpo;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditEKPODto {
    mandt: string | undefined;
    ebeln: string | undefined;
    ebelp: number | undefined;
    uniqueid: string | undefined;
    loekz: string | undefined;
    statu: string | undefined;
    aedat: DateTime | undefined;
    txZ01: string | undefined;
    matnr: string | undefined;
    ematn: string | undefined;
    bukrs: string | undefined;
    werks: string | undefined;
    lgort: string | undefined;
    bednr: string | undefined;
    matkl: string | undefined;
    infnr: string | undefined;
    idnlf: string | undefined;
    ktmng: number | undefined;
    menge: number | undefined;
    meins: string | undefined;
    bprme: string | undefined;
    bpumz: number | undefined;
    bpumn: number | undefined;
    umrez: number | undefined;
    umren: number | undefined;
    netpr: number | undefined;
    peinh: number | undefined;
    netwr: number | undefined;
    brtwr: number | undefined;
    agdat: DateTime | undefined;
    webaz: number | undefined;
    mwskz: string | undefined;
    bonus: string | undefined;
    insmk: string | undefined;
    spinf: string | undefined;
    prsdr: string | undefined;
    bwtar: string | undefined;
    bwtty: string | undefined;
    abskz: string | undefined;
    pstyp: string | undefined;
    knttp: string | undefined;
    konnr: string | undefined;
    ktpnr: number | undefined;
    packno: number | undefined;
    anfnr: string | undefined;
    banfn: string | undefined;
    bnfpo: number | undefined;
    id: string | undefined;
}

export class CreateOrEditEkkoDto implements ICreateOrEditEkkoDto {
    mandt!: string | undefined;
    ebeln!: string | undefined;
    bukrs!: string | undefined;
    bstyp!: string | undefined;
    bsart!: string | undefined;
    bsakz!: string | undefined;
    loekz!: string | undefined;
    statu!: string | undefined;
    aedat!: DateTime | undefined;
    ernam!: string | undefined;
    pincr!: number | undefined;
    lponr!: number | undefined;
    lifnr!: string | undefined;
    zterm!: string | undefined;
    zbD1T!: number | undefined;
    zbD2T!: number | undefined;
    zbD3T!: number | undefined;
    zbD1P!: number | undefined;
    zbD2P!: number | undefined;
    ekorg!: string | undefined;
    ekgrp!: string | undefined;
    waers!: string | undefined;
    wkurs!: number | undefined;
    kufix!: string | undefined;
    bedat!: DateTime | undefined;
    kdatb!: DateTime | undefined;
    kdate!: DateTime | undefined;
    bwbdt!: DateTime | undefined;
    gwldt!: DateTime | undefined;
    ihran!: DateTime | undefined;
    kunnr!: string | undefined;
    konnr!: string | undefined;
    abgru!: string | undefined;
    autlf!: string | undefined;
    weakt!: string | undefined;
    reswk!: string | undefined;
    lblif!: string | undefined;
    incO1!: string | undefined;
    incO2!: string | undefined;
    submi!: string | undefined;
    knumv!: string | undefined;
    kalsm!: string | undefined;
    procstat!: string | undefined;
    unsez!: string | undefined;
    frggr!: string | undefined;
    frgsx!: string | undefined;
    frgke!: string | undefined;
    frgzu!: string | undefined;
    adrnr!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditEkkoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mandt = _data["mandt"];
            this.ebeln = _data["ebeln"];
            this.bukrs = _data["bukrs"];
            this.bstyp = _data["bstyp"];
            this.bsart = _data["bsart"];
            this.bsakz = _data["bsakz"];
            this.loekz = _data["loekz"];
            this.statu = _data["statu"];
            this.aedat = _data["aedat"] ? DateTime.fromISO(_data["aedat"].toString()) : <any>undefined;
            this.ernam = _data["ernam"];
            this.pincr = _data["pincr"];
            this.lponr = _data["lponr"];
            this.lifnr = _data["lifnr"];
            this.zterm = _data["zterm"];
            this.zbD1T = _data["zbD1T"];
            this.zbD2T = _data["zbD2T"];
            this.zbD3T = _data["zbD3T"];
            this.zbD1P = _data["zbD1P"];
            this.zbD2P = _data["zbD2P"];
            this.ekorg = _data["ekorg"];
            this.ekgrp = _data["ekgrp"];
            this.waers = _data["waers"];
            this.wkurs = _data["wkurs"];
            this.kufix = _data["kufix"];
            this.bedat = _data["bedat"] ? DateTime.fromISO(_data["bedat"].toString()) : <any>undefined;
            this.kdatb = _data["kdatb"] ? DateTime.fromISO(_data["kdatb"].toString()) : <any>undefined;
            this.kdate = _data["kdate"] ? DateTime.fromISO(_data["kdate"].toString()) : <any>undefined;
            this.bwbdt = _data["bwbdt"] ? DateTime.fromISO(_data["bwbdt"].toString()) : <any>undefined;
            this.gwldt = _data["gwldt"] ? DateTime.fromISO(_data["gwldt"].toString()) : <any>undefined;
            this.ihran = _data["ihran"] ? DateTime.fromISO(_data["ihran"].toString()) : <any>undefined;
            this.kunnr = _data["kunnr"];
            this.konnr = _data["konnr"];
            this.abgru = _data["abgru"];
            this.autlf = _data["autlf"];
            this.weakt = _data["weakt"];
            this.reswk = _data["reswk"];
            this.lblif = _data["lblif"];
            this.incO1 = _data["incO1"];
            this.incO2 = _data["incO2"];
            this.submi = _data["submi"];
            this.knumv = _data["knumv"];
            this.kalsm = _data["kalsm"];
            this.procstat = _data["procstat"];
            this.unsez = _data["unsez"];
            this.frggr = _data["frggr"];
            this.frgsx = _data["frgsx"];
            this.frgke = _data["frgke"];
            this.frgzu = _data["frgzu"];
            this.adrnr = _data["adrnr"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEkkoDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEkkoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandt"] = this.mandt;
        data["ebeln"] = this.ebeln;
        data["bukrs"] = this.bukrs;
        data["bstyp"] = this.bstyp;
        data["bsart"] = this.bsart;
        data["bsakz"] = this.bsakz;
        data["loekz"] = this.loekz;
        data["statu"] = this.statu;
        data["aedat"] = this.aedat ? this.aedat.toString() : <any>undefined;
        data["ernam"] = this.ernam;
        data["pincr"] = this.pincr;
        data["lponr"] = this.lponr;
        data["lifnr"] = this.lifnr;
        data["zterm"] = this.zterm;
        data["zbD1T"] = this.zbD1T;
        data["zbD2T"] = this.zbD2T;
        data["zbD3T"] = this.zbD3T;
        data["zbD1P"] = this.zbD1P;
        data["zbD2P"] = this.zbD2P;
        data["ekorg"] = this.ekorg;
        data["ekgrp"] = this.ekgrp;
        data["waers"] = this.waers;
        data["wkurs"] = this.wkurs;
        data["kufix"] = this.kufix;
        data["bedat"] = this.bedat ? this.bedat.toString() : <any>undefined;
        data["kdatb"] = this.kdatb ? this.kdatb.toString() : <any>undefined;
        data["kdate"] = this.kdate ? this.kdate.toString() : <any>undefined;
        data["bwbdt"] = this.bwbdt ? this.bwbdt.toString() : <any>undefined;
        data["gwldt"] = this.gwldt ? this.gwldt.toString() : <any>undefined;
        data["ihran"] = this.ihran ? this.ihran.toString() : <any>undefined;
        data["kunnr"] = this.kunnr;
        data["konnr"] = this.konnr;
        data["abgru"] = this.abgru;
        data["autlf"] = this.autlf;
        data["weakt"] = this.weakt;
        data["reswk"] = this.reswk;
        data["lblif"] = this.lblif;
        data["incO1"] = this.incO1;
        data["incO2"] = this.incO2;
        data["submi"] = this.submi;
        data["knumv"] = this.knumv;
        data["kalsm"] = this.kalsm;
        data["procstat"] = this.procstat;
        data["unsez"] = this.unsez;
        data["frggr"] = this.frggr;
        data["frgsx"] = this.frgsx;
        data["frgke"] = this.frgke;
        data["frgzu"] = this.frgzu;
        data["adrnr"] = this.adrnr;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditEkkoDto {
    mandt: string | undefined;
    ebeln: string | undefined;
    bukrs: string | undefined;
    bstyp: string | undefined;
    bsart: string | undefined;
    bsakz: string | undefined;
    loekz: string | undefined;
    statu: string | undefined;
    aedat: DateTime | undefined;
    ernam: string | undefined;
    pincr: number | undefined;
    lponr: number | undefined;
    lifnr: string | undefined;
    zterm: string | undefined;
    zbD1T: number | undefined;
    zbD2T: number | undefined;
    zbD3T: number | undefined;
    zbD1P: number | undefined;
    zbD2P: number | undefined;
    ekorg: string | undefined;
    ekgrp: string | undefined;
    waers: string | undefined;
    wkurs: number | undefined;
    kufix: string | undefined;
    bedat: DateTime | undefined;
    kdatb: DateTime | undefined;
    kdate: DateTime | undefined;
    bwbdt: DateTime | undefined;
    gwldt: DateTime | undefined;
    ihran: DateTime | undefined;
    kunnr: string | undefined;
    konnr: string | undefined;
    abgru: string | undefined;
    autlf: string | undefined;
    weakt: string | undefined;
    reswk: string | undefined;
    lblif: string | undefined;
    incO1: string | undefined;
    incO2: string | undefined;
    submi: string | undefined;
    knumv: string | undefined;
    kalsm: string | undefined;
    procstat: string | undefined;
    unsez: string | undefined;
    frggr: string | undefined;
    frgsx: string | undefined;
    frgke: string | undefined;
    frgzu: string | undefined;
    adrnr: string | undefined;
    id: string | undefined;
}

export class CreateOrEditEnumTableDto implements ICreateOrEditEnumTableDto {
    enumCode!: string;
    enumValue!: string;
    enumLabel!: string;
    id!: string | undefined;

    constructor(data?: ICreateOrEditEnumTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enumCode = _data["enumCode"];
            this.enumValue = _data["enumValue"];
            this.enumLabel = _data["enumLabel"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEnumTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEnumTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enumCode"] = this.enumCode;
        data["enumValue"] = this.enumValue;
        data["enumLabel"] = this.enumLabel;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditEnumTableDto {
    enumCode: string;
    enumValue: string;
    enumLabel: string;
    id: string | undefined;
}

export class CreateOrEditGeneralLedgerAccountDto implements ICreateOrEditGeneralLedgerAccountDto {
    fundsCenter!: string | undefined;
    consumableBudget!: number | undefined;
    consumedBudget!: number | undefined;
    availableAmount!: number | undefined;
    currentBudget!: number | undefined;
    commitmentActuals!: number | undefined;
    fundsCenterDescription!: string | undefined;
    costCenterId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditGeneralLedgerAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundsCenter = _data["fundsCenter"];
            this.consumableBudget = _data["consumableBudget"];
            this.consumedBudget = _data["consumedBudget"];
            this.availableAmount = _data["availableAmount"];
            this.currentBudget = _data["currentBudget"];
            this.commitmentActuals = _data["commitmentActuals"];
            this.fundsCenterDescription = _data["fundsCenterDescription"];
            this.costCenterId = _data["costCenterId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditGeneralLedgerAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGeneralLedgerAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundsCenter"] = this.fundsCenter;
        data["consumableBudget"] = this.consumableBudget;
        data["consumedBudget"] = this.consumedBudget;
        data["availableAmount"] = this.availableAmount;
        data["currentBudget"] = this.currentBudget;
        data["commitmentActuals"] = this.commitmentActuals;
        data["fundsCenterDescription"] = this.fundsCenterDescription;
        data["costCenterId"] = this.costCenterId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditGeneralLedgerAccountDto {
    fundsCenter: string | undefined;
    consumableBudget: number | undefined;
    consumedBudget: number | undefined;
    availableAmount: number | undefined;
    currentBudget: number | undefined;
    commitmentActuals: number | undefined;
    fundsCenterDescription: string | undefined;
    costCenterId: string | undefined;
    id: string | undefined;
}

export class CreateOrEditGeneralLedgerMappingDto implements ICreateOrEditGeneralLedgerMappingDto {
    glAccount!: string;
    glAccountDescription!: string | undefined;
    mappingType!: string;
    valuationClass!: string;
    valuationClassDescription!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditGeneralLedgerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.glAccount = _data["glAccount"];
            this.glAccountDescription = _data["glAccountDescription"];
            this.mappingType = _data["mappingType"];
            this.valuationClass = _data["valuationClass"];
            this.valuationClassDescription = _data["valuationClassDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditGeneralLedgerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditGeneralLedgerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["glAccount"] = this.glAccount;
        data["glAccountDescription"] = this.glAccountDescription;
        data["mappingType"] = this.mappingType;
        data["valuationClass"] = this.valuationClass;
        data["valuationClassDescription"] = this.valuationClassDescription;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditGeneralLedgerMappingDto {
    glAccount: string;
    glAccountDescription: string | undefined;
    mappingType: string;
    valuationClass: string;
    valuationClassDescription: string | undefined;
    id: string | undefined;
}

export class CreateOrEditJobSynchronizeDto implements ICreateOrEditJobSynchronizeDto {
    jobName!: string;
    jobType!: JobSchedulerType;
    dataSource!: string;
    lastStatus!: JobSchedulerStatus;
    uri!: string | undefined;
    lastUpdate!: DateTime;
    totalInsert!: number;
    totalUpdate!: number;
    totalDelete!: number;
    id!: string | undefined;

    constructor(data?: ICreateOrEditJobSynchronizeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobName = _data["jobName"];
            this.jobType = _data["jobType"];
            this.dataSource = _data["dataSource"];
            this.lastStatus = _data["lastStatus"];
            this.uri = _data["uri"];
            this.lastUpdate = _data["lastUpdate"] ? DateTime.fromISO(_data["lastUpdate"].toString()) : <any>undefined;
            this.totalInsert = _data["totalInsert"];
            this.totalUpdate = _data["totalUpdate"];
            this.totalDelete = _data["totalDelete"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditJobSynchronizeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditJobSynchronizeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobName"] = this.jobName;
        data["jobType"] = this.jobType;
        data["dataSource"] = this.dataSource;
        data["lastStatus"] = this.lastStatus;
        data["uri"] = this.uri;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toString() : <any>undefined;
        data["totalInsert"] = this.totalInsert;
        data["totalUpdate"] = this.totalUpdate;
        data["totalDelete"] = this.totalDelete;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditJobSynchronizeDto {
    jobName: string;
    jobType: JobSchedulerType;
    dataSource: string;
    lastStatus: JobSchedulerStatus;
    uri: string | undefined;
    lastUpdate: DateTime;
    totalInsert: number;
    totalUpdate: number;
    totalDelete: number;
    id: string | undefined;
}

export class CreateOrEditLookupPageDto implements ICreateOrEditLookupPageDto {
    lookupName!: string;
    costCenterId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditLookupPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lookupName = _data["lookupName"];
            this.costCenterId = _data["costCenterId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditLookupPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLookupPageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lookupName"] = this.lookupName;
        data["costCenterId"] = this.costCenterId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditLookupPageDto {
    lookupName: string;
    costCenterId: string | undefined;
    id: string | undefined;
}

export class CreateOrEditMaterialDto implements ICreateOrEditMaterialDto {
    materialNo!: string;
    materialName!: string;
    materialNameSAP!: string | undefined;
    description!: string;
    size!: string | undefined;
    uoM!: string;
    brand!: string | undefined;
    imageMain!: string | undefined;
    imageMainToken!: string | undefined;
    materialGroupId!: string | undefined;
    unspscId!: string | undefined;
    generalLedgerMappingId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialNo = _data["materialNo"];
            this.materialName = _data["materialName"];
            this.materialNameSAP = _data["materialNameSAP"];
            this.description = _data["description"];
            this.size = _data["size"];
            this.uoM = _data["uoM"];
            this.brand = _data["brand"];
            this.imageMain = _data["imageMain"];
            this.imageMainToken = _data["imageMainToken"];
            this.materialGroupId = _data["materialGroupId"];
            this.unspscId = _data["unspscId"];
            this.generalLedgerMappingId = _data["generalLedgerMappingId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialNo"] = this.materialNo;
        data["materialName"] = this.materialName;
        data["materialNameSAP"] = this.materialNameSAP;
        data["description"] = this.description;
        data["size"] = this.size;
        data["uoM"] = this.uoM;
        data["brand"] = this.brand;
        data["imageMain"] = this.imageMain;
        data["imageMainToken"] = this.imageMainToken;
        data["materialGroupId"] = this.materialGroupId;
        data["unspscId"] = this.unspscId;
        data["generalLedgerMappingId"] = this.generalLedgerMappingId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditMaterialDto {
    materialNo: string;
    materialName: string;
    materialNameSAP: string | undefined;
    description: string;
    size: string | undefined;
    uoM: string;
    brand: string | undefined;
    imageMain: string | undefined;
    imageMainToken: string | undefined;
    materialGroupId: string | undefined;
    unspscId: string | undefined;
    generalLedgerMappingId: string | undefined;
    id: string | undefined;
}

export class CreateOrEditMaterialGroupDto implements ICreateOrEditMaterialGroupDto {
    materialGroupCode!: string;
    materialGroupName!: string;
    materialGroupDescription!: string;
    language!: string;
    id!: string | undefined;

    constructor(data?: ICreateOrEditMaterialGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialGroupCode = _data["materialGroupCode"];
            this.materialGroupName = _data["materialGroupName"];
            this.materialGroupDescription = _data["materialGroupDescription"];
            this.language = _data["language"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMaterialGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMaterialGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialGroupCode"] = this.materialGroupCode;
        data["materialGroupName"] = this.materialGroupName;
        data["materialGroupDescription"] = this.materialGroupDescription;
        data["language"] = this.language;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditMaterialGroupDto {
    materialGroupCode: string;
    materialGroupName: string;
    materialGroupDescription: string;
    language: string;
    id: string | undefined;
}

export class CreateOrEditMaterialRequestDto implements ICreateOrEditMaterialRequestDto {
    requestNo!: string;
    requestStatus!: MaterialRequestStatus;
    materialName!: string;
    description!: string;
    purpose!: string;
    materialType!: string | undefined;
    category!: string | undefined;
    size!: string | undefined;
    uoM!: string | undefined;
    packageSize!: string | undefined;
    generalLedger!: string;
    brand!: string | undefined;
    weight!: string | undefined;
    picture!: string | undefined;
    pictureToken!: string | undefined;
    imageColletion!: string | undefined;
    unspscId!: string | undefined;
    valuationClassId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditMaterialRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestNo = _data["requestNo"];
            this.requestStatus = _data["requestStatus"];
            this.materialName = _data["materialName"];
            this.description = _data["description"];
            this.purpose = _data["purpose"];
            this.materialType = _data["materialType"];
            this.category = _data["category"];
            this.size = _data["size"];
            this.uoM = _data["uoM"];
            this.packageSize = _data["packageSize"];
            this.generalLedger = _data["generalLedger"];
            this.brand = _data["brand"];
            this.weight = _data["weight"];
            this.picture = _data["picture"];
            this.pictureToken = _data["pictureToken"];
            this.imageColletion = _data["imageColletion"];
            this.unspscId = _data["unspscId"];
            this.valuationClassId = _data["valuationClassId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMaterialRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMaterialRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestNo"] = this.requestNo;
        data["requestStatus"] = this.requestStatus;
        data["materialName"] = this.materialName;
        data["description"] = this.description;
        data["purpose"] = this.purpose;
        data["materialType"] = this.materialType;
        data["category"] = this.category;
        data["size"] = this.size;
        data["uoM"] = this.uoM;
        data["packageSize"] = this.packageSize;
        data["generalLedger"] = this.generalLedger;
        data["brand"] = this.brand;
        data["weight"] = this.weight;
        data["picture"] = this.picture;
        data["pictureToken"] = this.pictureToken;
        data["imageColletion"] = this.imageColletion;
        data["unspscId"] = this.unspscId;
        data["valuationClassId"] = this.valuationClassId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditMaterialRequestDto {
    requestNo: string;
    requestStatus: MaterialRequestStatus;
    materialName: string;
    description: string;
    purpose: string;
    materialType: string | undefined;
    category: string | undefined;
    size: string | undefined;
    uoM: string | undefined;
    packageSize: string | undefined;
    generalLedger: string;
    brand: string | undefined;
    weight: string | undefined;
    picture: string | undefined;
    pictureToken: string | undefined;
    imageColletion: string | undefined;
    unspscId: string | undefined;
    valuationClassId: string | undefined;
    id: string | undefined;
}

export class CreateOrEditRptProcurementAdjustDto implements ICreateOrEditRptProcurementAdjustDto {
    purchasingDocument!: string;
    isContract!: boolean;
    isAdjust!: boolean;
    dayAdjust!: number;
    remark!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditRptProcurementAdjustDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchasingDocument = _data["purchasingDocument"];
            this.isContract = _data["isContract"];
            this.isAdjust = _data["isAdjust"];
            this.dayAdjust = _data["dayAdjust"];
            this.remark = _data["remark"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRptProcurementAdjustDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRptProcurementAdjustDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchasingDocument"] = this.purchasingDocument;
        data["isContract"] = this.isContract;
        data["isAdjust"] = this.isAdjust;
        data["dayAdjust"] = this.dayAdjust;
        data["remark"] = this.remark;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditRptProcurementAdjustDto {
    purchasingDocument: string;
    isContract: boolean;
    isAdjust: boolean;
    dayAdjust: number;
    remark: string | undefined;
    id: string | undefined;
}

export class CreateOrEditTransferBudgetDto implements ICreateOrEditTransferBudgetDto {
    documentNo!: string;
    department!: string;
    division!: string;
    purpose!: string;
    projectActivities!: string | undefined;
    reason!: string;
    scopeofWork!: string;
    location!: string;
    transferBudgetItemFromDtos!: CreateOrEditTransferBudgetItemDto[] | undefined;
    transferBudgetItemToDtos!: CreateOrEditTransferBudgetItemDto[] | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditTransferBudgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentNo = _data["documentNo"];
            this.department = _data["department"];
            this.division = _data["division"];
            this.purpose = _data["purpose"];
            this.projectActivities = _data["projectActivities"];
            this.reason = _data["reason"];
            this.scopeofWork = _data["scopeofWork"];
            this.location = _data["location"];
            if (Array.isArray(_data["transferBudgetItemFromDtos"])) {
                this.transferBudgetItemFromDtos = [] as any;
                for (let item of _data["transferBudgetItemFromDtos"])
                    this.transferBudgetItemFromDtos!.push(CreateOrEditTransferBudgetItemDto.fromJS(item));
            }
            if (Array.isArray(_data["transferBudgetItemToDtos"])) {
                this.transferBudgetItemToDtos = [] as any;
                for (let item of _data["transferBudgetItemToDtos"])
                    this.transferBudgetItemToDtos!.push(CreateOrEditTransferBudgetItemDto.fromJS(item));
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTransferBudgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTransferBudgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentNo"] = this.documentNo;
        data["department"] = this.department;
        data["division"] = this.division;
        data["purpose"] = this.purpose;
        data["projectActivities"] = this.projectActivities;
        data["reason"] = this.reason;
        data["scopeofWork"] = this.scopeofWork;
        data["location"] = this.location;
        if (Array.isArray(this.transferBudgetItemFromDtos)) {
            data["transferBudgetItemFromDtos"] = [];
            for (let item of this.transferBudgetItemFromDtos)
                data["transferBudgetItemFromDtos"].push(item.toJSON());
        }
        if (Array.isArray(this.transferBudgetItemToDtos)) {
            data["transferBudgetItemToDtos"] = [];
            for (let item of this.transferBudgetItemToDtos)
                data["transferBudgetItemToDtos"].push(item.toJSON());
        }
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditTransferBudgetDto {
    documentNo: string;
    department: string;
    division: string;
    purpose: string;
    projectActivities: string | undefined;
    reason: string;
    scopeofWork: string;
    location: string;
    transferBudgetItemFromDtos: CreateOrEditTransferBudgetItemDto[] | undefined;
    transferBudgetItemToDtos: CreateOrEditTransferBudgetItemDto[] | undefined;
    id: string | undefined;
}

export class CreateOrEditTransferBudgetItemDto implements ICreateOrEditTransferBudgetItemDto {
    transferBudgetId!: string;
    costCenterId!: string;
    period!: string;
    amount!: number;
    costCenterCode!: string;
    costCenterName!: string | undefined;
    departmentName!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditTransferBudgetItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferBudgetId = _data["transferBudgetId"];
            this.costCenterId = _data["costCenterId"];
            this.period = _data["period"];
            this.amount = _data["amount"];
            this.costCenterCode = _data["costCenterCode"];
            this.costCenterName = _data["costCenterName"];
            this.departmentName = _data["departmentName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTransferBudgetItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTransferBudgetItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferBudgetId"] = this.transferBudgetId;
        data["costCenterId"] = this.costCenterId;
        data["period"] = this.period;
        data["amount"] = this.amount;
        data["costCenterCode"] = this.costCenterCode;
        data["costCenterName"] = this.costCenterName;
        data["departmentName"] = this.departmentName;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditTransferBudgetItemDto {
    transferBudgetId: string;
    costCenterId: string;
    period: string;
    amount: number;
    costCenterCode: string;
    costCenterName: string | undefined;
    departmentName: string | undefined;
    id: string | undefined;
}

export class CreateOrEditTravelRequestDto implements ICreateOrEditTravelRequestDto {
    requestNo!: string;
    travelStatus!: TravelStatus;
    travelType!: TravelType;
    requestDate!: DateTime;
    requestPlanDate!: DateTime;
    camp!: string | undefined;
    transportBus!: string | undefined;
    createdDate!: DateTime;
    userTravel!: number | undefined;
    airportFrom!: string | undefined;
    airportTo!: string | undefined;
    createdBy!: number | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditTravelRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestNo = _data["requestNo"];
            this.travelStatus = _data["travelStatus"];
            this.travelType = _data["travelType"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.requestPlanDate = _data["requestPlanDate"] ? DateTime.fromISO(_data["requestPlanDate"].toString()) : <any>undefined;
            this.camp = _data["camp"];
            this.transportBus = _data["transportBus"];
            this.createdDate = _data["createdDate"] ? DateTime.fromISO(_data["createdDate"].toString()) : <any>undefined;
            this.userTravel = _data["userTravel"];
            this.airportFrom = _data["airportFrom"];
            this.airportTo = _data["airportTo"];
            this.createdBy = _data["createdBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditTravelRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditTravelRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestNo"] = this.requestNo;
        data["travelStatus"] = this.travelStatus;
        data["travelType"] = this.travelType;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["requestPlanDate"] = this.requestPlanDate ? this.requestPlanDate.toString() : <any>undefined;
        data["camp"] = this.camp;
        data["transportBus"] = this.transportBus;
        data["createdDate"] = this.createdDate ? this.createdDate.toString() : <any>undefined;
        data["userTravel"] = this.userTravel;
        data["airportFrom"] = this.airportFrom;
        data["airportTo"] = this.airportTo;
        data["createdBy"] = this.createdBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditTravelRequestDto {
    requestNo: string;
    travelStatus: TravelStatus;
    travelType: TravelType;
    requestDate: DateTime;
    requestPlanDate: DateTime;
    camp: string | undefined;
    transportBus: string | undefined;
    createdDate: DateTime;
    userTravel: number | undefined;
    airportFrom: string | undefined;
    airportTo: string | undefined;
    createdBy: number | undefined;
    id: string | undefined;
}

export class CreateOrEditUNSPSCDto implements ICreateOrEditUNSPSCDto {
    unspsC_Code!: string | undefined;
    description!: string | undefined;
    accountCode!: string | undefined;
    descriptionId!: string | undefined;
    id!: string | undefined;

    constructor(data?: ICreateOrEditUNSPSCDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unspsC_Code = _data["unspsC_Code"];
            this.description = _data["description"];
            this.accountCode = _data["accountCode"];
            this.descriptionId = _data["descriptionId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUNSPSCDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUNSPSCDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unspsC_Code"] = this.unspsC_Code;
        data["description"] = this.description;
        data["accountCode"] = this.accountCode;
        data["descriptionId"] = this.descriptionId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditUNSPSCDto {
    unspsC_Code: string | undefined;
    description: string | undefined;
    accountCode: string | undefined;
    descriptionId: string | undefined;
    id: string | undefined;
}

export class CreateOrEditZMM020RDto implements ICreateOrEditZMM020RDto {
    purchaseRequisition!: string;
    documentType!: string;
    documentTypeText!: string;
    itemRequisition!: string;
    processingStatusCode!: string | undefined;
    processingStatus!: string | undefined;
    deletionIndicator!: string | undefined;
    itemCategory!: string | undefined;
    accountAssignment!: string | undefined;
    material!: string | undefined;
    shortText!: string | undefined;
    quantityRequested!: number | undefined;
    unitOfMeasure!: string | undefined;
    serviceItem!: string | undefined;
    service!: string | undefined;
    serviceShortText!: string | undefined;
    quantityService!: number | undefined;
    unitOfMeasureService!: string | undefined;
    deliveryDate!: DateTime | undefined;
    materialGroup!: string | undefined;
    plant!: string | undefined;
    storageLocation!: string | undefined;
    purchaseGroup!: string | undefined;
    requisitioner!: string | undefined;
    requisitionerName!: string | undefined;
    purchasingDocument!: string | undefined;
    purchaseOrderDate!: DateTime | undefined;
    outlineAgreement!: string | undefined;
    princAgreementItem!: string | undefined;
    purchasingInfoRec!: string | undefined;
    status!: string | undefined;
    createdBy!: string | undefined;
    currency!: string | undefined;
    entrySheet!: string | undefined;
    goodsReceipt!: string | undefined;
    supplierCode!: string | undefined;
    supplierName!: string | undefined;
    releaseIndicator!: string | undefined;
    unitPrice!: number | undefined;
    valuationPrice!: number | undefined;
    itemText!: string | undefined;
    longText!: string | undefined;
    firstApprovalDate!: DateTime | undefined;
    firstApprovalName!: string | undefined;
    lastApprovalDate!: DateTime | undefined;
    lastApprovalName!: string | undefined;
    costCenter!: string | undefined;
    costCenterDescription!: string | undefined;
    wbsElement!: string | undefined;
    asset!: string | undefined;
    fundsCenter!: string | undefined;
    remainQuantity!: number | undefined;
    createdDate!: DateTime;
    updatedDate!: DateTime;
    documentId!: string;
    id!: string | undefined;

    constructor(data?: ICreateOrEditZMM020RDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseRequisition = _data["purchaseRequisition"];
            this.documentType = _data["documentType"];
            this.documentTypeText = _data["documentTypeText"];
            this.itemRequisition = _data["itemRequisition"];
            this.processingStatusCode = _data["processingStatusCode"];
            this.processingStatus = _data["processingStatus"];
            this.deletionIndicator = _data["deletionIndicator"];
            this.itemCategory = _data["itemCategory"];
            this.accountAssignment = _data["accountAssignment"];
            this.material = _data["material"];
            this.shortText = _data["shortText"];
            this.quantityRequested = _data["quantityRequested"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.serviceItem = _data["serviceItem"];
            this.service = _data["service"];
            this.serviceShortText = _data["serviceShortText"];
            this.quantityService = _data["quantityService"];
            this.unitOfMeasureService = _data["unitOfMeasureService"];
            this.deliveryDate = _data["deliveryDate"] ? DateTime.fromISO(_data["deliveryDate"].toString()) : <any>undefined;
            this.materialGroup = _data["materialGroup"];
            this.plant = _data["plant"];
            this.storageLocation = _data["storageLocation"];
            this.purchaseGroup = _data["purchaseGroup"];
            this.requisitioner = _data["requisitioner"];
            this.requisitionerName = _data["requisitionerName"];
            this.purchasingDocument = _data["purchasingDocument"];
            this.purchaseOrderDate = _data["purchaseOrderDate"] ? DateTime.fromISO(_data["purchaseOrderDate"].toString()) : <any>undefined;
            this.outlineAgreement = _data["outlineAgreement"];
            this.princAgreementItem = _data["princAgreementItem"];
            this.purchasingInfoRec = _data["purchasingInfoRec"];
            this.status = _data["status"];
            this.createdBy = _data["createdBy"];
            this.currency = _data["currency"];
            this.entrySheet = _data["entrySheet"];
            this.goodsReceipt = _data["goodsReceipt"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.releaseIndicator = _data["releaseIndicator"];
            this.unitPrice = _data["unitPrice"];
            this.valuationPrice = _data["valuationPrice"];
            this.itemText = _data["itemText"];
            this.longText = _data["longText"];
            this.firstApprovalDate = _data["firstApprovalDate"] ? DateTime.fromISO(_data["firstApprovalDate"].toString()) : <any>undefined;
            this.firstApprovalName = _data["firstApprovalName"];
            this.lastApprovalDate = _data["lastApprovalDate"] ? DateTime.fromISO(_data["lastApprovalDate"].toString()) : <any>undefined;
            this.lastApprovalName = _data["lastApprovalName"];
            this.costCenter = _data["costCenter"];
            this.costCenterDescription = _data["costCenterDescription"];
            this.wbsElement = _data["wbsElement"];
            this.asset = _data["asset"];
            this.fundsCenter = _data["fundsCenter"];
            this.remainQuantity = _data["remainQuantity"];
            this.createdDate = _data["createdDate"] ? DateTime.fromISO(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? DateTime.fromISO(_data["updatedDate"].toString()) : <any>undefined;
            this.documentId = _data["documentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditZMM020RDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditZMM020RDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseRequisition"] = this.purchaseRequisition;
        data["documentType"] = this.documentType;
        data["documentTypeText"] = this.documentTypeText;
        data["itemRequisition"] = this.itemRequisition;
        data["processingStatusCode"] = this.processingStatusCode;
        data["processingStatus"] = this.processingStatus;
        data["deletionIndicator"] = this.deletionIndicator;
        data["itemCategory"] = this.itemCategory;
        data["accountAssignment"] = this.accountAssignment;
        data["material"] = this.material;
        data["shortText"] = this.shortText;
        data["quantityRequested"] = this.quantityRequested;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["serviceItem"] = this.serviceItem;
        data["service"] = this.service;
        data["serviceShortText"] = this.serviceShortText;
        data["quantityService"] = this.quantityService;
        data["unitOfMeasureService"] = this.unitOfMeasureService;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toString() : <any>undefined;
        data["materialGroup"] = this.materialGroup;
        data["plant"] = this.plant;
        data["storageLocation"] = this.storageLocation;
        data["purchaseGroup"] = this.purchaseGroup;
        data["requisitioner"] = this.requisitioner;
        data["requisitionerName"] = this.requisitionerName;
        data["purchasingDocument"] = this.purchasingDocument;
        data["purchaseOrderDate"] = this.purchaseOrderDate ? this.purchaseOrderDate.toString() : <any>undefined;
        data["outlineAgreement"] = this.outlineAgreement;
        data["princAgreementItem"] = this.princAgreementItem;
        data["purchasingInfoRec"] = this.purchasingInfoRec;
        data["status"] = this.status;
        data["createdBy"] = this.createdBy;
        data["currency"] = this.currency;
        data["entrySheet"] = this.entrySheet;
        data["goodsReceipt"] = this.goodsReceipt;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["releaseIndicator"] = this.releaseIndicator;
        data["unitPrice"] = this.unitPrice;
        data["valuationPrice"] = this.valuationPrice;
        data["itemText"] = this.itemText;
        data["longText"] = this.longText;
        data["firstApprovalDate"] = this.firstApprovalDate ? this.firstApprovalDate.toString() : <any>undefined;
        data["firstApprovalName"] = this.firstApprovalName;
        data["lastApprovalDate"] = this.lastApprovalDate ? this.lastApprovalDate.toString() : <any>undefined;
        data["lastApprovalName"] = this.lastApprovalName;
        data["costCenter"] = this.costCenter;
        data["costCenterDescription"] = this.costCenterDescription;
        data["wbsElement"] = this.wbsElement;
        data["asset"] = this.asset;
        data["fundsCenter"] = this.fundsCenter;
        data["remainQuantity"] = this.remainQuantity;
        data["createdDate"] = this.createdDate ? this.createdDate.toString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toString() : <any>undefined;
        data["documentId"] = this.documentId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditZMM020RDto {
    purchaseRequisition: string;
    documentType: string;
    documentTypeText: string;
    itemRequisition: string;
    processingStatusCode: string | undefined;
    processingStatus: string | undefined;
    deletionIndicator: string | undefined;
    itemCategory: string | undefined;
    accountAssignment: string | undefined;
    material: string | undefined;
    shortText: string | undefined;
    quantityRequested: number | undefined;
    unitOfMeasure: string | undefined;
    serviceItem: string | undefined;
    service: string | undefined;
    serviceShortText: string | undefined;
    quantityService: number | undefined;
    unitOfMeasureService: string | undefined;
    deliveryDate: DateTime | undefined;
    materialGroup: string | undefined;
    plant: string | undefined;
    storageLocation: string | undefined;
    purchaseGroup: string | undefined;
    requisitioner: string | undefined;
    requisitionerName: string | undefined;
    purchasingDocument: string | undefined;
    purchaseOrderDate: DateTime | undefined;
    outlineAgreement: string | undefined;
    princAgreementItem: string | undefined;
    purchasingInfoRec: string | undefined;
    status: string | undefined;
    createdBy: string | undefined;
    currency: string | undefined;
    entrySheet: string | undefined;
    goodsReceipt: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    releaseIndicator: string | undefined;
    unitPrice: number | undefined;
    valuationPrice: number | undefined;
    itemText: string | undefined;
    longText: string | undefined;
    firstApprovalDate: DateTime | undefined;
    firstApprovalName: string | undefined;
    lastApprovalDate: DateTime | undefined;
    lastApprovalName: string | undefined;
    costCenter: string | undefined;
    costCenterDescription: string | undefined;
    wbsElement: string | undefined;
    asset: string | undefined;
    fundsCenter: string | undefined;
    remainQuantity: number | undefined;
    createdDate: DateTime;
    updatedDate: DateTime;
    documentId: string;
    id: string | undefined;
}

export class CreateOrEditZMM021RDto implements ICreateOrEditZMM021RDto {
    purchasingDocument!: string;
    purchasingDocType!: string;
    purchasingDocTypeDescription!: string | undefined;
    item!: string;
    lineNumber!: string | undefined;
    deletionIndicator!: string | undefined;
    documentDate!: DateTime;
    createdOn!: DateTime;
    purchaseRequisition!: string | undefined;
    itemPR!: string | undefined;
    supplierCode!: string | undefined;
    supplierName!: string | undefined;
    address!: string | undefined;
    itemNo!: string | undefined;
    materialGroup!: string | undefined;
    shortText!: string | undefined;
    orderQuantity!: number | undefined;
    orderUnit!: string | undefined;
    currency!: string | undefined;
    deliveryDate!: DateTime | undefined;
    netPrice!: number | undefined;
    netOrderValue!: number | undefined;
    demurrage!: number | undefined;
    grossPrice!: number | undefined;
    totalDiscount!: number | undefined;
    freightCost!: number | undefined;
    releaseIndicator!: string | undefined;
    plant!: string | undefined;
    purchasingGroup!: string | undefined;
    taxCode!: string | undefined;
    collectiveNumber!: string | undefined;
    itemCategory!: string | undefined;
    accountAssignment!: string | undefined;
    outlineAgreement!: string | undefined;
    rfqNo!: string | undefined;
    qtyPending!: number | undefined;
    materialService!: string | undefined;
    approvalStatus!: string | undefined;
    poStatus!: string | undefined;
    period!: string | undefined;
    commentVendor!: string | undefined;
    itemText!: string | undefined;
    longText!: string | undefined;
    ourReference!: string | undefined;
    prFinalFirstApprovalDate!: DateTime | undefined;
    prFinalLastApprovalDate!: DateTime | undefined;
    poFirstApprovalDate!: DateTime | undefined;
    poLastApprovalDate!: DateTime | undefined;
    poApprovalName!: string | undefined;
    buyerCode!: string | undefined;
    buyerName!: string | undefined;
    picDept!: string | undefined;
    picSect!: string | undefined;
    fuelAllocation!: string | undefined;
    costCenter!: string | undefined;
    costCenterDescription!: string | undefined;
    wbsElement!: string | undefined;
    assetNo!: string | undefined;
    fundCenter!: string | undefined;
    createdDate!: DateTime;
    updatedDate!: DateTime;
    documentId!: string;
    id!: string | undefined;

    constructor(data?: ICreateOrEditZMM021RDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchasingDocument = _data["purchasingDocument"];
            this.purchasingDocType = _data["purchasingDocType"];
            this.purchasingDocTypeDescription = _data["purchasingDocTypeDescription"];
            this.item = _data["item"];
            this.lineNumber = _data["lineNumber"];
            this.deletionIndicator = _data["deletionIndicator"];
            this.documentDate = _data["documentDate"] ? DateTime.fromISO(_data["documentDate"].toString()) : <any>undefined;
            this.createdOn = _data["createdOn"] ? DateTime.fromISO(_data["createdOn"].toString()) : <any>undefined;
            this.purchaseRequisition = _data["purchaseRequisition"];
            this.itemPR = _data["itemPR"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.address = _data["address"];
            this.itemNo = _data["itemNo"];
            this.materialGroup = _data["materialGroup"];
            this.shortText = _data["shortText"];
            this.orderQuantity = _data["orderQuantity"];
            this.orderUnit = _data["orderUnit"];
            this.currency = _data["currency"];
            this.deliveryDate = _data["deliveryDate"] ? DateTime.fromISO(_data["deliveryDate"].toString()) : <any>undefined;
            this.netPrice = _data["netPrice"];
            this.netOrderValue = _data["netOrderValue"];
            this.demurrage = _data["demurrage"];
            this.grossPrice = _data["grossPrice"];
            this.totalDiscount = _data["totalDiscount"];
            this.freightCost = _data["freightCost"];
            this.releaseIndicator = _data["releaseIndicator"];
            this.plant = _data["plant"];
            this.purchasingGroup = _data["purchasingGroup"];
            this.taxCode = _data["taxCode"];
            this.collectiveNumber = _data["collectiveNumber"];
            this.itemCategory = _data["itemCategory"];
            this.accountAssignment = _data["accountAssignment"];
            this.outlineAgreement = _data["outlineAgreement"];
            this.rfqNo = _data["rfqNo"];
            this.qtyPending = _data["qtyPending"];
            this.materialService = _data["materialService"];
            this.approvalStatus = _data["approvalStatus"];
            this.poStatus = _data["poStatus"];
            this.period = _data["period"];
            this.commentVendor = _data["commentVendor"];
            this.itemText = _data["itemText"];
            this.longText = _data["longText"];
            this.ourReference = _data["ourReference"];
            this.prFinalFirstApprovalDate = _data["prFinalFirstApprovalDate"] ? DateTime.fromISO(_data["prFinalFirstApprovalDate"].toString()) : <any>undefined;
            this.prFinalLastApprovalDate = _data["prFinalLastApprovalDate"] ? DateTime.fromISO(_data["prFinalLastApprovalDate"].toString()) : <any>undefined;
            this.poFirstApprovalDate = _data["poFirstApprovalDate"] ? DateTime.fromISO(_data["poFirstApprovalDate"].toString()) : <any>undefined;
            this.poLastApprovalDate = _data["poLastApprovalDate"] ? DateTime.fromISO(_data["poLastApprovalDate"].toString()) : <any>undefined;
            this.poApprovalName = _data["poApprovalName"];
            this.buyerCode = _data["buyerCode"];
            this.buyerName = _data["buyerName"];
            this.picDept = _data["picDept"];
            this.picSect = _data["picSect"];
            this.fuelAllocation = _data["fuelAllocation"];
            this.costCenter = _data["costCenter"];
            this.costCenterDescription = _data["costCenterDescription"];
            this.wbsElement = _data["wbsElement"];
            this.assetNo = _data["assetNo"];
            this.fundCenter = _data["fundCenter"];
            this.createdDate = _data["createdDate"] ? DateTime.fromISO(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? DateTime.fromISO(_data["updatedDate"].toString()) : <any>undefined;
            this.documentId = _data["documentId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditZMM021RDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditZMM021RDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchasingDocument"] = this.purchasingDocument;
        data["purchasingDocType"] = this.purchasingDocType;
        data["purchasingDocTypeDescription"] = this.purchasingDocTypeDescription;
        data["item"] = this.item;
        data["lineNumber"] = this.lineNumber;
        data["deletionIndicator"] = this.deletionIndicator;
        data["documentDate"] = this.documentDate ? this.documentDate.toString() : <any>undefined;
        data["createdOn"] = this.createdOn ? this.createdOn.toString() : <any>undefined;
        data["purchaseRequisition"] = this.purchaseRequisition;
        data["itemPR"] = this.itemPR;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["address"] = this.address;
        data["itemNo"] = this.itemNo;
        data["materialGroup"] = this.materialGroup;
        data["shortText"] = this.shortText;
        data["orderQuantity"] = this.orderQuantity;
        data["orderUnit"] = this.orderUnit;
        data["currency"] = this.currency;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toString() : <any>undefined;
        data["netPrice"] = this.netPrice;
        data["netOrderValue"] = this.netOrderValue;
        data["demurrage"] = this.demurrage;
        data["grossPrice"] = this.grossPrice;
        data["totalDiscount"] = this.totalDiscount;
        data["freightCost"] = this.freightCost;
        data["releaseIndicator"] = this.releaseIndicator;
        data["plant"] = this.plant;
        data["purchasingGroup"] = this.purchasingGroup;
        data["taxCode"] = this.taxCode;
        data["collectiveNumber"] = this.collectiveNumber;
        data["itemCategory"] = this.itemCategory;
        data["accountAssignment"] = this.accountAssignment;
        data["outlineAgreement"] = this.outlineAgreement;
        data["rfqNo"] = this.rfqNo;
        data["qtyPending"] = this.qtyPending;
        data["materialService"] = this.materialService;
        data["approvalStatus"] = this.approvalStatus;
        data["poStatus"] = this.poStatus;
        data["period"] = this.period;
        data["commentVendor"] = this.commentVendor;
        data["itemText"] = this.itemText;
        data["longText"] = this.longText;
        data["ourReference"] = this.ourReference;
        data["prFinalFirstApprovalDate"] = this.prFinalFirstApprovalDate ? this.prFinalFirstApprovalDate.toString() : <any>undefined;
        data["prFinalLastApprovalDate"] = this.prFinalLastApprovalDate ? this.prFinalLastApprovalDate.toString() : <any>undefined;
        data["poFirstApprovalDate"] = this.poFirstApprovalDate ? this.poFirstApprovalDate.toString() : <any>undefined;
        data["poLastApprovalDate"] = this.poLastApprovalDate ? this.poLastApprovalDate.toString() : <any>undefined;
        data["poApprovalName"] = this.poApprovalName;
        data["buyerCode"] = this.buyerCode;
        data["buyerName"] = this.buyerName;
        data["picDept"] = this.picDept;
        data["picSect"] = this.picSect;
        data["fuelAllocation"] = this.fuelAllocation;
        data["costCenter"] = this.costCenter;
        data["costCenterDescription"] = this.costCenterDescription;
        data["wbsElement"] = this.wbsElement;
        data["assetNo"] = this.assetNo;
        data["fundCenter"] = this.fundCenter;
        data["createdDate"] = this.createdDate ? this.createdDate.toString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toString() : <any>undefined;
        data["documentId"] = this.documentId;
        data["id"] = this.id;
        return data;
    }
}

export interface ICreateOrEditZMM021RDto {
    purchasingDocument: string;
    purchasingDocType: string;
    purchasingDocTypeDescription: string | undefined;
    item: string;
    lineNumber: string | undefined;
    deletionIndicator: string | undefined;
    documentDate: DateTime;
    createdOn: DateTime;
    purchaseRequisition: string | undefined;
    itemPR: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    address: string | undefined;
    itemNo: string | undefined;
    materialGroup: string | undefined;
    shortText: string | undefined;
    orderQuantity: number | undefined;
    orderUnit: string | undefined;
    currency: string | undefined;
    deliveryDate: DateTime | undefined;
    netPrice: number | undefined;
    netOrderValue: number | undefined;
    demurrage: number | undefined;
    grossPrice: number | undefined;
    totalDiscount: number | undefined;
    freightCost: number | undefined;
    releaseIndicator: string | undefined;
    plant: string | undefined;
    purchasingGroup: string | undefined;
    taxCode: string | undefined;
    collectiveNumber: string | undefined;
    itemCategory: string | undefined;
    accountAssignment: string | undefined;
    outlineAgreement: string | undefined;
    rfqNo: string | undefined;
    qtyPending: number | undefined;
    materialService: string | undefined;
    approvalStatus: string | undefined;
    poStatus: string | undefined;
    period: string | undefined;
    commentVendor: string | undefined;
    itemText: string | undefined;
    longText: string | undefined;
    ourReference: string | undefined;
    prFinalFirstApprovalDate: DateTime | undefined;
    prFinalLastApprovalDate: DateTime | undefined;
    poFirstApprovalDate: DateTime | undefined;
    poLastApprovalDate: DateTime | undefined;
    poApprovalName: string | undefined;
    buyerCode: string | undefined;
    buyerName: string | undefined;
    picDept: string | undefined;
    picSect: string | undefined;
    fuelAllocation: string | undefined;
    costCenter: string | undefined;
    costCenterDescription: string | undefined;
    wbsElement: string | undefined;
    assetNo: string | undefined;
    fundCenter: string | undefined;
    createdDate: DateTime;
    updatedDate: DateTime;
    documentId: string;
    id: string | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : new RoleEditDto();
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean;
    setRandomPassword!: boolean;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : new UserEditDto();
            if (Array.isArray(_data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of _data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.setRandomPassword = _data["setRandomPassword"];
            if (Array.isArray(_data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of _data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data;
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean;
    setRandomPassword: boolean;
    organizationUnits: number[] | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number;
    editionPaymentType!: EditionPaymentType;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled!: boolean;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.editionId = _data["editionId"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = _data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = _data["recurringPaymentEnabled"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data;
    }
}

export interface ICreatePaymentDto {
    editionId: number;
    editionPaymentType: EditionPaymentType;
    paymentPeriodType: PaymentPeriodType;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType;
    recurringPaymentEnabled: boolean;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminName!: string | undefined;
    adminSurname!: string | undefined;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean;
    sendActivationEmail!: boolean;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminName = _data["adminName"];
            this.adminSurname = _data["adminSurname"];
            this.adminPassword = _data["adminPassword"];
            this.connectionString = _data["connectionString"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = _data["sendActivationEmail"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminName"] = this.adminName;
        data["adminSurname"] = this.adminSurname;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        return data;
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminName: string | undefined;
    adminSurname: string | undefined;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean;
    sendActivationEmail: boolean;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
}

export class CreateUserDelegationDto implements ICreateUserDelegationDto {
    targetUserId!: number;
    startTime!: DateTime;
    endTime!: DateTime;

    constructor(data?: ICreateUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetUserId = _data["targetUserId"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): CreateUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetUserId"] = this.targetUserId;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        return data;
    }
}

export interface ICreateUserDelegationDto {
    targetUserId: number;
    startTime: DateTime;
    endTime: DateTime;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.isPhoneNumberConfirmed = _data["isPhoneNumberConfirmed"];
            this.timezone = _data["timezone"];
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean;
}

export class Dashboard implements IDashboard {
    dashboardName!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: IDashboard) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Dashboard {
        data = typeof data === 'object' ? data : {};
        let result = new Dashboard();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDashboard {
    dashboardName: string | undefined;
    pages: Page[] | undefined;
}

export class DashboardOutput implements IDashboardOutput {
    name!: string | undefined;
    widgets!: WidgetOutput[] | undefined;

    constructor(data?: IDashboardOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(WidgetOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): DashboardOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DashboardOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IDashboardOutput {
    name: string | undefined;
    widgets: WidgetOutput[] | undefined;
}

export class DataProductionDto implements IDataProductionDto {
    materialDocument!: string | undefined;
    materialDocYear!: number;
    materialDocItem!: number;
    order!: string | undefined;
    reservation!: number;
    purchaseOrder!: string | undefined;
    movementType!: string | undefined;
    movementTypeText!: string | undefined;
    plant!: string | undefined;
    storageLocation!: string | undefined;
    material!: string | undefined;
    materialDescription!: string | undefined;
    quantity!: number;
    qtyInOrderUnit!: number;
    postingDate!: DateTime;
    entryDate!: DateTime;
    documentDate!: DateTime;
    batch!: string | undefined;
    id!: string;

    constructor(data?: IDataProductionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialDocument = _data["materialDocument"];
            this.materialDocYear = _data["materialDocYear"];
            this.materialDocItem = _data["materialDocItem"];
            this.order = _data["order"];
            this.reservation = _data["reservation"];
            this.purchaseOrder = _data["purchaseOrder"];
            this.movementType = _data["movementType"];
            this.movementTypeText = _data["movementTypeText"];
            this.plant = _data["plant"];
            this.storageLocation = _data["storageLocation"];
            this.material = _data["material"];
            this.materialDescription = _data["materialDescription"];
            this.quantity = _data["quantity"];
            this.qtyInOrderUnit = _data["qtyInOrderUnit"];
            this.postingDate = _data["postingDate"] ? DateTime.fromISO(_data["postingDate"].toString()) : <any>undefined;
            this.entryDate = _data["entryDate"] ? DateTime.fromISO(_data["entryDate"].toString()) : <any>undefined;
            this.documentDate = _data["documentDate"] ? DateTime.fromISO(_data["documentDate"].toString()) : <any>undefined;
            this.batch = _data["batch"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DataProductionDto {
        data = typeof data === 'object' ? data : {};
        let result = new DataProductionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialDocument"] = this.materialDocument;
        data["materialDocYear"] = this.materialDocYear;
        data["materialDocItem"] = this.materialDocItem;
        data["order"] = this.order;
        data["reservation"] = this.reservation;
        data["purchaseOrder"] = this.purchaseOrder;
        data["movementType"] = this.movementType;
        data["movementTypeText"] = this.movementTypeText;
        data["plant"] = this.plant;
        data["storageLocation"] = this.storageLocation;
        data["material"] = this.material;
        data["materialDescription"] = this.materialDescription;
        data["quantity"] = this.quantity;
        data["qtyInOrderUnit"] = this.qtyInOrderUnit;
        data["postingDate"] = this.postingDate ? this.postingDate.toString() : <any>undefined;
        data["entryDate"] = this.entryDate ? this.entryDate.toString() : <any>undefined;
        data["documentDate"] = this.documentDate ? this.documentDate.toString() : <any>undefined;
        data["batch"] = this.batch;
        data["id"] = this.id;
        return data;
    }
}

export interface IDataProductionDto {
    materialDocument: string | undefined;
    materialDocYear: number;
    materialDocItem: number;
    order: string | undefined;
    reservation: number;
    purchaseOrder: string | undefined;
    movementType: string | undefined;
    movementTypeText: string | undefined;
    plant: string | undefined;
    storageLocation: string | undefined;
    material: string | undefined;
    materialDescription: string | undefined;
    quantity: number;
    qtyInOrderUnit: number;
    postingDate: DateTime;
    entryDate: DateTime;
    documentDate: DateTime;
    batch: string | undefined;
    id: string;
}

export class DateFieldOutput implements IDateFieldOutput {
    date!: DateTime;

    constructor(data?: IDateFieldOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateFieldOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateFieldOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        return data;
    }
}

export interface IDateFieldOutput {
    date: DateTime;
}

export class DateRangeFieldOutput implements IDateRangeFieldOutput {
    startDate!: DateTime;
    endDate!: DateTime;

    constructor(data?: IDateRangeFieldOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.startDate = _data["startDate"] ? DateTime.fromISO(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? DateTime.fromISO(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateRangeFieldOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateRangeFieldOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toString() : <any>undefined;
        return data;
    }
}

export interface IDateRangeFieldOutput {
    startDate: DateTime;
    endDate: DateTime;
}

export class DateWithTextFieldOutput implements IDateWithTextFieldOutput {
    text!: string | undefined;
    date!: DateTime;

    constructor(data?: IDateWithTextFieldOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): DateWithTextFieldOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateWithTextFieldOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        return data;
    }
}

export interface IDateWithTextFieldOutput {
    text: string | undefined;
    date: DateTime;
}

export class DelegatedImpersonateInput implements IDelegatedImpersonateInput {
    userDelegationId!: number;

    constructor(data?: IDelegatedImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userDelegationId = _data["userDelegationId"];
        }
    }

    static fromJS(data: any): DelegatedImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new DelegatedImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userDelegationId"] = this.userDelegationId;
        return data;
    }
}

export interface IDelegatedImpersonateInput {
    userDelegationId: number;
}

export class DtoResponseModel implements IDtoResponseModel {
    message!: string | undefined;
    isSuccess!: boolean;
    isResponse!: boolean;
    responseObject!: string | undefined;

    constructor(data?: IDtoResponseModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.isSuccess = _data["isSuccess"];
            this.isResponse = _data["isResponse"];
            this.responseObject = _data["responseObject"];
        }
    }

    static fromJS(data: any): DtoResponseModel {
        data = typeof data === 'object' ? data : {};
        let result = new DtoResponseModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["isSuccess"] = this.isSuccess;
        data["isResponse"] = this.isResponse;
        data["responseObject"] = this.responseObject;
        return data;
    }
}

export interface IDtoResponseModel {
    message: string | undefined;
    isSuccess: boolean;
    isResponse: boolean;
    responseObject: string | undefined;
}

export class DynamicEntityPropertyDto implements IDynamicEntityPropertyDto {
    entityFullName!: string | undefined;
    dynamicPropertyName!: string | undefined;
    dynamicPropertyId!: number;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IDynamicEntityPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityFullName = _data["entityFullName"];
            this.dynamicPropertyName = _data["dynamicPropertyName"];
            this.dynamicPropertyId = _data["dynamicPropertyId"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicEntityPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicEntityPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityFullName"] = this.entityFullName;
        data["dynamicPropertyName"] = this.dynamicPropertyName;
        data["dynamicPropertyId"] = this.dynamicPropertyId;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicEntityPropertyDto {
    entityFullName: string | undefined;
    dynamicPropertyName: string | undefined;
    dynamicPropertyId: number;
    tenantId: number | undefined;
    id: number;
}

export class DynamicEntityPropertyValueDto implements IDynamicEntityPropertyValueDto {
    value!: string | undefined;
    entityId!: string | undefined;
    dynamicEntityPropertyId!: number;
    id!: number;

    constructor(data?: IDynamicEntityPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.entityId = _data["entityId"];
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicEntityPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicEntityPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["entityId"] = this.entityId;
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicEntityPropertyValueDto {
    value: string | undefined;
    entityId: string | undefined;
    dynamicEntityPropertyId: number;
    id: number;
}

export class DynamicPropertyDto implements IDynamicPropertyDto {
    propertyName!: string | undefined;
    displayName!: string | undefined;
    inputType!: string | undefined;
    permission!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IDynamicPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.propertyName = _data["propertyName"];
            this.displayName = _data["displayName"];
            this.inputType = _data["inputType"];
            this.permission = _data["permission"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["propertyName"] = this.propertyName;
        data["displayName"] = this.displayName;
        data["inputType"] = this.inputType;
        data["permission"] = this.permission;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicPropertyDto {
    propertyName: string | undefined;
    displayName: string | undefined;
    inputType: string | undefined;
    permission: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class DynamicPropertyValueDto implements IDynamicPropertyValueDto {
    value!: string | undefined;
    tenantId!: number | undefined;
    dynamicPropertyId!: number;
    id!: number;

    constructor(data?: IDynamicPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.tenantId = _data["tenantId"];
            this.dynamicPropertyId = _data["dynamicPropertyId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): DynamicPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new DynamicPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["tenantId"] = this.tenantId;
        data["dynamicPropertyId"] = this.dynamicPropertyId;
        data["id"] = this.id;
        return data;
    }
}

export interface IDynamicPropertyValueDto {
    value: string | undefined;
    tenantId: number | undefined;
    dynamicPropertyId: number;
    id: number;
}

export class EKPODto implements IEKPODto {
    mandt!: string | undefined;
    ebeln!: string | undefined;
    ebelp!: number | undefined;
    uniqueid!: string | undefined;
    loekz!: string | undefined;
    aedat!: DateTime | undefined;
    txZ01!: string | undefined;
    matnr!: string | undefined;
    bukrs!: string | undefined;
    bednr!: string | undefined;
    matkl!: string | undefined;
    infnr!: string | undefined;
    idnlf!: string | undefined;
    ktmng!: number | undefined;
    menge!: number | undefined;
    meins!: string | undefined;
    bprme!: string | undefined;
    bpumz!: number | undefined;
    bpumn!: number | undefined;
    umrez!: number | undefined;
    umren!: number | undefined;
    netpr!: number | undefined;
    peinh!: number | undefined;
    netwr!: number | undefined;
    brtwr!: number | undefined;
    agdat!: DateTime | undefined;
    webaz!: number | undefined;
    mwskz!: string | undefined;
    bonus!: string | undefined;
    insmk!: string | undefined;
    spinf!: string | undefined;
    prsdr!: string | undefined;
    bwtar!: string | undefined;
    bwtty!: string | undefined;
    abskz!: string | undefined;
    pstyp!: string | undefined;
    knttp!: string | undefined;
    konnr!: string | undefined;
    ktpnr!: number | undefined;
    packno!: number | undefined;
    anfnr!: string | undefined;
    banfn!: string | undefined;
    bnfpo!: number | undefined;
    id!: string;

    constructor(data?: IEKPODto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mandt = _data["mandt"];
            this.ebeln = _data["ebeln"];
            this.ebelp = _data["ebelp"];
            this.uniqueid = _data["uniqueid"];
            this.loekz = _data["loekz"];
            this.aedat = _data["aedat"] ? DateTime.fromISO(_data["aedat"].toString()) : <any>undefined;
            this.txZ01 = _data["txZ01"];
            this.matnr = _data["matnr"];
            this.bukrs = _data["bukrs"];
            this.bednr = _data["bednr"];
            this.matkl = _data["matkl"];
            this.infnr = _data["infnr"];
            this.idnlf = _data["idnlf"];
            this.ktmng = _data["ktmng"];
            this.menge = _data["menge"];
            this.meins = _data["meins"];
            this.bprme = _data["bprme"];
            this.bpumz = _data["bpumz"];
            this.bpumn = _data["bpumn"];
            this.umrez = _data["umrez"];
            this.umren = _data["umren"];
            this.netpr = _data["netpr"];
            this.peinh = _data["peinh"];
            this.netwr = _data["netwr"];
            this.brtwr = _data["brtwr"];
            this.agdat = _data["agdat"] ? DateTime.fromISO(_data["agdat"].toString()) : <any>undefined;
            this.webaz = _data["webaz"];
            this.mwskz = _data["mwskz"];
            this.bonus = _data["bonus"];
            this.insmk = _data["insmk"];
            this.spinf = _data["spinf"];
            this.prsdr = _data["prsdr"];
            this.bwtar = _data["bwtar"];
            this.bwtty = _data["bwtty"];
            this.abskz = _data["abskz"];
            this.pstyp = _data["pstyp"];
            this.knttp = _data["knttp"];
            this.konnr = _data["konnr"];
            this.ktpnr = _data["ktpnr"];
            this.packno = _data["packno"];
            this.anfnr = _data["anfnr"];
            this.banfn = _data["banfn"];
            this.bnfpo = _data["bnfpo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EKPODto {
        data = typeof data === 'object' ? data : {};
        let result = new EKPODto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandt"] = this.mandt;
        data["ebeln"] = this.ebeln;
        data["ebelp"] = this.ebelp;
        data["uniqueid"] = this.uniqueid;
        data["loekz"] = this.loekz;
        data["aedat"] = this.aedat ? this.aedat.toString() : <any>undefined;
        data["txZ01"] = this.txZ01;
        data["matnr"] = this.matnr;
        data["bukrs"] = this.bukrs;
        data["bednr"] = this.bednr;
        data["matkl"] = this.matkl;
        data["infnr"] = this.infnr;
        data["idnlf"] = this.idnlf;
        data["ktmng"] = this.ktmng;
        data["menge"] = this.menge;
        data["meins"] = this.meins;
        data["bprme"] = this.bprme;
        data["bpumz"] = this.bpumz;
        data["bpumn"] = this.bpumn;
        data["umrez"] = this.umrez;
        data["umren"] = this.umren;
        data["netpr"] = this.netpr;
        data["peinh"] = this.peinh;
        data["netwr"] = this.netwr;
        data["brtwr"] = this.brtwr;
        data["agdat"] = this.agdat ? this.agdat.toString() : <any>undefined;
        data["webaz"] = this.webaz;
        data["mwskz"] = this.mwskz;
        data["bonus"] = this.bonus;
        data["insmk"] = this.insmk;
        data["spinf"] = this.spinf;
        data["prsdr"] = this.prsdr;
        data["bwtar"] = this.bwtar;
        data["bwtty"] = this.bwtty;
        data["abskz"] = this.abskz;
        data["pstyp"] = this.pstyp;
        data["knttp"] = this.knttp;
        data["konnr"] = this.konnr;
        data["ktpnr"] = this.ktpnr;
        data["packno"] = this.packno;
        data["anfnr"] = this.anfnr;
        data["banfn"] = this.banfn;
        data["bnfpo"] = this.bnfpo;
        data["id"] = this.id;
        return data;
    }
}

export interface IEKPODto {
    mandt: string | undefined;
    ebeln: string | undefined;
    ebelp: number | undefined;
    uniqueid: string | undefined;
    loekz: string | undefined;
    aedat: DateTime | undefined;
    txZ01: string | undefined;
    matnr: string | undefined;
    bukrs: string | undefined;
    bednr: string | undefined;
    matkl: string | undefined;
    infnr: string | undefined;
    idnlf: string | undefined;
    ktmng: number | undefined;
    menge: number | undefined;
    meins: string | undefined;
    bprme: string | undefined;
    bpumz: number | undefined;
    bpumn: number | undefined;
    umrez: number | undefined;
    umren: number | undefined;
    netpr: number | undefined;
    peinh: number | undefined;
    netwr: number | undefined;
    brtwr: number | undefined;
    agdat: DateTime | undefined;
    webaz: number | undefined;
    mwskz: string | undefined;
    bonus: string | undefined;
    insmk: string | undefined;
    spinf: string | undefined;
    prsdr: string | undefined;
    bwtar: string | undefined;
    bwtty: string | undefined;
    abskz: string | undefined;
    pstyp: string | undefined;
    knttp: string | undefined;
    konnr: string | undefined;
    ktpnr: number | undefined;
    packno: number | undefined;
    anfnr: string | undefined;
    banfn: string | undefined;
    bnfpo: number | undefined;
    id: string;
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data;
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean;
    isFree!: boolean;
    id!: number;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.trialDayCount = _data["trialDayCount"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.isHighestEdition = _data["isHighestEdition"];
            this.isFree = _data["isFree"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean;
    isFree: boolean;
    id: number;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.trialDayCount = _data["trialDayCount"];
            this.expiringEditionDisplayName = _data["expiringEditionDisplayName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data;
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number;
}

export enum EditionPaymentType {
    NewRegistration = 0,
    BuyNow = 1,
    Upgrade = 2,
    Extend = 3,
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.expiringEditionId = _data["expiringEditionId"];
            this.dailyPrice = _data["dailyPrice"];
            this.weeklyPrice = _data["weeklyPrice"];
            this.monthlyPrice = _data["monthlyPrice"];
            this.annualPrice = _data["annualPrice"];
            this.trialDayCount = _data["trialDayCount"];
            this.waitingDayAfterExpire = _data["waitingDayAfterExpire"];
            this.isFree = _data["isFree"];
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        return data;
    }
}

export interface IEditionSelectDto {
    id: number;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto;
    featureValues: NameValueDto[] | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["allFeatures"])) {
                this.allFeatures = [] as any;
                for (let item of _data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (Array.isArray(_data["editionsWithFeatures"])) {
                this.editionsWithFeatures = [] as any;
                for (let item of _data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allFeatures)) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (Array.isArray(this.editionsWithFeatures)) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        return data;
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
}

export class EkkoDto implements IEkkoDto {
    mandt!: string | undefined;
    ebeln!: string | undefined;
    bukrs!: string | undefined;
    bstyp!: string | undefined;
    aedat!: DateTime | undefined;
    zbD1T!: number | undefined;
    zbD2T!: number | undefined;
    zbD3T!: number | undefined;
    ekgrp!: string | undefined;
    wkurs!: number | undefined;
    kufix!: string | undefined;
    bedat!: DateTime | undefined;
    kdatb!: DateTime | undefined;
    kdate!: DateTime | undefined;
    bwbdt!: DateTime | undefined;
    gwldt!: DateTime | undefined;
    ihran!: DateTime | undefined;
    kunnr!: string | undefined;
    konnr!: string | undefined;
    abgru!: string | undefined;
    autlf!: string | undefined;
    weakt!: string | undefined;
    reswk!: string | undefined;
    lblif!: string | undefined;
    incO1!: string | undefined;
    incO2!: string | undefined;
    submi!: string | undefined;
    knumv!: string | undefined;
    id!: string;

    constructor(data?: IEkkoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mandt = _data["mandt"];
            this.ebeln = _data["ebeln"];
            this.bukrs = _data["bukrs"];
            this.bstyp = _data["bstyp"];
            this.aedat = _data["aedat"] ? DateTime.fromISO(_data["aedat"].toString()) : <any>undefined;
            this.zbD1T = _data["zbD1T"];
            this.zbD2T = _data["zbD2T"];
            this.zbD3T = _data["zbD3T"];
            this.ekgrp = _data["ekgrp"];
            this.wkurs = _data["wkurs"];
            this.kufix = _data["kufix"];
            this.bedat = _data["bedat"] ? DateTime.fromISO(_data["bedat"].toString()) : <any>undefined;
            this.kdatb = _data["kdatb"] ? DateTime.fromISO(_data["kdatb"].toString()) : <any>undefined;
            this.kdate = _data["kdate"] ? DateTime.fromISO(_data["kdate"].toString()) : <any>undefined;
            this.bwbdt = _data["bwbdt"] ? DateTime.fromISO(_data["bwbdt"].toString()) : <any>undefined;
            this.gwldt = _data["gwldt"] ? DateTime.fromISO(_data["gwldt"].toString()) : <any>undefined;
            this.ihran = _data["ihran"] ? DateTime.fromISO(_data["ihran"].toString()) : <any>undefined;
            this.kunnr = _data["kunnr"];
            this.konnr = _data["konnr"];
            this.abgru = _data["abgru"];
            this.autlf = _data["autlf"];
            this.weakt = _data["weakt"];
            this.reswk = _data["reswk"];
            this.lblif = _data["lblif"];
            this.incO1 = _data["incO1"];
            this.incO2 = _data["incO2"];
            this.submi = _data["submi"];
            this.knumv = _data["knumv"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EkkoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EkkoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mandt"] = this.mandt;
        data["ebeln"] = this.ebeln;
        data["bukrs"] = this.bukrs;
        data["bstyp"] = this.bstyp;
        data["aedat"] = this.aedat ? this.aedat.toString() : <any>undefined;
        data["zbD1T"] = this.zbD1T;
        data["zbD2T"] = this.zbD2T;
        data["zbD3T"] = this.zbD3T;
        data["ekgrp"] = this.ekgrp;
        data["wkurs"] = this.wkurs;
        data["kufix"] = this.kufix;
        data["bedat"] = this.bedat ? this.bedat.toString() : <any>undefined;
        data["kdatb"] = this.kdatb ? this.kdatb.toString() : <any>undefined;
        data["kdate"] = this.kdate ? this.kdate.toString() : <any>undefined;
        data["bwbdt"] = this.bwbdt ? this.bwbdt.toString() : <any>undefined;
        data["gwldt"] = this.gwldt ? this.gwldt.toString() : <any>undefined;
        data["ihran"] = this.ihran ? this.ihran.toString() : <any>undefined;
        data["kunnr"] = this.kunnr;
        data["konnr"] = this.konnr;
        data["abgru"] = this.abgru;
        data["autlf"] = this.autlf;
        data["weakt"] = this.weakt;
        data["reswk"] = this.reswk;
        data["lblif"] = this.lblif;
        data["incO1"] = this.incO1;
        data["incO2"] = this.incO2;
        data["submi"] = this.submi;
        data["knumv"] = this.knumv;
        data["id"] = this.id;
        return data;
    }
}

export interface IEkkoDto {
    mandt: string | undefined;
    ebeln: string | undefined;
    bukrs: string | undefined;
    bstyp: string | undefined;
    aedat: DateTime | undefined;
    zbD1T: number | undefined;
    zbD2T: number | undefined;
    zbD3T: number | undefined;
    ekgrp: string | undefined;
    wkurs: number | undefined;
    kufix: string | undefined;
    bedat: DateTime | undefined;
    kdatb: DateTime | undefined;
    kdate: DateTime | undefined;
    bwbdt: DateTime | undefined;
    gwldt: DateTime | undefined;
    ihran: DateTime | undefined;
    kunnr: string | undefined;
    konnr: string | undefined;
    abgru: string | undefined;
    autlf: string | undefined;
    weakt: string | undefined;
    reswk: string | undefined;
    lblif: string | undefined;
    incO1: string | undefined;
    incO2: string | undefined;
    submi: string | undefined;
    knumv: string | undefined;
    id: string;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: DateTime;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number;
    id!: number;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.changeTime = _data["changeTime"] ? DateTime.fromISO(_data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = _data["entityTypeFullName"];
            this.changeType = _data["changeType"];
            (<any>this).changeTypeName = _data["changeTypeName"];
            this.entityChangeSetId = _data["entityChangeSetId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: DateTime;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType;
    changeTypeName: string | undefined;
    entityChangeSetId: number;
    id: number;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityDto implements IEntityDto {
    id!: number;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDto {
    id: number;
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfGuid {
    id: string;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfInt64 {
    id: number;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityChangeId = _data["entityChangeId"];
            this.newValue = _data["newValue"];
            this.originalValue = _data["originalValue"];
            this.propertyName = _data["propertyName"];
            this.propertyTypeFullName = _data["propertyTypeFullName"];
            this.tenantId = _data["tenantId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data;
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number;
}

export class EnumTableDto implements IEnumTableDto {
    enumCode!: string | undefined;
    enumValue!: string | undefined;
    enumLabel!: string | undefined;
    id!: string;

    constructor(data?: IEnumTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enumCode = _data["enumCode"];
            this.enumValue = _data["enumValue"];
            this.enumLabel = _data["enumLabel"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): EnumTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EnumTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enumCode"] = this.enumCode;
        data["enumValue"] = this.enumValue;
        data["enumLabel"] = this.enumLabel;
        data["id"] = this.id;
        return data;
    }
}

export interface IEnumTableDto {
    enumCode: string | undefined;
    enumValue: string | undefined;
    enumLabel: string | undefined;
    id: string;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantName = _data["tenantName"];
            this.remainingDayCount = _data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data;
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.authProvider = _data["authProvider"];
            this.providerKey = _data["providerKey"];
            this.providerAccessCode = _data["providerAccessCode"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data;
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;
    waitingForActivation!: boolean;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;
    refreshTokenExpireInSeconds!: number;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
            this.waitingForActivation = _data["waitingForActivation"];
            this.returnUrl = _data["returnUrl"];
            this.refreshToken = _data["refreshToken"];
            this.refreshTokenExpireInSeconds = _data["refreshTokenExpireInSeconds"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        data["refreshTokenExpireInSeconds"] = this.refreshTokenExpireInSeconds;
        return data;
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
    waitingForActivation: boolean;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
    refreshTokenExpireInSeconds: number;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string]: string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.clientId = _data["clientId"];
            if (_data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in _data["additionalParams"]) {
                    if (_data["additionalParams"].hasOwnProperty(key))
                        (<any>this.additionalParams)![key] = _data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    (<any>data["additionalParams"])[key] = (<any>this.additionalParams)[key];
            }
        }
        return data;
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string]: string; } | undefined;
}

export class ExternalLoginProviderSettingsEditDto implements IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated!: boolean;
    facebook!: FacebookExternalLoginProviderSettings;
    google_IsDeactivated!: boolean;
    google!: GoogleExternalLoginProviderSettings;
    twitter_IsDeactivated!: boolean;
    twitter!: TwitterExternalLoginProviderSettings;
    microsoft_IsDeactivated!: boolean;
    microsoft!: MicrosoftExternalLoginProviderSettings;
    openIdConnect_IsDeactivated!: boolean;
    openIdConnect!: OpenIdConnectExternalLoginProviderSettings;
    openIdConnectClaimsMapping!: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated!: boolean;
    wsFederation!: WsFederationExternalLoginProviderSettings;
    wsFederationClaimsMapping!: JsonClaimMapDto[] | undefined;

    constructor(data?: IExternalLoginProviderSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.facebook_IsDeactivated = _data["facebook_IsDeactivated"];
            this.facebook = _data["facebook"] ? FacebookExternalLoginProviderSettings.fromJS(_data["facebook"]) : <any>undefined;
            this.google_IsDeactivated = _data["google_IsDeactivated"];
            this.google = _data["google"] ? GoogleExternalLoginProviderSettings.fromJS(_data["google"]) : <any>undefined;
            this.twitter_IsDeactivated = _data["twitter_IsDeactivated"];
            this.twitter = _data["twitter"] ? TwitterExternalLoginProviderSettings.fromJS(_data["twitter"]) : <any>undefined;
            this.microsoft_IsDeactivated = _data["microsoft_IsDeactivated"];
            this.microsoft = _data["microsoft"] ? MicrosoftExternalLoginProviderSettings.fromJS(_data["microsoft"]) : <any>undefined;
            this.openIdConnect_IsDeactivated = _data["openIdConnect_IsDeactivated"];
            this.openIdConnect = _data["openIdConnect"] ? OpenIdConnectExternalLoginProviderSettings.fromJS(_data["openIdConnect"]) : <any>undefined;
            if (Array.isArray(_data["openIdConnectClaimsMapping"])) {
                this.openIdConnectClaimsMapping = [] as any;
                for (let item of _data["openIdConnectClaimsMapping"])
                    this.openIdConnectClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
            this.wsFederation_IsDeactivated = _data["wsFederation_IsDeactivated"];
            this.wsFederation = _data["wsFederation"] ? WsFederationExternalLoginProviderSettings.fromJS(_data["wsFederation"]) : <any>undefined;
            if (Array.isArray(_data["wsFederationClaimsMapping"])) {
                this.wsFederationClaimsMapping = [] as any;
                for (let item of _data["wsFederationClaimsMapping"])
                    this.wsFederationClaimsMapping!.push(JsonClaimMapDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["facebook_IsDeactivated"] = this.facebook_IsDeactivated;
        data["facebook"] = this.facebook ? this.facebook.toJSON() : <any>undefined;
        data["google_IsDeactivated"] = this.google_IsDeactivated;
        data["google"] = this.google ? this.google.toJSON() : <any>undefined;
        data["twitter_IsDeactivated"] = this.twitter_IsDeactivated;
        data["twitter"] = this.twitter ? this.twitter.toJSON() : <any>undefined;
        data["microsoft_IsDeactivated"] = this.microsoft_IsDeactivated;
        data["microsoft"] = this.microsoft ? this.microsoft.toJSON() : <any>undefined;
        data["openIdConnect_IsDeactivated"] = this.openIdConnect_IsDeactivated;
        data["openIdConnect"] = this.openIdConnect ? this.openIdConnect.toJSON() : <any>undefined;
        if (Array.isArray(this.openIdConnectClaimsMapping)) {
            data["openIdConnectClaimsMapping"] = [];
            for (let item of this.openIdConnectClaimsMapping)
                data["openIdConnectClaimsMapping"].push(item.toJSON());
        }
        data["wsFederation_IsDeactivated"] = this.wsFederation_IsDeactivated;
        data["wsFederation"] = this.wsFederation ? this.wsFederation.toJSON() : <any>undefined;
        if (Array.isArray(this.wsFederationClaimsMapping)) {
            data["wsFederationClaimsMapping"] = [];
            for (let item of this.wsFederationClaimsMapping)
                data["wsFederationClaimsMapping"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExternalLoginProviderSettingsEditDto {
    facebook_IsDeactivated: boolean;
    facebook: FacebookExternalLoginProviderSettings;
    google_IsDeactivated: boolean;
    google: GoogleExternalLoginProviderSettings;
    twitter_IsDeactivated: boolean;
    twitter: TwitterExternalLoginProviderSettings;
    microsoft_IsDeactivated: boolean;
    microsoft: MicrosoftExternalLoginProviderSettings;
    openIdConnect_IsDeactivated: boolean;
    openIdConnect: OpenIdConnectExternalLoginProviderSettings;
    openIdConnectClaimsMapping: JsonClaimMapDto[] | undefined;
    wsFederation_IsDeactivated: boolean;
    wsFederation: WsFederationExternalLoginProviderSettings;
    wsFederationClaimsMapping: JsonClaimMapDto[] | undefined;
}

export class ExternalLoginSettingsDto implements IExternalLoginSettingsDto {
    enabledSocialLoginSettings!: string[] | undefined;

    constructor(data?: IExternalLoginSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["enabledSocialLoginSettings"])) {
                this.enabledSocialLoginSettings = [] as any;
                for (let item of _data["enabledSocialLoginSettings"])
                    this.enabledSocialLoginSettings!.push(item);
            }
        }
    }

    static fromJS(data: any): ExternalLoginSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.enabledSocialLoginSettings)) {
            data["enabledSocialLoginSettings"] = [];
            for (let item of this.enabledSocialLoginSettings)
                data["enabledSocialLoginSettings"].push(item);
        }
        return data;
    }
}

export interface IExternalLoginSettingsDto {
    enabledSocialLoginSettings: string[] | undefined;
}

export class FacebookExternalLoginProviderSettings implements IFacebookExternalLoginProviderSettings {
    appId!: string | undefined;
    appSecret!: string | undefined;

    constructor(data?: IFacebookExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.appId = _data["appId"];
            this.appSecret = _data["appSecret"];
        }
    }

    static fromJS(data: any): FacebookExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new FacebookExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["appId"] = this.appId;
        data["appSecret"] = this.appSecret;
        return data;
    }
}

export interface IFacebookExternalLoginProviderSettings {
    appId: string | undefined;
    appSecret: string | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;
    itemSource!: LocalizableComboboxItemSourceDto;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            if (_data["attributes"]) {
                this.attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>this.attributes)![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
            this.itemSource = _data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(_data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
    itemSource: LocalizableComboboxItemSourceDto;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileName = _data["fileName"];
            this.fileType = _data["fileType"];
            this.fileToken = _data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data;
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.organizationUnitId = _data["organizationUnitId"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    excludeCurrentUser!: boolean;
    maxResultCount!: number;
    skipCount!: number;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.excludeCurrentUser = _data["excludeCurrentUser"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
            this.filter = _data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["excludeCurrentUser"] = this.excludeCurrentUser;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data;
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    excludeCurrentUser: boolean;
    maxResultCount: number;
    skipCount: number;
    filter: string | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? FeatureInputTypeDto.fromJS(_data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.defaultValue = _data["defaultValue"];
            this.inputType = _data["inputType"] ? IInputType.fromJS(_data["inputType"]) : <any>undefined;
            this.textHtmlColor = _data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data;
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType;
    textHtmlColor: string | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.parentName = _data["parentName"];
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.isGrantedByDefault = _data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data;
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean;
}

export class FriendDto implements IFriendDto {
    friendUserId!: number;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number;
    isOnline!: boolean;
    state!: FriendshipState;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.friendUserId = _data["friendUserId"];
            this.friendTenantId = _data["friendTenantId"];
            this.friendUserName = _data["friendUserName"];
            this.friendTenancyName = _data["friendTenancyName"];
            this.friendProfilePictureId = _data["friendProfilePictureId"];
            this.unreadMessageCount = _data["unreadMessageCount"];
            this.isOnline = _data["isOnline"];
            this.state = _data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data;
    }
}

export interface IFriendDto {
    friendUserId: number;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number;
    isOnline: boolean;
    state: FriendshipState;
}

export enum FriendshipState {
    Accepted = 1,
    Blocked = 2,
}

export class GeneralLedgerAccountCostCenterLookupTableDto implements IGeneralLedgerAccountCostCenterLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IGeneralLedgerAccountCostCenterLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): GeneralLedgerAccountCostCenterLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralLedgerAccountCostCenterLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IGeneralLedgerAccountCostCenterLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class GeneralLedgerAccountDto implements IGeneralLedgerAccountDto {
    fundsCenter!: string | undefined;
    consumableBudget!: number | undefined;
    consumedBudget!: number | undefined;
    availableAmount!: number | undefined;
    currentBudget!: number | undefined;
    commitmentActuals!: number | undefined;
    fundsCenterDescription!: string | undefined;
    costCenterId!: string | undefined;
    id!: string;

    constructor(data?: IGeneralLedgerAccountDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fundsCenter = _data["fundsCenter"];
            this.consumableBudget = _data["consumableBudget"];
            this.consumedBudget = _data["consumedBudget"];
            this.availableAmount = _data["availableAmount"];
            this.currentBudget = _data["currentBudget"];
            this.commitmentActuals = _data["commitmentActuals"];
            this.fundsCenterDescription = _data["fundsCenterDescription"];
            this.costCenterId = _data["costCenterId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GeneralLedgerAccountDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralLedgerAccountDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fundsCenter"] = this.fundsCenter;
        data["consumableBudget"] = this.consumableBudget;
        data["consumedBudget"] = this.consumedBudget;
        data["availableAmount"] = this.availableAmount;
        data["currentBudget"] = this.currentBudget;
        data["commitmentActuals"] = this.commitmentActuals;
        data["fundsCenterDescription"] = this.fundsCenterDescription;
        data["costCenterId"] = this.costCenterId;
        data["id"] = this.id;
        return data;
    }
}

export interface IGeneralLedgerAccountDto {
    fundsCenter: string | undefined;
    consumableBudget: number | undefined;
    consumedBudget: number | undefined;
    availableAmount: number | undefined;
    currentBudget: number | undefined;
    commitmentActuals: number | undefined;
    fundsCenterDescription: string | undefined;
    costCenterId: string | undefined;
    id: string;
}

export class GeneralLedgerMappingDto implements IGeneralLedgerMappingDto {
    glAccount!: string | undefined;
    glAccountDescription!: string | undefined;
    mappingType!: string | undefined;
    valuationClass!: string | undefined;
    valuationClassDescription!: string | undefined;
    id!: string;

    constructor(data?: IGeneralLedgerMappingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.glAccount = _data["glAccount"];
            this.glAccountDescription = _data["glAccountDescription"];
            this.mappingType = _data["mappingType"];
            this.valuationClass = _data["valuationClass"];
            this.valuationClassDescription = _data["valuationClassDescription"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GeneralLedgerMappingDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralLedgerMappingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["glAccount"] = this.glAccount;
        data["glAccountDescription"] = this.glAccountDescription;
        data["mappingType"] = this.mappingType;
        data["valuationClass"] = this.valuationClass;
        data["valuationClassDescription"] = this.valuationClassDescription;
        data["id"] = this.id;
        return data;
    }
}

export interface IGeneralLedgerMappingDto {
    glAccount: string | undefined;
    glAccountDescription: string | undefined;
    mappingType: string | undefined;
    valuationClass: string | undefined;
    valuationClassDescription: string | undefined;
    id: string;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.timezone = _data["timezone"];
            this.timezoneForComparison = _data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data;
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class GenerateGoogleAuthenticatorKeyOutput implements IGenerateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;
    googleAuthenticatorKey!: string | undefined;

    constructor(data?: IGenerateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qrCodeSetupImageUrl = _data["qrCodeSetupImageUrl"];
            this.googleAuthenticatorKey = _data["googleAuthenticatorKey"];
        }
    }

    static fromJS(data: any): GenerateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GenerateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["googleAuthenticatorKey"] = this.googleAuthenticatorKey;
        return data;
    }
}

export interface IGenerateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
    googleAuthenticatorKey: string | undefined;
}

export class GetAirportForEditOutput implements IGetAirportForEditOutput {
    airport!: CreateOrEditAirportDto;

    constructor(data?: IGetAirportForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.airport = _data["airport"] ? CreateOrEditAirportDto.fromJS(_data["airport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAirportForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAirportForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["airport"] = this.airport ? this.airport.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAirportForEditOutput {
    airport: CreateOrEditAirportDto;
}

export class GetAirportForViewDto implements IGetAirportForViewDto {
    airport!: AirportDto;

    constructor(data?: IGetAirportForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.airport = _data["airport"] ? AirportDto.fromJS(_data["airport"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAirportForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAirportForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["airport"] = this.airport ? this.airport.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetAirportForViewDto {
    airport: AirportDto;
}

export class GetAllAvailableWebhooksOutput implements IGetAllAvailableWebhooksOutput {
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;

    constructor(data?: IGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.description = _data["description"];
        }
    }

    static fromJS(data: any): GetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        return data;
    }
}

export interface IGetAllAvailableWebhooksOutput {
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
}

export class GetAllDynamicEntityPropertyValuesOutput implements IGetAllDynamicEntityPropertyValuesOutput {
    items!: GetAllDynamicEntityPropertyValuesOutputItem[] | undefined;

    constructor(data?: IGetAllDynamicEntityPropertyValuesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllDynamicEntityPropertyValuesOutputItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllDynamicEntityPropertyValuesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDynamicEntityPropertyValuesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAllDynamicEntityPropertyValuesOutput {
    items: GetAllDynamicEntityPropertyValuesOutputItem[] | undefined;
}

export class GetAllDynamicEntityPropertyValuesOutputItem implements IGetAllDynamicEntityPropertyValuesOutputItem {
    dynamicEntityPropertyId!: number;
    propertyName!: string | undefined;
    inputType!: IInputType;
    selectedValues!: string[] | undefined;
    allValuesInputTypeHas!: string[] | undefined;

    constructor(data?: IGetAllDynamicEntityPropertyValuesOutputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            this.propertyName = _data["propertyName"];
            this.inputType = _data["inputType"] ? IInputType.fromJS(_data["inputType"]) : <any>undefined;
            if (Array.isArray(_data["selectedValues"])) {
                this.selectedValues = [] as any;
                for (let item of _data["selectedValues"])
                    this.selectedValues!.push(item);
            }
            if (Array.isArray(_data["allValuesInputTypeHas"])) {
                this.allValuesInputTypeHas = [] as any;
                for (let item of _data["allValuesInputTypeHas"])
                    this.allValuesInputTypeHas!.push(item);
            }
        }
    }

    static fromJS(data: any): GetAllDynamicEntityPropertyValuesOutputItem {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllDynamicEntityPropertyValuesOutputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        data["propertyName"] = this.propertyName;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        if (Array.isArray(this.selectedValues)) {
            data["selectedValues"] = [];
            for (let item of this.selectedValues)
                data["selectedValues"].push(item);
        }
        if (Array.isArray(this.allValuesInputTypeHas)) {
            data["allValuesInputTypeHas"] = [];
            for (let item of this.allValuesInputTypeHas)
                data["allValuesInputTypeHas"].push(item);
        }
        return data;
    }
}

export interface IGetAllDynamicEntityPropertyValuesOutputItem {
    dynamicEntityPropertyId: number;
    propertyName: string | undefined;
    inputType: IInputType;
    selectedValues: string[] | undefined;
    allValuesInputTypeHas: string[] | undefined;
}

export class GetAllEntitiesHasDynamicPropertyOutput implements IGetAllEntitiesHasDynamicPropertyOutput {
    entityFullName!: string | undefined;

    constructor(data?: IGetAllEntitiesHasDynamicPropertyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityFullName = _data["entityFullName"];
        }
    }

    static fromJS(data: any): GetAllEntitiesHasDynamicPropertyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllEntitiesHasDynamicPropertyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityFullName"] = this.entityFullName;
        return data;
    }
}

export interface IGetAllEntitiesHasDynamicPropertyOutput {
    entityFullName: string | undefined;
}

export class GetAllSendAttemptsOfWebhookEventOutput implements IGetAllSendAttemptsOfWebhookEventOutput {
    id!: string;
    webhookUri!: string | undefined;
    webhookSubscriptionId!: string;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: DateTime;
    lastModificationTime!: DateTime | undefined;

    constructor(data?: IGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookUri = _data["webhookUri"];
            this.webhookSubscriptionId = _data["webhookSubscriptionId"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookUri"] = this.webhookUri;
        data["webhookSubscriptionId"] = this.webhookSubscriptionId;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IGetAllSendAttemptsOfWebhookEventOutput {
    id: string;
    webhookUri: string | undefined;
    webhookSubscriptionId: string;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: DateTime;
    lastModificationTime: DateTime | undefined;
}

export class GetAllSendAttemptsOutput implements IGetAllSendAttemptsOutput {
    id!: string;
    webhookEventId!: string;
    webhookName!: string | undefined;
    data!: string | undefined;
    response!: string | undefined;
    responseStatusCode!: HttpStatusCode;
    creationTime!: DateTime;

    constructor(data?: IGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.webhookEventId = _data["webhookEventId"];
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.response = _data["response"];
            this.responseStatusCode = _data["responseStatusCode"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["webhookEventId"] = this.webhookEventId;
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["response"] = this.response;
        data["responseStatusCode"] = this.responseStatusCode;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IGetAllSendAttemptsOutput {
    id: string;
    webhookEventId: string;
    webhookName: string | undefined;
    data: string | undefined;
    response: string | undefined;
    responseStatusCode: HttpStatusCode;
    creationTime: DateTime;
}

export class GetAllSubscriptionsOutput implements IGetAllSubscriptionsOutput {
    webhookUri!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    id!: string;

    constructor(data?: IGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webhookUri = _data["webhookUri"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): GetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webhookUri"] = this.webhookUri;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IGetAllSubscriptionsOutput {
    webhookUri: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    id: string;
}

export class GetCostCenterForEditOutput implements IGetCostCenterForEditOutput {
    costCenter!: CreateOrEditCostCenterDto;

    constructor(data?: IGetCostCenterForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.costCenter = _data["costCenter"] ? CreateOrEditCostCenterDto.fromJS(_data["costCenter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCostCenterForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCostCenterForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["costCenter"] = this.costCenter ? this.costCenter.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCostCenterForEditOutput {
    costCenter: CreateOrEditCostCenterDto;
}

export class GetCostCenterForViewDto implements IGetCostCenterForViewDto {
    costCenter!: CostCenterDto;

    constructor(data?: IGetCostCenterForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.costCenter = _data["costCenter"] ? CostCenterDto.fromJS(_data["costCenter"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCostCenterForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCostCenterForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["costCenter"] = this.costCenter ? this.costCenter.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCostCenterForViewDto {
    costCenter: CostCenterDto;
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto;
    impersonatorUser!: UserLoginInfoDto;
    tenant!: TenantLoginInfoDto;
    impersonatorTenant!: TenantLoginInfoDto;
    application!: ApplicationInfoDto;
    theme!: UiCustomizationSettingsDto;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserLoginInfoDto.fromJS(_data["user"]) : <any>undefined;
            this.impersonatorUser = _data["impersonatorUser"] ? UserLoginInfoDto.fromJS(_data["impersonatorUser"]) : <any>undefined;
            this.tenant = _data["tenant"] ? TenantLoginInfoDto.fromJS(_data["tenant"]) : <any>undefined;
            this.impersonatorTenant = _data["impersonatorTenant"] ? TenantLoginInfoDto.fromJS(_data["impersonatorTenant"]) : <any>undefined;
            this.application = _data["application"] ? ApplicationInfoDto.fromJS(_data["application"]) : <any>undefined;
            this.theme = _data["theme"] ? UiCustomizationSettingsDto.fromJS(_data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["impersonatorUser"] = this.impersonatorUser ? this.impersonatorUser.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["impersonatorTenant"] = this.impersonatorTenant ? this.impersonatorTenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto;
    impersonatorUser: UserLoginInfoDto;
    tenant: TenantLoginInfoDto;
    impersonatorTenant: TenantLoginInfoDto;
    application: ApplicationInfoDto;
    theme: UiCustomizationSettingsDto;
}

export class GetDailySalesOutput implements IGetDailySalesOutput {
    dailySales!: number[] | undefined;

    constructor(data?: IGetDailySalesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDailySalesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDailySalesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        return data;
    }
}

export interface IGetDailySalesOutput {
    dailySales: number[] | undefined;
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
            if (Array.isArray(_data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of _data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data;
    }
}

export interface IGetDashboardDataOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class GetDataProductionForEditOutput implements IGetDataProductionForEditOutput {
    dataProduction!: CreateOrEditDataProductionDto;

    constructor(data?: IGetDataProductionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataProduction = _data["dataProduction"] ? CreateOrEditDataProductionDto.fromJS(_data["dataProduction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDataProductionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataProductionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataProduction"] = this.dataProduction ? this.dataProduction.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetDataProductionForEditOutput {
    dataProduction: CreateOrEditDataProductionDto;
}

export class GetDataProductionForViewDto implements IGetDataProductionForViewDto {
    dataProduction!: DataProductionDto;

    constructor(data?: IGetDataProductionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dataProduction = _data["dataProduction"] ? DataProductionDto.fromJS(_data["dataProduction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetDataProductionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetDataProductionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dataProduction"] = this.dataProduction ? this.dataProduction.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetDataProductionForViewDto {
    dataProduction: DataProductionDto;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class GetEKPOForEditOutput implements IGetEKPOForEditOutput {
    ekpo!: CreateOrEditEKPODto;

    constructor(data?: IGetEKPOForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ekpo = _data["ekpo"] ? CreateOrEditEKPODto.fromJS(_data["ekpo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEKPOForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEKPOForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ekpo"] = this.ekpo ? this.ekpo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetEKPOForEditOutput {
    ekpo: CreateOrEditEKPODto;
}

export class GetEKPOForViewDto implements IGetEKPOForViewDto {
    ekpo!: EKPODto;

    constructor(data?: IGetEKPOForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ekpo = _data["ekpo"] ? EKPODto.fromJS(_data["ekpo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEKPOForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEKPOForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ekpo"] = this.ekpo ? this.ekpo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetEKPOForViewDto {
    ekpo: EKPODto;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["editionStatistics"])) {
                this.editionStatistics = [] as any;
                for (let item of _data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.editionStatistics)) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class GetEkkoForEditOutput implements IGetEkkoForEditOutput {
    ekko!: CreateOrEditEkkoDto;

    constructor(data?: IGetEkkoForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ekko = _data["ekko"] ? CreateOrEditEkkoDto.fromJS(_data["ekko"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEkkoForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEkkoForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ekko"] = this.ekko ? this.ekko.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetEkkoForEditOutput {
    ekko: CreateOrEditEkkoDto;
}

export class GetEkkoForViewDto implements IGetEkkoForViewDto {
    ekko!: EkkoDto;

    constructor(data?: IGetEkkoForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ekko = _data["ekko"] ? EkkoDto.fromJS(_data["ekko"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEkkoForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEkkoForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ekko"] = this.ekko ? this.ekko.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetEkkoForViewDto {
    ekko: EkkoDto;
}

export class GetEnumTableForEditOutput implements IGetEnumTableForEditOutput {
    enumTable!: CreateOrEditEnumTableDto;

    constructor(data?: IGetEnumTableForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enumTable = _data["enumTable"] ? CreateOrEditEnumTableDto.fromJS(_data["enumTable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEnumTableForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEnumTableForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enumTable"] = this.enumTable ? this.enumTable.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetEnumTableForEditOutput {
    enumTable: CreateOrEditEnumTableDto;
}

export class GetEnumTableForViewDto implements IGetEnumTableForViewDto {
    enumTable!: EnumTableDto;

    constructor(data?: IGetEnumTableForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enumTable = _data["enumTable"] ? EnumTableDto.fromJS(_data["enumTable"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEnumTableForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEnumTableForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enumTable"] = this.enumTable ? this.enumTable.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetEnumTableForViewDto {
    enumTable: EnumTableDto;
}

export class GetExpiringTenantsOutput implements IGetExpiringTenantsOutput {
    expiringTenants!: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount!: number;
    maxExpiringTenantsShownCount!: number;
    subscriptionEndDateStart!: DateTime;
    subscriptionEndDateEnd!: DateTime;

    constructor(data?: IGetExpiringTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["expiringTenants"])) {
                this.expiringTenants = [] as any;
                for (let item of _data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            this.subscriptionEndAlertDayCount = _data["subscriptionEndAlertDayCount"];
            this.maxExpiringTenantsShownCount = _data["maxExpiringTenantsShownCount"];
            this.subscriptionEndDateStart = _data["subscriptionEndDateStart"] ? DateTime.fromISO(_data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = _data["subscriptionEndDateEnd"] ? DateTime.fromISO(_data["subscriptionEndDateEnd"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetExpiringTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetExpiringTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.expiringTenants)) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toString() : <any>undefined;
        return data;
    }
}

export interface IGetExpiringTenantsOutput {
    expiringTenants: ExpiringTenant[] | undefined;
    subscriptionEndAlertDayCount: number;
    maxExpiringTenantsShownCount: number;
    subscriptionEndDateStart: DateTime;
    subscriptionEndDateEnd: DateTime;
}

export class GetGeneralLedgerAccountForEditOutput implements IGetGeneralLedgerAccountForEditOutput {
    generalLedgerAccount!: CreateOrEditGeneralLedgerAccountDto;
    costCenterCostCenterName!: string | undefined;

    constructor(data?: IGetGeneralLedgerAccountForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.generalLedgerAccount = _data["generalLedgerAccount"] ? CreateOrEditGeneralLedgerAccountDto.fromJS(_data["generalLedgerAccount"]) : <any>undefined;
            this.costCenterCostCenterName = _data["costCenterCostCenterName"];
        }
    }

    static fromJS(data: any): GetGeneralLedgerAccountForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralLedgerAccountForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generalLedgerAccount"] = this.generalLedgerAccount ? this.generalLedgerAccount.toJSON() : <any>undefined;
        data["costCenterCostCenterName"] = this.costCenterCostCenterName;
        return data;
    }
}

export interface IGetGeneralLedgerAccountForEditOutput {
    generalLedgerAccount: CreateOrEditGeneralLedgerAccountDto;
    costCenterCostCenterName: string | undefined;
}

export class GetGeneralLedgerAccountForViewDto implements IGetGeneralLedgerAccountForViewDto {
    generalLedgerAccount!: GeneralLedgerAccountDto;
    costCenterCostCenterName!: string | undefined;

    constructor(data?: IGetGeneralLedgerAccountForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.generalLedgerAccount = _data["generalLedgerAccount"] ? GeneralLedgerAccountDto.fromJS(_data["generalLedgerAccount"]) : <any>undefined;
            this.costCenterCostCenterName = _data["costCenterCostCenterName"];
        }
    }

    static fromJS(data: any): GetGeneralLedgerAccountForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralLedgerAccountForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generalLedgerAccount"] = this.generalLedgerAccount ? this.generalLedgerAccount.toJSON() : <any>undefined;
        data["costCenterCostCenterName"] = this.costCenterCostCenterName;
        return data;
    }
}

export interface IGetGeneralLedgerAccountForViewDto {
    generalLedgerAccount: GeneralLedgerAccountDto;
    costCenterCostCenterName: string | undefined;
}

export class GetGeneralLedgerMappingForEditOutput implements IGetGeneralLedgerMappingForEditOutput {
    generalLedgerMapping!: CreateOrEditGeneralLedgerMappingDto;

    constructor(data?: IGetGeneralLedgerMappingForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.generalLedgerMapping = _data["generalLedgerMapping"] ? CreateOrEditGeneralLedgerMappingDto.fromJS(_data["generalLedgerMapping"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGeneralLedgerMappingForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralLedgerMappingForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generalLedgerMapping"] = this.generalLedgerMapping ? this.generalLedgerMapping.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetGeneralLedgerMappingForEditOutput {
    generalLedgerMapping: CreateOrEditGeneralLedgerMappingDto;
}

export class GetGeneralLedgerMappingForViewDto implements IGetGeneralLedgerMappingForViewDto {
    generalLedgerMapping!: GeneralLedgerMappingDto;

    constructor(data?: IGetGeneralLedgerMappingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.generalLedgerMapping = _data["generalLedgerMapping"] ? GeneralLedgerMappingDto.fromJS(_data["generalLedgerMapping"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetGeneralLedgerMappingForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralLedgerMappingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["generalLedgerMapping"] = this.generalLedgerMapping ? this.generalLedgerMapping.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetGeneralLedgerMappingForViewDto {
    generalLedgerMapping: GeneralLedgerMappingDto;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number;
    newVisitPercent!: number;
    bouncePercent!: number;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transactionPercent = _data["transactionPercent"];
            this.newVisitPercent = _data["newVisitPercent"];
            this.bouncePercent = _data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data;
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number;
    newVisitPercent: number;
    bouncePercent: number;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["incomeStatistics"])) {
                this.incomeStatistics = [] as any;
                for (let item of _data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.incomeStatistics)) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetJobSynchronizeForEditOutput implements IGetJobSynchronizeForEditOutput {
    jobSynchronize!: CreateOrEditJobSynchronizeDto;

    constructor(data?: IGetJobSynchronizeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobSynchronize = _data["jobSynchronize"] ? CreateOrEditJobSynchronizeDto.fromJS(_data["jobSynchronize"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetJobSynchronizeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobSynchronizeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobSynchronize"] = this.jobSynchronize ? this.jobSynchronize.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetJobSynchronizeForEditOutput {
    jobSynchronize: CreateOrEditJobSynchronizeDto;
}

export class GetJobSynchronizeForViewDto implements IGetJobSynchronizeForViewDto {
    jobSynchronize!: JobSynchronizeDto;

    constructor(data?: IGetJobSynchronizeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobSynchronize = _data["jobSynchronize"] ? JobSynchronizeDto.fromJS(_data["jobSynchronize"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetJobSynchronizeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetJobSynchronizeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobSynchronize"] = this.jobSynchronize ? this.jobSynchronize.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetJobSynchronizeForViewDto {
    jobSynchronize: JobSynchronizeDto;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.language = _data["language"] ? ApplicationLanguageEditDto.fromJS(_data["language"]) : <any>undefined;
            if (Array.isArray(_data["languageNames"])) {
                this.languageNames = [] as any;
                for (let item of _data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(_data["flags"])) {
                this.flags = [] as any;
                for (let item of _data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (Array.isArray(this.languageNames)) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (Array.isArray(this.flags)) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.defaultLanguageName = _data["defaultLanguageName"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["latestWebLogLines"])) {
                this.latestWebLogLines = [] as any;
                for (let item of _data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.latestWebLogLines)) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data;
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class GetLookupPageForEditOutput implements IGetLookupPageForEditOutput {
    lookupPage!: CreateOrEditLookupPageDto;
    costCenterDisplayProperty!: string | undefined;

    constructor(data?: IGetLookupPageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lookupPage = _data["lookupPage"] ? CreateOrEditLookupPageDto.fromJS(_data["lookupPage"]) : <any>undefined;
            this.costCenterDisplayProperty = _data["costCenterDisplayProperty"];
        }
    }

    static fromJS(data: any): GetLookupPageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLookupPageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lookupPage"] = this.lookupPage ? this.lookupPage.toJSON() : <any>undefined;
        data["costCenterDisplayProperty"] = this.costCenterDisplayProperty;
        return data;
    }
}

export interface IGetLookupPageForEditOutput {
    lookupPage: CreateOrEditLookupPageDto;
    costCenterDisplayProperty: string | undefined;
}

export class GetLookupPageForViewDto implements IGetLookupPageForViewDto {
    lookupPage!: LookupPageDto;
    costCenterDisplayProperty!: string | undefined;

    constructor(data?: IGetLookupPageForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lookupPage = _data["lookupPage"] ? LookupPageDto.fromJS(_data["lookupPage"]) : <any>undefined;
            this.costCenterDisplayProperty = _data["costCenterDisplayProperty"];
        }
    }

    static fromJS(data: any): GetLookupPageForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLookupPageForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lookupPage"] = this.lookupPage ? this.lookupPage.toJSON() : <any>undefined;
        data["costCenterDisplayProperty"] = this.costCenterDisplayProperty;
        return data;
    }
}

export interface IGetLookupPageForViewDto {
    lookupPage: LookupPageDto;
    costCenterDisplayProperty: string | undefined;
}

export class GetMaterialForEditOutput implements IGetMaterialForEditOutput {
    material!: CreateOrEditMaterialDto;
    materialGroupDisplayProperty!: string | undefined;
    unspscDisplayProperty!: string | undefined;
    generalLedgerMappingDisplayProperty!: string | undefined;
    imageMainFileName!: string | undefined;

    constructor(data?: IGetMaterialForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.material = _data["material"] ? CreateOrEditMaterialDto.fromJS(_data["material"]) : <any>undefined;
            this.materialGroupDisplayProperty = _data["materialGroupDisplayProperty"];
            this.unspscDisplayProperty = _data["unspscDisplayProperty"];
            this.generalLedgerMappingDisplayProperty = _data["generalLedgerMappingDisplayProperty"];
            this.imageMainFileName = _data["imageMainFileName"];
        }
    }

    static fromJS(data: any): GetMaterialForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["materialGroupDisplayProperty"] = this.materialGroupDisplayProperty;
        data["unspscDisplayProperty"] = this.unspscDisplayProperty;
        data["generalLedgerMappingDisplayProperty"] = this.generalLedgerMappingDisplayProperty;
        data["imageMainFileName"] = this.imageMainFileName;
        return data;
    }
}

export interface IGetMaterialForEditOutput {
    material: CreateOrEditMaterialDto;
    materialGroupDisplayProperty: string | undefined;
    unspscDisplayProperty: string | undefined;
    generalLedgerMappingDisplayProperty: string | undefined;
    imageMainFileName: string | undefined;
}

export class GetMaterialForViewDto implements IGetMaterialForViewDto {
    material!: MaterialDto;
    materialGroupDisplayProperty!: string | undefined;
    unspscDisplayProperty!: string | undefined;
    generalLedgerMappingDisplayProperty!: string | undefined;

    constructor(data?: IGetMaterialForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.material = _data["material"] ? MaterialDto.fromJS(_data["material"]) : <any>undefined;
            this.materialGroupDisplayProperty = _data["materialGroupDisplayProperty"];
            this.unspscDisplayProperty = _data["unspscDisplayProperty"];
            this.generalLedgerMappingDisplayProperty = _data["generalLedgerMappingDisplayProperty"];
        }
    }

    static fromJS(data: any): GetMaterialForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["material"] = this.material ? this.material.toJSON() : <any>undefined;
        data["materialGroupDisplayProperty"] = this.materialGroupDisplayProperty;
        data["unspscDisplayProperty"] = this.unspscDisplayProperty;
        data["generalLedgerMappingDisplayProperty"] = this.generalLedgerMappingDisplayProperty;
        return data;
    }
}

export interface IGetMaterialForViewDto {
    material: MaterialDto;
    materialGroupDisplayProperty: string | undefined;
    unspscDisplayProperty: string | undefined;
    generalLedgerMappingDisplayProperty: string | undefined;
}

export class GetMaterialGroupForEditOutput implements IGetMaterialGroupForEditOutput {
    materialGroup!: CreateOrEditMaterialGroupDto;

    constructor(data?: IGetMaterialGroupForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialGroup = _data["materialGroup"] ? CreateOrEditMaterialGroupDto.fromJS(_data["materialGroup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMaterialGroupForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialGroupForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialGroup"] = this.materialGroup ? this.materialGroup.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetMaterialGroupForEditOutput {
    materialGroup: CreateOrEditMaterialGroupDto;
}

export class GetMaterialGroupForViewDto implements IGetMaterialGroupForViewDto {
    materialGroup!: MaterialGroupDto;

    constructor(data?: IGetMaterialGroupForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialGroup = _data["materialGroup"] ? MaterialGroupDto.fromJS(_data["materialGroup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetMaterialGroupForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialGroupForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialGroup"] = this.materialGroup ? this.materialGroup.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetMaterialGroupForViewDto {
    materialGroup: MaterialGroupDto;
}

export class GetMaterialRequestForEditOutput implements IGetMaterialRequestForEditOutput {
    materialRequest!: CreateOrEditMaterialRequestDto;
    unspscDisplayProperty!: string | undefined;
    generalLedgerMappingDisplayProperty!: string | undefined;
    pictureFileName!: string | undefined;

    constructor(data?: IGetMaterialRequestForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialRequest = _data["materialRequest"] ? CreateOrEditMaterialRequestDto.fromJS(_data["materialRequest"]) : <any>undefined;
            this.unspscDisplayProperty = _data["unspscDisplayProperty"];
            this.generalLedgerMappingDisplayProperty = _data["generalLedgerMappingDisplayProperty"];
            this.pictureFileName = _data["pictureFileName"];
        }
    }

    static fromJS(data: any): GetMaterialRequestForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialRequestForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialRequest"] = this.materialRequest ? this.materialRequest.toJSON() : <any>undefined;
        data["unspscDisplayProperty"] = this.unspscDisplayProperty;
        data["generalLedgerMappingDisplayProperty"] = this.generalLedgerMappingDisplayProperty;
        data["pictureFileName"] = this.pictureFileName;
        return data;
    }
}

export interface IGetMaterialRequestForEditOutput {
    materialRequest: CreateOrEditMaterialRequestDto;
    unspscDisplayProperty: string | undefined;
    generalLedgerMappingDisplayProperty: string | undefined;
    pictureFileName: string | undefined;
}

export class GetMaterialRequestForViewDto implements IGetMaterialRequestForViewDto {
    materialRequest!: MaterialRequestDto;
    unspscDisplayProperty!: string | undefined;
    generalLedgerMappingDisplayProperty!: string | undefined;

    constructor(data?: IGetMaterialRequestForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialRequest = _data["materialRequest"] ? MaterialRequestDto.fromJS(_data["materialRequest"]) : <any>undefined;
            this.unspscDisplayProperty = _data["unspscDisplayProperty"];
            this.generalLedgerMappingDisplayProperty = _data["generalLedgerMappingDisplayProperty"];
        }
    }

    static fromJS(data: any): GetMaterialRequestForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaterialRequestForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialRequest"] = this.materialRequest ? this.materialRequest.toJSON() : <any>undefined;
        data["unspscDisplayProperty"] = this.unspscDisplayProperty;
        data["generalLedgerMappingDisplayProperty"] = this.generalLedgerMappingDisplayProperty;
        return data;
    }
}

export interface IGetMaterialRequestForViewDto {
    materialRequest: MaterialRequestDto;
    unspscDisplayProperty: string | undefined;
    generalLedgerMappingDisplayProperty: string | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["memberActivities"])) {
                this.memberActivities = [] as any;
                for (let item of _data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberActivities)) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class GetNotificationsCreatedByUserOutput implements IGetNotificationsCreatedByUserOutput {
    notificationName!: string | undefined;
    data!: string | undefined;
    dataTypeName!: string | undefined;
    severity!: NotificationSeverity;
    isPublished!: boolean;
    creationTime!: DateTime;

    constructor(data?: IGetNotificationsCreatedByUserOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.notificationName = _data["notificationName"];
            this.data = _data["data"];
            this.dataTypeName = _data["dataTypeName"];
            this.severity = _data["severity"];
            this.isPublished = _data["isPublished"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): GetNotificationsCreatedByUserOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsCreatedByUserOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["notificationName"] = this.notificationName;
        data["data"] = this.data;
        data["dataTypeName"] = this.dataTypeName;
        data["severity"] = this.severity;
        data["isPublished"] = this.isPublished;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IGetNotificationsCreatedByUserOutput {
    notificationName: string | undefined;
    data: string | undefined;
    dataTypeName: string | undefined;
    severity: NotificationSeverity;
    isPublished: boolean;
    creationTime: DateTime;
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number;
    totalCount!: number;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unreadCount = _data["unreadCount"];
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number;
    totalCount: number;
    items: UserNotification[] | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.setting = _data["setting"] ? PasswordComplexitySetting.fromJS(_data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePicture = _data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data;
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class GetProfitShareOutput implements IGetProfitShareOutput {
    profitShares!: number[] | undefined;

    constructor(data?: IGetProfitShareOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of _data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetProfitShareOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfitShareOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data;
    }
}

export interface IGetProfitShareOutput {
    profitShares: number[] | undefined;
}

export class GetPublishedNotificationsOutput implements IGetPublishedNotificationsOutput {
    totalCount!: number;
    items!: GetNotificationsCreatedByUserOutput[] | undefined;

    constructor(data?: IGetPublishedNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetNotificationsCreatedByUserOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetPublishedNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPublishedNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetPublishedNotificationsOutput {
    totalCount: number;
    items: GetNotificationsCreatedByUserOutput[] | undefined;
}

export class GetRecentTenantsOutput implements IGetRecentTenantsOutput {
    recentTenantsDayCount!: number;
    maxRecentTenantsShownCount!: number;
    tenantCreationStartDate!: DateTime;
    recentTenants!: RecentTenant[] | undefined;

    constructor(data?: IGetRecentTenantsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.recentTenantsDayCount = _data["recentTenantsDayCount"];
            this.maxRecentTenantsShownCount = _data["maxRecentTenantsShownCount"];
            this.tenantCreationStartDate = _data["tenantCreationStartDate"] ? DateTime.fromISO(_data["tenantCreationStartDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["recentTenants"])) {
                this.recentTenants = [] as any;
                for (let item of _data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRecentTenantsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRecentTenantsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toString() : <any>undefined;
        if (Array.isArray(this.recentTenants)) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRecentTenantsOutput {
    recentTenantsDayCount: number;
    maxRecentTenantsShownCount: number;
    tenantCreationStartDate: DateTime;
    recentTenants: RecentTenant[] | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["stats"])) {
                this.stats = [] as any;
                for (let item of _data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stats)) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.role = _data["role"] ? RoleEditDto.fromJS(_data["role"]) : <any>undefined;
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetRolesInput implements IGetRolesInput {
    permissions!: string[] | undefined;

    constructor(data?: IGetRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data;
    }
}

export interface IGetRolesInput {
    permissions: string[] | undefined;
}

export class GetRptProcurementAdjustForEditOutput implements IGetRptProcurementAdjustForEditOutput {
    rptProcurementAdjust!: CreateOrEditRptProcurementAdjustDto;

    constructor(data?: IGetRptProcurementAdjustForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rptProcurementAdjust = _data["rptProcurementAdjust"] ? CreateOrEditRptProcurementAdjustDto.fromJS(_data["rptProcurementAdjust"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRptProcurementAdjustForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRptProcurementAdjustForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rptProcurementAdjust"] = this.rptProcurementAdjust ? this.rptProcurementAdjust.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetRptProcurementAdjustForEditOutput {
    rptProcurementAdjust: CreateOrEditRptProcurementAdjustDto;
}

export class GetRptProcurementAdjustForViewDto implements IGetRptProcurementAdjustForViewDto {
    rptProcurementAdjust!: RptProcurementAdjustDto;

    constructor(data?: IGetRptProcurementAdjustForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rptProcurementAdjust = _data["rptProcurementAdjust"] ? RptProcurementAdjustDto.fromJS(_data["rptProcurementAdjust"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRptProcurementAdjustForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRptProcurementAdjustForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rptProcurementAdjust"] = this.rptProcurementAdjust ? this.rptProcurementAdjust.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetRptProcurementAdjustForViewDto {
    rptProcurementAdjust: RptProcurementAdjustDto;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    totalSales!: number;
    revenue!: number;
    expenses!: number;
    growth!: number;
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalSales = _data["totalSales"];
            this.revenue = _data["revenue"];
            this.expenses = _data["expenses"];
            this.growth = _data["growth"];
            if (Array.isArray(_data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of _data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetSalesSummaryOutput {
    totalSales: number;
    revenue: number;
    expenses: number;
    growth: number;
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(_data["features"])) {
                this.features = [] as any;
                for (let item of _data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class GetTopStatsOutput implements IGetTopStatsOutput {
    totalProfit!: number;
    newFeedbacks!: number;
    newOrders!: number;
    newUsers!: number;

    constructor(data?: IGetTopStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalProfit = _data["totalProfit"];
            this.newFeedbacks = _data["newFeedbacks"];
            this.newOrders = _data["newOrders"];
            this.newUsers = _data["newUsers"];
        }
    }

    static fromJS(data: any): GetTopStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTopStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        return data;
    }
}

export interface IGetTopStatsOutput {
    totalProfit: number;
    newFeedbacks: number;
    newOrders: number;
    newUsers: number;
}

export class GetTransferBudgetForEditOutput implements IGetTransferBudgetForEditOutput {
    transferBudget!: CreateOrEditTransferBudgetDto;

    constructor(data?: IGetTransferBudgetForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferBudget = _data["transferBudget"] ? CreateOrEditTransferBudgetDto.fromJS(_data["transferBudget"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTransferBudgetForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransferBudgetForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferBudget"] = this.transferBudget ? this.transferBudget.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetTransferBudgetForEditOutput {
    transferBudget: CreateOrEditTransferBudgetDto;
}

export class GetTransferBudgetForViewDto implements IGetTransferBudgetForViewDto {
    transferBudget!: TransferBudgetDto;

    constructor(data?: IGetTransferBudgetForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferBudget = _data["transferBudget"] ? TransferBudgetDto.fromJS(_data["transferBudget"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetTransferBudgetForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransferBudgetForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferBudget"] = this.transferBudget ? this.transferBudget.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetTransferBudgetForViewDto {
    transferBudget: TransferBudgetDto;
}

export class GetTransferBudgetItemForEditOutput implements IGetTransferBudgetItemForEditOutput {
    transferBudgetItem!: CreateOrEditTransferBudgetItemDto;
    transferBudgetDisplayProperty!: string | undefined;
    costCenterDisplayProperty!: string | undefined;
    costCenterDisplayProperty2!: string | undefined;

    constructor(data?: IGetTransferBudgetItemForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferBudgetItem = _data["transferBudgetItem"] ? CreateOrEditTransferBudgetItemDto.fromJS(_data["transferBudgetItem"]) : <any>undefined;
            this.transferBudgetDisplayProperty = _data["transferBudgetDisplayProperty"];
            this.costCenterDisplayProperty = _data["costCenterDisplayProperty"];
            this.costCenterDisplayProperty2 = _data["costCenterDisplayProperty2"];
        }
    }

    static fromJS(data: any): GetTransferBudgetItemForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransferBudgetItemForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferBudgetItem"] = this.transferBudgetItem ? this.transferBudgetItem.toJSON() : <any>undefined;
        data["transferBudgetDisplayProperty"] = this.transferBudgetDisplayProperty;
        data["costCenterDisplayProperty"] = this.costCenterDisplayProperty;
        data["costCenterDisplayProperty2"] = this.costCenterDisplayProperty2;
        return data;
    }
}

export interface IGetTransferBudgetItemForEditOutput {
    transferBudgetItem: CreateOrEditTransferBudgetItemDto;
    transferBudgetDisplayProperty: string | undefined;
    costCenterDisplayProperty: string | undefined;
    costCenterDisplayProperty2: string | undefined;
}

export class GetTransferBudgetItemForViewDto implements IGetTransferBudgetItemForViewDto {
    transferBudgetItem!: TransferBudgetItemDto;
    transferBudgetDisplayProperty!: string | undefined;
    costCenterDisplayProperty!: string | undefined;
    costCenterDisplayProperty2!: string | undefined;

    constructor(data?: IGetTransferBudgetItemForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.transferBudgetItem = _data["transferBudgetItem"] ? TransferBudgetItemDto.fromJS(_data["transferBudgetItem"]) : <any>undefined;
            this.transferBudgetDisplayProperty = _data["transferBudgetDisplayProperty"];
            this.costCenterDisplayProperty = _data["costCenterDisplayProperty"];
            this.costCenterDisplayProperty2 = _data["costCenterDisplayProperty2"];
        }
    }

    static fromJS(data: any): GetTransferBudgetItemForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTransferBudgetItemForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transferBudgetItem"] = this.transferBudgetItem ? this.transferBudgetItem.toJSON() : <any>undefined;
        data["transferBudgetDisplayProperty"] = this.transferBudgetDisplayProperty;
        data["costCenterDisplayProperty"] = this.costCenterDisplayProperty;
        data["costCenterDisplayProperty2"] = this.costCenterDisplayProperty2;
        return data;
    }
}

export interface IGetTransferBudgetItemForViewDto {
    transferBudgetItem: TransferBudgetItemDto;
    transferBudgetDisplayProperty: string | undefined;
    costCenterDisplayProperty: string | undefined;
    costCenterDisplayProperty2: string | undefined;
}

export class GetTravelRequestForEditOutput implements IGetTravelRequestForEditOutput {
    travelRequest!: CreateOrEditTravelRequestDto;
    userName!: string | undefined;
    airportDisplayProperty!: string | undefined;
    airportDisplayProperty2!: string | undefined;
    userName2!: string | undefined;

    constructor(data?: IGetTravelRequestForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.travelRequest = _data["travelRequest"] ? CreateOrEditTravelRequestDto.fromJS(_data["travelRequest"]) : <any>undefined;
            this.userName = _data["userName"];
            this.airportDisplayProperty = _data["airportDisplayProperty"];
            this.airportDisplayProperty2 = _data["airportDisplayProperty2"];
            this.userName2 = _data["userName2"];
        }
    }

    static fromJS(data: any): GetTravelRequestForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTravelRequestForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["travelRequest"] = this.travelRequest ? this.travelRequest.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["airportDisplayProperty"] = this.airportDisplayProperty;
        data["airportDisplayProperty2"] = this.airportDisplayProperty2;
        data["userName2"] = this.userName2;
        return data;
    }
}

export interface IGetTravelRequestForEditOutput {
    travelRequest: CreateOrEditTravelRequestDto;
    userName: string | undefined;
    airportDisplayProperty: string | undefined;
    airportDisplayProperty2: string | undefined;
    userName2: string | undefined;
}

export class GetTravelRequestForViewDto implements IGetTravelRequestForViewDto {
    travelRequest!: TravelRequestDto;
    userName!: string | undefined;
    airportDisplayProperty!: string | undefined;
    airportDisplayProperty2!: string | undefined;
    userName2!: string | undefined;

    constructor(data?: IGetTravelRequestForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.travelRequest = _data["travelRequest"] ? TravelRequestDto.fromJS(_data["travelRequest"]) : <any>undefined;
            this.userName = _data["userName"];
            this.airportDisplayProperty = _data["airportDisplayProperty"];
            this.airportDisplayProperty2 = _data["airportDisplayProperty2"];
            this.userName2 = _data["userName2"];
        }
    }

    static fromJS(data: any): GetTravelRequestForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetTravelRequestForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["travelRequest"] = this.travelRequest ? this.travelRequest.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["airportDisplayProperty"] = this.airportDisplayProperty;
        data["airportDisplayProperty2"] = this.airportDisplayProperty2;
        data["userName2"] = this.userName2;
        return data;
    }
}

export interface IGetTravelRequestForViewDto {
    travelRequest: TravelRequestDto;
    userName: string | undefined;
    airportDisplayProperty: string | undefined;
    airportDisplayProperty2: string | undefined;
    userName2: string | undefined;
}

export class GetUNSPSCForEditOutput implements IGetUNSPSCForEditOutput {
    unspsc!: CreateOrEditUNSPSCDto;

    constructor(data?: IGetUNSPSCForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unspsc = _data["unspsc"] ? CreateOrEditUNSPSCDto.fromJS(_data["unspsc"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUNSPSCForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUNSPSCForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unspsc"] = this.unspsc ? this.unspsc.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetUNSPSCForEditOutput {
    unspsc: CreateOrEditUNSPSCDto;
}

export class GetUNSPSCForViewDto implements IGetUNSPSCForViewDto {
    unspsc!: UNSPSCDto;

    constructor(data?: IGetUNSPSCForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unspsc = _data["unspsc"] ? UNSPSCDto.fromJS(_data["unspsc"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUNSPSCForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUNSPSCForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unspsc"] = this.unspsc ? this.unspsc.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetUNSPSCForViewDto {
    unspsc: UNSPSCDto;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: DateTime;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.serverTime = _data["serverTime"] ? DateTime.fromISO(_data["serverTime"].toString()) : <any>undefined;
            if (Array.isArray(_data["friends"])) {
                this.friends = [] as any;
                for (let item of _data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toString() : <any>undefined;
        if (Array.isArray(this.friends)) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: DateTime;
    friends: FriendDto[] | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;
    allowedUserNameCharacters!: string | undefined;
    isSMTPSettingsProvided!: boolean;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.profilePictureId = _data["profilePictureId"];
            this.user = _data["user"] ? UserEditDto.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(_data["allOrganizationUnits"])) {
                this.allOrganizationUnits = [] as any;
                for (let item of _data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (Array.isArray(_data["memberedOrganizationUnits"])) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of _data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
            this.allowedUserNameCharacters = _data["allowedUserNameCharacters"];
            this.isSMTPSettingsProvided = _data["isSMTPSettingsProvided"];
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.allOrganizationUnits)) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.memberedOrganizationUnits)) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        data["allowedUserNameCharacters"] = this.allowedUserNameCharacters;
        data["isSMTPSettingsProvided"] = this.isSMTPSettingsProvided;
        return data;
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
    allowedUserNameCharacters: string | undefined;
    isSMTPSettingsProvided: boolean;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class GetUsersInput implements IGetUsersInput {
    filter!: string | undefined;
    permissions!: string[] | undefined;
    role!: number | undefined;
    onlyLockedUsers!: boolean;
    sorting!: string | undefined;
    maxResultCount!: number;
    skipCount!: number;

    constructor(data?: IGetUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.filter = _data["filter"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
            this.role = _data["role"];
            this.onlyLockedUsers = _data["onlyLockedUsers"];
            this.sorting = _data["sorting"];
            this.maxResultCount = _data["maxResultCount"];
            this.skipCount = _data["skipCount"];
        }
    }

    static fromJS(data: any): GetUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filter"] = this.filter;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        data["role"] = this.role;
        data["onlyLockedUsers"] = this.onlyLockedUsers;
        data["sorting"] = this.sorting;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        return data;
    }
}

export interface IGetUsersInput {
    filter: string | undefined;
    permissions: string[] | undefined;
    role: number | undefined;
    onlyLockedUsers: boolean;
    sorting: string | undefined;
    maxResultCount: number;
    skipCount: number;
}

export class GetZMM020RForEditOutput implements IGetZMM020RForEditOutput {
    zmM020R!: CreateOrEditZMM020RDto;

    constructor(data?: IGetZMM020RForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zmM020R = _data["zmM020R"] ? CreateOrEditZMM020RDto.fromJS(_data["zmM020R"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetZMM020RForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetZMM020RForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zmM020R"] = this.zmM020R ? this.zmM020R.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetZMM020RForEditOutput {
    zmM020R: CreateOrEditZMM020RDto;
}

export class GetZMM020RForViewDto implements IGetZMM020RForViewDto {
    zmM020R!: ZMM020RDto;

    constructor(data?: IGetZMM020RForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zmM020R = _data["zmM020R"] ? ZMM020RDto.fromJS(_data["zmM020R"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetZMM020RForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetZMM020RForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zmM020R"] = this.zmM020R ? this.zmM020R.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetZMM020RForViewDto {
    zmM020R: ZMM020RDto;
}

export class GetZMM021RForEditOutput implements IGetZMM021RForEditOutput {
    zmM021R!: CreateOrEditZMM021RDto;

    constructor(data?: IGetZMM021RForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zmM021R = _data["zmM021R"] ? CreateOrEditZMM021RDto.fromJS(_data["zmM021R"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetZMM021RForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetZMM021RForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zmM021R"] = this.zmM021R ? this.zmM021R.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetZMM021RForEditOutput {
    zmM021R: CreateOrEditZMM021RDto;
}

export class GetZMM021RForViewDto implements IGetZMM021RForViewDto {
    zmM021R!: ZMM021RDto;

    constructor(data?: IGetZMM021RForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.zmM021R = _data["zmM021R"] ? ZMM021RDto.fromJS(_data["zmM021R"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetZMM021RForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetZMM021RForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["zmM021R"] = this.zmM021R ? this.zmM021R.toJSON() : <any>undefined;
        return data;
    }
}

export interface IGetZMM021RForViewDto {
    zmM021R: ZMM021RDto;
}

export class GoogleExternalLoginProviderSettings implements IGoogleExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    userInfoEndpoint!: string | undefined;

    constructor(data?: IGoogleExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.userInfoEndpoint = _data["userInfoEndpoint"];
        }
    }

    static fromJS(data: any): GoogleExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new GoogleExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["userInfoEndpoint"] = this.userInfoEndpoint;
        return data;
    }
}

export interface IGoogleExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    userInfoEndpoint: string | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data;
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto;
    otherSettings!: OtherSettingsEditDto;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = _data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = _data["email"] ? EmailSettingsEditDto.fromJS(_data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = _data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(_data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? HostBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? OtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto;
    otherSettings: OtherSettingsEditDto;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean;
    smsVerificationEnabled!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    useCaptchaOnLogin!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;
    userPasswordSettings!: UserPasswordSettingsEditDto;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = _data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
            this.userPasswordSettings = _data["userPasswordSettings"] ? UserPasswordSettingsEditDto.fromJS(_data["userPasswordSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        data["userPasswordSettings"] = this.userPasswordSettings ? this.userPasswordSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean;
    smsVerificationEnabled: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    useCaptchaOnLogin: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
    userPasswordSettings: UserPasswordSettingsEditDto;
}

export enum HttpStatusCode {
    Continue = 100,
    SwitchingProtocols = 101,
    Processing = 102,
    EarlyHints = 103,
    OK = 200,
    Created = 201,
    Accepted = 202,
    NonAuthoritativeInformation = 203,
    NoContent = 204,
    ResetContent = 205,
    PartialContent = 206,
    MultiStatus = 207,
    AlreadyReported = 208,
    IMUsed = 226,
    MultipleChoices = 300,
    Ambiguous = 301,
    MovedPermanently = 302,
    Moved = 303,
    Found = 304,
    Redirect = 305,
    SeeOther = 306,
    RedirectMethod = 307,
    NotModified = 308,
    UseProxy = 400,
    Unused = 401,
    TemporaryRedirect = 402,
    RedirectKeepVerb = 403,
    PermanentRedirect = 404,
    BadRequest = 405,
    Unauthorized = 406,
    PaymentRequired = 407,
    Forbidden = 408,
    NotFound = 409,
    MethodNotAllowed = 410,
    NotAcceptable = 411,
    ProxyAuthenticationRequired = 412,
    RequestTimeout = 413,
    Conflict = 414,
    Gone = 415,
    LengthRequired = 416,
    PreconditionFailed = 417,
    RequestEntityTooLarge = 421,
    RequestUriTooLong = 422,
    UnsupportedMediaType = 423,
    RequestedRangeNotSatisfiable = 424,
    ExpectationFailed = 426,
    MisdirectedRequest = 428,
    UnprocessableEntity = 429,
    Locked = 431,
    FailedDependency = 451,
    UpgradeRequired = 500,
    PreconditionRequired = 501,
    TooManyRequests = 502,
    RequestHeaderFieldsTooLarge = 503,
    UnavailableForLegalReasons = 504,
    InternalServerError = 505,
    NotImplemented = 506,
    BadGateway = 507,
    ServiceUnavailable = 508,
    GatewayTimeout = 510,
    HttpVersionNotSupported = 511,
}

export class IInputType implements IIInputType {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>(<any>this).attributes)![key] = _data["attributes"][key];
                }
            }
            this.validator = _data["validator"] ? IValueValidator.fromJS(_data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data;
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).name = _data["name"];
            if (_data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in _data["attributes"]) {
                    if (_data["attributes"].hasOwnProperty(key))
                        (<any>(<any>this).attributes)![key] = _data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    (<any>data["attributes"])[key] = (<any>this.attributes)[key];
            }
        }
        return data;
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.impersonationToken = _data["impersonationToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class ImpersonateTenantInput implements IImpersonateTenantInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IImpersonateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IImpersonateTenantInput {
    tenantId: number | undefined;
    userId: number;
}

export class ImpersonateUserInput implements IImpersonateUserInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IImpersonateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IImpersonateUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: DateTime;
    amount!: number;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        data["amount"] = this.amount;
        return data;
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: DateTime;
    amount: number;
}

export class InsertOrUpdateAllValuesInput implements IInsertOrUpdateAllValuesInput {
    items!: InsertOrUpdateAllValuesInputItem[] | undefined;

    constructor(data?: IInsertOrUpdateAllValuesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(InsertOrUpdateAllValuesInputItem.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InsertOrUpdateAllValuesInput {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrUpdateAllValuesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IInsertOrUpdateAllValuesInput {
    items: InsertOrUpdateAllValuesInputItem[] | undefined;
}

export class InsertOrUpdateAllValuesInputItem implements IInsertOrUpdateAllValuesInputItem {
    entityId!: string | undefined;
    dynamicEntityPropertyId!: number;
    values!: string[] | undefined;

    constructor(data?: IInsertOrUpdateAllValuesInputItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.dynamicEntityPropertyId = _data["dynamicEntityPropertyId"];
            if (Array.isArray(_data["values"])) {
                this.values = [] as any;
                for (let item of _data["values"])
                    this.values!.push(item);
            }
        }
    }

    static fromJS(data: any): InsertOrUpdateAllValuesInputItem {
        data = typeof data === 'object' ? data : {};
        let result = new InsertOrUpdateAllValuesInputItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["dynamicEntityPropertyId"] = this.dynamicEntityPropertyId;
        if (Array.isArray(this.values)) {
            data["values"] = [];
            for (let item of this.values)
                data["values"].push(item);
        }
        return data;
    }
}

export interface IInsertOrUpdateAllValuesInputItem {
    entityId: string | undefined;
    dynamicEntityPropertyId: number;
    values: string[] | undefined;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto;
    billInfo!: HostBillingSettingsEditDto;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.connectionString = _data["connectionString"];
            this.adminPassword = _data["adminPassword"];
            this.webSiteUrl = _data["webSiteUrl"];
            this.serverUrl = _data["serverUrl"];
            this.defaultLanguage = _data["defaultLanguage"];
            this.smtpSettings = _data["smtpSettings"] ? EmailSettingsEditDto.fromJS(_data["smtpSettings"]) : <any>undefined;
            this.billInfo = _data["billInfo"] ? HostBillingSettingsEditDto.fromJS(_data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data;
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto;
    billInfo: HostBillingSettingsEditDto;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: DateTime;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.invoiceDate = _data["invoiceDate"] ? DateTime.fromISO(_data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = _data["tenantLegalName"];
            if (Array.isArray(_data["tenantAddress"])) {
                this.tenantAddress = [] as any;
                for (let item of _data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = _data["tenantTaxNo"];
            this.hostLegalName = _data["hostLegalName"];
            if (Array.isArray(_data["hostAddress"])) {
                this.hostAddress = [] as any;
                for (let item of _data["hostAddress"])
                    this.hostAddress!.push(item);
            }
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (Array.isArray(this.tenantAddress)) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (Array.isArray(this.hostAddress)) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        return data;
    }
}

export interface IInvoiceDto {
    amount: number;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: DateTime;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.state = _data["state"];
            this.tenantId = _data["tenantId"];
            this.serverRootAddress = _data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data;
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export enum JobSchedulerStatus {
    Progress = 0,
    Success = 1,
    Error = 2,
    Cancel = 3,
}

export enum JobSchedulerType {
    CostCenter = 0,
    PurchasingDocumentHeader = 1,
}

export class JobSynchronizeDto implements IJobSynchronizeDto {
    jobName!: string | undefined;
    jobType!: JobSchedulerType;
    dataSource!: string | undefined;
    lastStatus!: JobSchedulerStatus;
    lastUpdate!: DateTime;
    id!: string;

    constructor(data?: IJobSynchronizeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.jobName = _data["jobName"];
            this.jobType = _data["jobType"];
            this.dataSource = _data["dataSource"];
            this.lastStatus = _data["lastStatus"];
            this.lastUpdate = _data["lastUpdate"] ? DateTime.fromISO(_data["lastUpdate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): JobSynchronizeDto {
        data = typeof data === 'object' ? data : {};
        let result = new JobSynchronizeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["jobName"] = this.jobName;
        data["jobType"] = this.jobType;
        data["dataSource"] = this.dataSource;
        data["lastStatus"] = this.lastStatus;
        data["lastUpdate"] = this.lastUpdate ? this.lastUpdate.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IJobSynchronizeDto {
    jobName: string | undefined;
    jobType: JobSchedulerType;
    dataSource: string | undefined;
    lastStatus: JobSchedulerStatus;
    lastUpdate: DateTime;
    id: string;
}

export class JsonClaimMapDto implements IJsonClaimMapDto {
    claim!: string | undefined;
    key!: string | undefined;

    constructor(data?: IJsonClaimMapDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.claim = _data["claim"];
            this.key = _data["key"];
        }
    }

    static fromJS(data: any): JsonClaimMapDto {
        data = typeof data === 'object' ? data : {};
        let result = new JsonClaimMapDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["claim"] = this.claim;
        data["key"] = this.key;
        return data;
    }
}

export interface IJsonClaimMapDto {
    claim: string | undefined;
    key: string | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.baseValue = _data["baseValue"];
            this.targetValue = _data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data;
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean;
    isEnabled!: boolean;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;
    useSsl!: boolean;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isModuleEnabled = _data["isModuleEnabled"];
            this.isEnabled = _data["isEnabled"];
            this.domain = _data["domain"];
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.useSsl = _data["useSsl"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["useSsl"] = this.useSsl;
        return data;
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean;
    isEnabled: boolean;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
    useSsl: boolean;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.usernameOrEmailAddress = _data["usernameOrEmailAddress"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data;
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.username = _data["username"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data;
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ListResultDtoOfDynamicEntityPropertyDto implements IListResultDtoOfDynamicEntityPropertyDto {
    items!: DynamicEntityPropertyDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicEntityPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicEntityPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicEntityPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicEntityPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicEntityPropertyDto {
    items: DynamicEntityPropertyDto[] | undefined;
}

export class ListResultDtoOfDynamicEntityPropertyValueDto implements IListResultDtoOfDynamicEntityPropertyValueDto {
    items!: DynamicEntityPropertyValueDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicEntityPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicEntityPropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicEntityPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicEntityPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicEntityPropertyValueDto {
    items: DynamicEntityPropertyValueDto[] | undefined;
}

export class ListResultDtoOfDynamicPropertyDto implements IListResultDtoOfDynamicPropertyDto {
    items!: DynamicPropertyDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicPropertyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicPropertyDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicPropertyDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicPropertyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicPropertyDto {
    items: DynamicPropertyDto[] | undefined;
}

export class ListResultDtoOfDynamicPropertyValueDto implements IListResultDtoOfDynamicPropertyValueDto {
    items!: DynamicPropertyValueDto[] | undefined;

    constructor(data?: IListResultDtoOfDynamicPropertyValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(DynamicPropertyValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfDynamicPropertyValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfDynamicPropertyValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfDynamicPropertyValueDto {
    items: DynamicPropertyValueDto[] | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class ListResultDtoOfGetAllAvailableWebhooksOutput implements IListResultDtoOfGetAllAvailableWebhooksOutput {
    items!: GetAllAvailableWebhooksOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllAvailableWebhooksOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllAvailableWebhooksOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllAvailableWebhooksOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllAvailableWebhooksOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllAvailableWebhooksOutput {
    items: GetAllAvailableWebhooksOutput[] | undefined;
}

export class ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput implements IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
    items!: GetAllEntitiesHasDynamicPropertyOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllEntitiesHasDynamicPropertyOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllEntitiesHasDynamicPropertyOutput {
    items: GetAllEntitiesHasDynamicPropertyOutput[] | undefined;
}

export class ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput implements IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items!: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOfWebhookEventOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllSendAttemptsOfWebhookEventOutput {
    items: GetAllSendAttemptsOfWebhookEventOutput[] | undefined;
}

export class ListResultDtoOfGetAllSubscriptionsOutput implements IListResultDtoOfGetAllSubscriptionsOutput {
    items!: GetAllSubscriptionsOutput[] | undefined;

    constructor(data?: IListResultDtoOfGetAllSubscriptionsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSubscriptionsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfGetAllSubscriptionsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfGetAllSubscriptionsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfGetAllSubscriptionsOutput {
    items: GetAllSubscriptionsOutput[] | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.value = _data["value"];
            this.displayText = _data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data;
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LookupPageCostCenterLookupTableDto implements ILookupPageCostCenterLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;
    costCenterCode!: string | undefined;
    costCenterName!: string | undefined;
    departmentName!: string | undefined;

    constructor(data?: ILookupPageCostCenterLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.costCenterCode = _data["costCenterCode"];
            this.costCenterName = _data["costCenterName"];
            this.departmentName = _data["departmentName"];
        }
    }

    static fromJS(data: any): LookupPageCostCenterLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupPageCostCenterLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["costCenterCode"] = this.costCenterCode;
        data["costCenterName"] = this.costCenterName;
        data["departmentName"] = this.departmentName;
        return data;
    }
}

export interface ILookupPageCostCenterLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
    costCenterCode: string | undefined;
    costCenterName: string | undefined;
    departmentName: string | undefined;
}

export class LookupPageDto implements ILookupPageDto {
    lookupName!: string | undefined;
    costCenterId!: string | undefined;
    id!: string;

    constructor(data?: ILookupPageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.lookupName = _data["lookupName"];
            this.costCenterId = _data["costCenterId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): LookupPageDto {
        data = typeof data === 'object' ? data : {};
        let result = new LookupPageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lookupName"] = this.lookupName;
        data["costCenterId"] = this.costCenterId;
        data["id"] = this.id;
        return data;
    }
}

export interface ILookupPageDto {
    lookupName: string | undefined;
    costCenterId: string | undefined;
    id: string;
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number;
}

export class MassNotificationOrganizationUnitLookupTableDto implements IMassNotificationOrganizationUnitLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IMassNotificationOrganizationUnitLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MassNotificationOrganizationUnitLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MassNotificationOrganizationUnitLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMassNotificationOrganizationUnitLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class MassNotificationUserLookupTableDto implements IMassNotificationUserLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: IMassNotificationUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MassNotificationUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MassNotificationUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMassNotificationUserLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export class MaterialDto implements IMaterialDto {
    materialNo!: string | undefined;
    materialName!: string | undefined;
    description!: string | undefined;
    uoM!: string | undefined;
    imageMain!: string | undefined;
    imageMainFileName!: string | undefined;
    materialGroupId!: string | undefined;
    unspscId!: string | undefined;
    generalLedgerMappingId!: string | undefined;
    id!: string;

    constructor(data?: IMaterialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialNo = _data["materialNo"];
            this.materialName = _data["materialName"];
            this.description = _data["description"];
            this.uoM = _data["uoM"];
            this.imageMain = _data["imageMain"];
            this.imageMainFileName = _data["imageMainFileName"];
            this.materialGroupId = _data["materialGroupId"];
            this.unspscId = _data["unspscId"];
            this.generalLedgerMappingId = _data["generalLedgerMappingId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialNo"] = this.materialNo;
        data["materialName"] = this.materialName;
        data["description"] = this.description;
        data["uoM"] = this.uoM;
        data["imageMain"] = this.imageMain;
        data["imageMainFileName"] = this.imageMainFileName;
        data["materialGroupId"] = this.materialGroupId;
        data["unspscId"] = this.unspscId;
        data["generalLedgerMappingId"] = this.generalLedgerMappingId;
        data["id"] = this.id;
        return data;
    }
}

export interface IMaterialDto {
    materialNo: string | undefined;
    materialName: string | undefined;
    description: string | undefined;
    uoM: string | undefined;
    imageMain: string | undefined;
    imageMainFileName: string | undefined;
    materialGroupId: string | undefined;
    unspscId: string | undefined;
    generalLedgerMappingId: string | undefined;
    id: string;
}

export class MaterialGeneralLedgerMappingLookupTableDto implements IMaterialGeneralLedgerMappingLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IMaterialGeneralLedgerMappingLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MaterialGeneralLedgerMappingLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialGeneralLedgerMappingLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMaterialGeneralLedgerMappingLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class MaterialGroupDto implements IMaterialGroupDto {
    materialGroupCode!: string | undefined;
    materialGroupName!: string | undefined;
    materialGroupDescription!: string | undefined;
    language!: string | undefined;
    id!: string;

    constructor(data?: IMaterialGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.materialGroupCode = _data["materialGroupCode"];
            this.materialGroupName = _data["materialGroupName"];
            this.materialGroupDescription = _data["materialGroupDescription"];
            this.language = _data["language"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["materialGroupCode"] = this.materialGroupCode;
        data["materialGroupName"] = this.materialGroupName;
        data["materialGroupDescription"] = this.materialGroupDescription;
        data["language"] = this.language;
        data["id"] = this.id;
        return data;
    }
}

export interface IMaterialGroupDto {
    materialGroupCode: string | undefined;
    materialGroupName: string | undefined;
    materialGroupDescription: string | undefined;
    language: string | undefined;
    id: string;
}

export class MaterialMaterialGroupLookupTableDto implements IMaterialMaterialGroupLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IMaterialMaterialGroupLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MaterialMaterialGroupLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialMaterialGroupLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMaterialMaterialGroupLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class MaterialRequestDto implements IMaterialRequestDto {
    requestNo!: string | undefined;
    requestStatus!: MaterialRequestStatus;
    materialName!: string | undefined;
    description!: string | undefined;
    generalLedger!: string | undefined;
    picture!: string | undefined;
    pictureFileName!: string | undefined;
    unspscId!: string | undefined;
    valuationClassId!: string | undefined;
    id!: string;

    constructor(data?: IMaterialRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestNo = _data["requestNo"];
            this.requestStatus = _data["requestStatus"];
            this.materialName = _data["materialName"];
            this.description = _data["description"];
            this.generalLedger = _data["generalLedger"];
            this.picture = _data["picture"];
            this.pictureFileName = _data["pictureFileName"];
            this.unspscId = _data["unspscId"];
            this.valuationClassId = _data["valuationClassId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): MaterialRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestNo"] = this.requestNo;
        data["requestStatus"] = this.requestStatus;
        data["materialName"] = this.materialName;
        data["description"] = this.description;
        data["generalLedger"] = this.generalLedger;
        data["picture"] = this.picture;
        data["pictureFileName"] = this.pictureFileName;
        data["unspscId"] = this.unspscId;
        data["valuationClassId"] = this.valuationClassId;
        data["id"] = this.id;
        return data;
    }
}

export interface IMaterialRequestDto {
    requestNo: string | undefined;
    requestStatus: MaterialRequestStatus;
    materialName: string | undefined;
    description: string | undefined;
    generalLedger: string | undefined;
    picture: string | undefined;
    pictureFileName: string | undefined;
    unspscId: string | undefined;
    valuationClassId: string | undefined;
    id: string;
}

export class MaterialRequestGeneralLedgerMappingLookupTableDto implements IMaterialRequestGeneralLedgerMappingLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IMaterialRequestGeneralLedgerMappingLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MaterialRequestGeneralLedgerMappingLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialRequestGeneralLedgerMappingLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMaterialRequestGeneralLedgerMappingLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export enum MaterialRequestStatus {
    New = 0,
    Submitted = 1,
    Rejected = 2,
    VerifyCataloger = 3,
    VerifyBudget = 4,
    SubmittedHolding = 5,
    Registred = 6,
}

export class MaterialRequestUNSPSCLookupTableDto implements IMaterialRequestUNSPSCLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IMaterialRequestUNSPSCLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MaterialRequestUNSPSCLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialRequestUNSPSCLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMaterialRequestUNSPSCLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class MaterialUNSPSCLookupTableDto implements IMaterialUNSPSCLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: IMaterialUNSPSCLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): MaterialUNSPSCLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaterialUNSPSCLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IMaterialUNSPSCLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number;
    closed!: number;
    rate!: string | undefined;
    profilePictureName!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.earnings = _data["earnings"];
            this.cases = _data["cases"];
            this.closed = _data["closed"];
            this.rate = _data["rate"];
            this.profilePictureName = _data["profilePictureName"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        data["profilePictureName"] = this.profilePictureName;
        return data;
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number;
    closed: number;
    rate: string | undefined;
    profilePictureName: string | undefined;
}

export class MicrosoftExternalLoginProviderSettings implements IMicrosoftExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;

    constructor(data?: IMicrosoftExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
        }
    }

    static fromJS(data: any): MicrosoftExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new MicrosoftExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        return data;
    }
}

export interface IMicrosoftExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.newParentId = _data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data;
    }
}

export interface IMoveOrganizationUnitInput {
    id: number;
    newParentId: number | undefined;
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number;
    targetEditionId!: number;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceEditionId = _data["sourceEditionId"];
            this.targetEditionId = _data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data;
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number;
    targetEditionId: number;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data;
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).type = _data["type"];
            if (_data["properties"]) {
                this.properties = {} as any;
                for (let key in _data["properties"]) {
                    if (_data["properties"].hasOwnProperty(key))
                        (<any>this.properties)![key] = _data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    (<any>data["properties"])[key] = (<any>this.properties)[key];
            }
        }
        return data;
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0,
    Success = 1,
    Warn = 2,
    Error = 3,
    Fatal = 4,
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data;
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.description = _data["description"];
            this.name = _data["name"];
            this.isSubscribed = _data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data;
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean;
}

export class OpenIdConnectExternalLoginProviderSettings implements IOpenIdConnectExternalLoginProviderSettings {
    clientId!: string | undefined;
    clientSecret!: string | undefined;
    authority!: string | undefined;
    loginUrl!: string | undefined;
    validateIssuer!: boolean;
    responseType!: string | undefined;

    constructor(data?: IOpenIdConnectExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.clientSecret = _data["clientSecret"];
            this.authority = _data["authority"];
            this.loginUrl = _data["loginUrl"];
            this.validateIssuer = _data["validateIssuer"];
            this.responseType = _data["responseType"];
        }
    }

    static fromJS(data: any): OpenIdConnectExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new OpenIdConnectExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["clientSecret"] = this.clientSecret;
        data["authority"] = this.authority;
        data["loginUrl"] = this.loginUrl;
        data["validateIssuer"] = this.validateIssuer;
        data["responseType"] = this.responseType;
        return data;
    }
}

export interface IOpenIdConnectExternalLoginProviderSettings {
    clientId: string | undefined;
    clientSecret: string | undefined;
    authority: string | undefined;
    loginUrl: string | undefined;
    validateIssuer: boolean;
    responseType: string | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number;
    roleCount!: number;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parentId = _data["parentId"];
            this.code = _data["code"];
            this.displayName = _data["displayName"];
            this.memberCount = _data["memberCount"];
            this.roleCount = _data["roleCount"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number;
    roleCount: number;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: DateTime;
    id!: number;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.displayName = _data["displayName"];
            this.name = _data["name"];
            this.addedTime = _data["addedTime"] ? DateTime.fromISO(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: DateTime;
    id: number;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: DateTime;
    id!: number;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.addedTime = _data["addedTime"] ? DateTime.fromISO(_data["addedTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: DateTime;
    id: number;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class Page implements IPage {
    id!: string | undefined;
    name!: string | undefined;
    widgets!: Widget[] | undefined;

    constructor(data?: IPage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["widgets"])) {
                this.widgets = [] as any;
                for (let item of _data["widgets"])
                    this.widgets!.push(Widget.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Page {
        data = typeof data === 'object' ? data : {};
        let result = new Page();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.widgets)) {
            data["widgets"] = [];
            for (let item of this.widgets)
                data["widgets"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPage {
    id: string | undefined;
    name: string | undefined;
    widgets: Widget[] | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number;
    items: AuditLogListDto[] | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number;
    items: EntityChangeListDto[] | undefined;
}

export class PagedResultDtoOfGeneralLedgerAccountCostCenterLookupTableDto implements IPagedResultDtoOfGeneralLedgerAccountCostCenterLookupTableDto {
    totalCount!: number;
    items!: GeneralLedgerAccountCostCenterLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGeneralLedgerAccountCostCenterLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GeneralLedgerAccountCostCenterLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGeneralLedgerAccountCostCenterLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGeneralLedgerAccountCostCenterLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGeneralLedgerAccountCostCenterLookupTableDto {
    totalCount: number;
    items: GeneralLedgerAccountCostCenterLookupTableDto[] | undefined;
}

export class PagedResultDtoOfGetAirportForViewDto implements IPagedResultDtoOfGetAirportForViewDto {
    totalCount!: number;
    items!: GetAirportForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAirportForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAirportForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAirportForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAirportForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAirportForViewDto {
    totalCount: number;
    items: GetAirportForViewDto[] | undefined;
}

export class PagedResultDtoOfGetAllSendAttemptsOutput implements IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount!: number;
    items!: GetAllSendAttemptsOutput[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAllSendAttemptsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetAllSendAttemptsOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAllSendAttemptsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAllSendAttemptsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetAllSendAttemptsOutput {
    totalCount: number;
    items: GetAllSendAttemptsOutput[] | undefined;
}

export class PagedResultDtoOfGetCostCenterForViewDto implements IPagedResultDtoOfGetCostCenterForViewDto {
    totalCount!: number;
    items!: GetCostCenterForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCostCenterForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetCostCenterForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCostCenterForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCostCenterForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetCostCenterForViewDto {
    totalCount: number;
    items: GetCostCenterForViewDto[] | undefined;
}

export class PagedResultDtoOfGetDataProductionForViewDto implements IPagedResultDtoOfGetDataProductionForViewDto {
    totalCount!: number;
    items!: GetDataProductionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetDataProductionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetDataProductionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetDataProductionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetDataProductionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetDataProductionForViewDto {
    totalCount: number;
    items: GetDataProductionForViewDto[] | undefined;
}

export class PagedResultDtoOfGetEKPOForViewDto implements IPagedResultDtoOfGetEKPOForViewDto {
    totalCount!: number;
    items!: GetEKPOForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEKPOForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetEKPOForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEKPOForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEKPOForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetEKPOForViewDto {
    totalCount: number;
    items: GetEKPOForViewDto[] | undefined;
}

export class PagedResultDtoOfGetEkkoForViewDto implements IPagedResultDtoOfGetEkkoForViewDto {
    totalCount!: number;
    items!: GetEkkoForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEkkoForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetEkkoForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEkkoForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEkkoForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetEkkoForViewDto {
    totalCount: number;
    items: GetEkkoForViewDto[] | undefined;
}

export class PagedResultDtoOfGetEnumTableForViewDto implements IPagedResultDtoOfGetEnumTableForViewDto {
    totalCount!: number;
    items!: GetEnumTableForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEnumTableForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetEnumTableForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEnumTableForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEnumTableForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetEnumTableForViewDto {
    totalCount: number;
    items: GetEnumTableForViewDto[] | undefined;
}

export class PagedResultDtoOfGetGeneralLedgerAccountForViewDto implements IPagedResultDtoOfGetGeneralLedgerAccountForViewDto {
    totalCount!: number;
    items!: GetGeneralLedgerAccountForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetGeneralLedgerAccountForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetGeneralLedgerAccountForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetGeneralLedgerAccountForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetGeneralLedgerAccountForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetGeneralLedgerAccountForViewDto {
    totalCount: number;
    items: GetGeneralLedgerAccountForViewDto[] | undefined;
}

export class PagedResultDtoOfGetGeneralLedgerMappingForViewDto implements IPagedResultDtoOfGetGeneralLedgerMappingForViewDto {
    totalCount!: number;
    items!: GetGeneralLedgerMappingForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetGeneralLedgerMappingForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetGeneralLedgerMappingForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetGeneralLedgerMappingForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetGeneralLedgerMappingForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetGeneralLedgerMappingForViewDto {
    totalCount: number;
    items: GetGeneralLedgerMappingForViewDto[] | undefined;
}

export class PagedResultDtoOfGetJobSynchronizeForViewDto implements IPagedResultDtoOfGetJobSynchronizeForViewDto {
    totalCount!: number;
    items!: GetJobSynchronizeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetJobSynchronizeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetJobSynchronizeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetJobSynchronizeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetJobSynchronizeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetJobSynchronizeForViewDto {
    totalCount: number;
    items: GetJobSynchronizeForViewDto[] | undefined;
}

export class PagedResultDtoOfGetLookupPageForViewDto implements IPagedResultDtoOfGetLookupPageForViewDto {
    totalCount!: number;
    items!: GetLookupPageForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetLookupPageForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetLookupPageForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetLookupPageForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetLookupPageForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetLookupPageForViewDto {
    totalCount: number;
    items: GetLookupPageForViewDto[] | undefined;
}

export class PagedResultDtoOfGetMaterialForViewDto implements IPagedResultDtoOfGetMaterialForViewDto {
    totalCount!: number;
    items!: GetMaterialForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaterialForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMaterialForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaterialForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaterialForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetMaterialForViewDto {
    totalCount: number;
    items: GetMaterialForViewDto[] | undefined;
}

export class PagedResultDtoOfGetMaterialGroupForViewDto implements IPagedResultDtoOfGetMaterialGroupForViewDto {
    totalCount!: number;
    items!: GetMaterialGroupForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaterialGroupForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMaterialGroupForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaterialGroupForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaterialGroupForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetMaterialGroupForViewDto {
    totalCount: number;
    items: GetMaterialGroupForViewDto[] | undefined;
}

export class PagedResultDtoOfGetMaterialRequestForViewDto implements IPagedResultDtoOfGetMaterialRequestForViewDto {
    totalCount!: number;
    items!: GetMaterialRequestForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaterialRequestForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetMaterialRequestForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaterialRequestForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaterialRequestForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetMaterialRequestForViewDto {
    totalCount: number;
    items: GetMaterialRequestForViewDto[] | undefined;
}

export class PagedResultDtoOfGetRptProcurementAdjustForViewDto implements IPagedResultDtoOfGetRptProcurementAdjustForViewDto {
    totalCount!: number;
    items!: GetRptProcurementAdjustForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRptProcurementAdjustForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetRptProcurementAdjustForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRptProcurementAdjustForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRptProcurementAdjustForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetRptProcurementAdjustForViewDto {
    totalCount: number;
    items: GetRptProcurementAdjustForViewDto[] | undefined;
}

export class PagedResultDtoOfGetTransferBudgetForViewDto implements IPagedResultDtoOfGetTransferBudgetForViewDto {
    totalCount!: number;
    items!: GetTransferBudgetForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTransferBudgetForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTransferBudgetForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTransferBudgetForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTransferBudgetForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetTransferBudgetForViewDto {
    totalCount: number;
    items: GetTransferBudgetForViewDto[] | undefined;
}

export class PagedResultDtoOfGetTransferBudgetItemForViewDto implements IPagedResultDtoOfGetTransferBudgetItemForViewDto {
    totalCount!: number;
    items!: GetTransferBudgetItemForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTransferBudgetItemForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTransferBudgetItemForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTransferBudgetItemForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTransferBudgetItemForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetTransferBudgetItemForViewDto {
    totalCount: number;
    items: GetTransferBudgetItemForViewDto[] | undefined;
}

export class PagedResultDtoOfGetTravelRequestForViewDto implements IPagedResultDtoOfGetTravelRequestForViewDto {
    totalCount!: number;
    items!: GetTravelRequestForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetTravelRequestForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetTravelRequestForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetTravelRequestForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetTravelRequestForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetTravelRequestForViewDto {
    totalCount: number;
    items: GetTravelRequestForViewDto[] | undefined;
}

export class PagedResultDtoOfGetUNSPSCForViewDto implements IPagedResultDtoOfGetUNSPSCForViewDto {
    totalCount!: number;
    items!: GetUNSPSCForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUNSPSCForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetUNSPSCForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUNSPSCForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUNSPSCForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetUNSPSCForViewDto {
    totalCount: number;
    items: GetUNSPSCForViewDto[] | undefined;
}

export class PagedResultDtoOfGetZMM020RForViewDto implements IPagedResultDtoOfGetZMM020RForViewDto {
    totalCount!: number;
    items!: GetZMM020RForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetZMM020RForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetZMM020RForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetZMM020RForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetZMM020RForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetZMM020RForViewDto {
    totalCount: number;
    items: GetZMM020RForViewDto[] | undefined;
}

export class PagedResultDtoOfGetZMM021RForViewDto implements IPagedResultDtoOfGetZMM021RForViewDto {
    totalCount!: number;
    items!: GetZMM021RForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetZMM021RForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(GetZMM021RForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetZMM021RForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetZMM021RForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfGetZMM021RForViewDto {
    totalCount: number;
    items: GetZMM021RForViewDto[] | undefined;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number;
    items: LanguageTextListDto[] | undefined;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number;
    items: LinkedUserDto[] | undefined;
}

export class PagedResultDtoOfLookupPageCostCenterLookupTableDto implements IPagedResultDtoOfLookupPageCostCenterLookupTableDto {
    totalCount!: number;
    items!: LookupPageCostCenterLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLookupPageCostCenterLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(LookupPageCostCenterLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLookupPageCostCenterLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLookupPageCostCenterLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfLookupPageCostCenterLookupTableDto {
    totalCount: number;
    items: LookupPageCostCenterLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto implements IPagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto {
    totalCount!: number;
    items!: MassNotificationOrganizationUnitLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MassNotificationOrganizationUnitLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMassNotificationOrganizationUnitLookupTableDto {
    totalCount: number;
    items: MassNotificationOrganizationUnitLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMassNotificationUserLookupTableDto implements IPagedResultDtoOfMassNotificationUserLookupTableDto {
    totalCount!: number;
    items!: MassNotificationUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMassNotificationUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MassNotificationUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMassNotificationUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMassNotificationUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMassNotificationUserLookupTableDto {
    totalCount: number;
    items: MassNotificationUserLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMaterialGeneralLedgerMappingLookupTableDto implements IPagedResultDtoOfMaterialGeneralLedgerMappingLookupTableDto {
    totalCount!: number;
    items!: MaterialGeneralLedgerMappingLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMaterialGeneralLedgerMappingLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MaterialGeneralLedgerMappingLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMaterialGeneralLedgerMappingLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMaterialGeneralLedgerMappingLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMaterialGeneralLedgerMappingLookupTableDto {
    totalCount: number;
    items: MaterialGeneralLedgerMappingLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMaterialMaterialGroupLookupTableDto implements IPagedResultDtoOfMaterialMaterialGroupLookupTableDto {
    totalCount!: number;
    items!: MaterialMaterialGroupLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMaterialMaterialGroupLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MaterialMaterialGroupLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMaterialMaterialGroupLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMaterialMaterialGroupLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMaterialMaterialGroupLookupTableDto {
    totalCount: number;
    items: MaterialMaterialGroupLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMaterialRequestGeneralLedgerMappingLookupTableDto implements IPagedResultDtoOfMaterialRequestGeneralLedgerMappingLookupTableDto {
    totalCount!: number;
    items!: MaterialRequestGeneralLedgerMappingLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMaterialRequestGeneralLedgerMappingLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MaterialRequestGeneralLedgerMappingLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMaterialRequestGeneralLedgerMappingLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMaterialRequestGeneralLedgerMappingLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMaterialRequestGeneralLedgerMappingLookupTableDto {
    totalCount: number;
    items: MaterialRequestGeneralLedgerMappingLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMaterialRequestUNSPSCLookupTableDto implements IPagedResultDtoOfMaterialRequestUNSPSCLookupTableDto {
    totalCount!: number;
    items!: MaterialRequestUNSPSCLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMaterialRequestUNSPSCLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MaterialRequestUNSPSCLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMaterialRequestUNSPSCLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMaterialRequestUNSPSCLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMaterialRequestUNSPSCLookupTableDto {
    totalCount: number;
    items: MaterialRequestUNSPSCLookupTableDto[] | undefined;
}

export class PagedResultDtoOfMaterialUNSPSCLookupTableDto implements IPagedResultDtoOfMaterialUNSPSCLookupTableDto {
    totalCount!: number;
    items!: MaterialUNSPSCLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMaterialUNSPSCLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(MaterialUNSPSCLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMaterialUNSPSCLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMaterialUNSPSCLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfMaterialUNSPSCLookupTableDto {
    totalCount: number;
    items: MaterialUNSPSCLookupTableDto[] | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number;
    items: NameValueDto[] | undefined;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number;
    items: TenantListDto[] | undefined;
}

export class PagedResultDtoOfTransferBudgetItemCostCenterLookupTableDto implements IPagedResultDtoOfTransferBudgetItemCostCenterLookupTableDto {
    totalCount!: number;
    items!: TransferBudgetItemCostCenterLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTransferBudgetItemCostCenterLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TransferBudgetItemCostCenterLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTransferBudgetItemCostCenterLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTransferBudgetItemCostCenterLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTransferBudgetItemCostCenterLookupTableDto {
    totalCount: number;
    items: TransferBudgetItemCostCenterLookupTableDto[] | undefined;
}

export class PagedResultDtoOfTransferBudgetItemTransferBudgetLookupTableDto implements IPagedResultDtoOfTransferBudgetItemTransferBudgetLookupTableDto {
    totalCount!: number;
    items!: TransferBudgetItemTransferBudgetLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTransferBudgetItemTransferBudgetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TransferBudgetItemTransferBudgetLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTransferBudgetItemTransferBudgetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTransferBudgetItemTransferBudgetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTransferBudgetItemTransferBudgetLookupTableDto {
    totalCount: number;
    items: TransferBudgetItemTransferBudgetLookupTableDto[] | undefined;
}

export class PagedResultDtoOfTravelRequestAirportLookupTableDto implements IPagedResultDtoOfTravelRequestAirportLookupTableDto {
    totalCount!: number;
    items!: TravelRequestAirportLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTravelRequestAirportLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TravelRequestAirportLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTravelRequestAirportLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTravelRequestAirportLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTravelRequestAirportLookupTableDto {
    totalCount: number;
    items: TravelRequestAirportLookupTableDto[] | undefined;
}

export class PagedResultDtoOfTravelRequestUserLookupTableDto implements IPagedResultDtoOfTravelRequestUserLookupTableDto {
    totalCount!: number;
    items!: TravelRequestUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTravelRequestUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TravelRequestUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTravelRequestUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTravelRequestUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfTravelRequestUserLookupTableDto {
    totalCount: number;
    items: TravelRequestUserLookupTableDto[] | undefined;
}

export class PagedResultDtoOfUserDelegationDto implements IPagedResultDtoOfUserDelegationDto {
    totalCount!: number;
    items!: UserDelegationDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserDelegationDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserDelegationDto {
    totalCount: number;
    items: UserDelegationDto[] | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number;
    items: UserListDto[] | undefined;
}

export class PagedResultDtoOfUserLoginAttemptDto implements IPagedResultDtoOfUserLoginAttemptDto {
    totalCount!: number;
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IPagedResultDtoOfUserLoginAttemptDto {
    totalCount: number;
    items: UserLoginAttemptDto[] | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    readonly allowedMinimumLength!: number;
    requireDigit!: boolean;
    requireLowercase!: boolean;
    requireNonAlphanumeric!: boolean;
    requireUppercase!: boolean;
    requiredLength!: number;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).allowedMinimumLength = _data["allowedMinimumLength"];
            this.requireDigit = _data["requireDigit"];
            this.requireLowercase = _data["requireLowercase"];
            this.requireNonAlphanumeric = _data["requireNonAlphanumeric"];
            this.requireUppercase = _data["requireUppercase"];
            this.requiredLength = _data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowedMinimumLength"] = this.allowedMinimumLength;
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data;
    }
}

export interface IPasswordComplexitySetting {
    allowedMinimumLength: number;
    requireDigit: boolean;
    requireLowercase: boolean;
    requireNonAlphanumeric: boolean;
    requireUppercase: boolean;
    requiredLength: number;
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;
    disabledFundings!: string[] | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.demoUsername = _data["demoUsername"];
            this.demoPassword = _data["demoPassword"];
            if (Array.isArray(_data["disabledFundings"])) {
                this.disabledFundings = [] as any;
                for (let item of _data["disabledFundings"])
                    this.disabledFundings!.push(item);
            }
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        if (Array.isArray(this.disabledFundings)) {
            data["disabledFundings"] = [];
            for (let item of this.disabledFundings)
                data["disabledFundings"].push(item);
        }
        return data;
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
    disabledFundings: string[] | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType;
    supportsRecurringPayments!: boolean;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gatewayType = _data["gatewayType"];
            this.supportsRecurringPayments = _data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data;
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType;
    supportsRecurringPayments: boolean;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto;
    additionalPrice!: number;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionSelectDto.fromJS(_data["edition"]) : <any>undefined;
            this.additionalPrice = _data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data;
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto;
    additionalPrice: number;
}

export enum PaymentPeriodType {
    Daily = 1,
    Weekly = 7,
    Monthly = 30,
    Annual = 365,
}

export class PurchasingOrderSynchDto implements IPurchasingOrderSynchDto {
    companyCode!: string | undefined;
    dateFrom!: DateTime;
    dateTo!: DateTime;
    isActive!: boolean;

    constructor(data?: IPurchasingOrderSynchDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.companyCode = _data["companyCode"];
            this.dateFrom = _data["dateFrom"] ? DateTime.fromISO(_data["dateFrom"].toString()) : <any>undefined;
            this.dateTo = _data["dateTo"] ? DateTime.fromISO(_data["dateTo"].toString()) : <any>undefined;
            this.isActive = _data["isActive"];
        }
    }

    static fromJS(data: any): PurchasingOrderSynchDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchasingOrderSynchDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["companyCode"] = this.companyCode;
        data["dateFrom"] = this.dateFrom ? this.dateFrom.toString() : <any>undefined;
        data["dateTo"] = this.dateTo ? this.dateTo.toString() : <any>undefined;
        data["isActive"] = this.isActive;
        return data;
    }
}

export interface IPurchasingOrderSynchDto {
    companyCode: string | undefined;
    dateFrom: DateTime;
    dateTo: DateTime;
    isActive: boolean;
}

export class RecentTenant implements IRecentTenant {
    id!: number;
    name!: string | undefined;
    creationTime!: DateTime;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IRecentTenant {
    id: number;
    name: string | undefined;
    creationTime: DateTime;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number;
    change!: number[] | undefined;
    averagePrice!: number;
    totalPrice!: number;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countryName = _data["countryName"];
            this.sales = _data["sales"];
            if (Array.isArray(_data["change"])) {
                this.change = [] as any;
                for (let item of _data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = _data["averagePrice"];
            this.totalPrice = _data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (Array.isArray(this.change)) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data;
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number;
    change: number[] | undefined;
    averagePrice: number;
    totalPrice: number;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.password = _data["password"];
            this.captchaResponse = _data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data;
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data;
    }
}

export interface IRegisterOutput {
    canLogin: boolean;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    adminEmailAddress!: string;
    adminName!: string | undefined;
    adminSurname!: string | undefined;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType;
    editionId!: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.adminEmailAddress = _data["adminEmailAddress"];
            this.adminName = _data["adminName"];
            this.adminSurname = _data["adminSurname"];
            this.adminPassword = _data["adminPassword"];
            this.captchaResponse = _data["captchaResponse"];
            this.subscriptionStartType = _data["subscriptionStartType"];
            this.editionId = _data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminName"] = this.adminName;
        data["adminSurname"] = this.adminSurname;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data;
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    adminEmailAddress: string;
    adminName: string | undefined;
    adminSurname: string | undefined;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType;
    editionId: number | undefined;
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean;
    isActive!: boolean;
    isEmailConfirmationRequired!: boolean;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.isTenantActive = _data["isTenantActive"];
            this.isActive = _data["isActive"];
            this.isEmailConfirmationRequired = _data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data;
    }
}

export interface IRegisterTenantOutput {
    tenantId: number;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean;
    isActive: boolean;
    isEmailConfirmationRequired: boolean;
}

export class RenamePageInput implements IRenamePageInput {
    dashboardName!: string | undefined;
    id!: string | undefined;
    name!: string | undefined;
    application!: string | undefined;

    constructor(data?: IRenamePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.application = _data["application"];
        }
    }

    static fromJS(data: any): RenamePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new RenamePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["id"] = this.id;
        data["name"] = this.name;
        data["application"] = this.application;
        return data;
    }
}

export interface IRenamePageInput {
    dashboardName: string | undefined;
    id: string | undefined;
    name: string | undefined;
    application: string | undefined;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number;
    resetCode!: string | undefined;
    expireDate!: DateTime;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.resetCode = _data["resetCode"];
            this.expireDate = _data["expireDate"] ? DateTime.fromISO(_data["expireDate"].toString()) : <any>undefined;
            this.password = _data["password"];
            this.returnUrl = _data["returnUrl"];
            this.singleSignIn = _data["singleSignIn"];
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["expireDate"] = this.expireDate ? this.expireDate.toString() : <any>undefined;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data;
    }
}

export interface IResetPasswordInput {
    userId: number;
    resetCode: string | undefined;
    expireDate: DateTime;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.canLogin = _data["canLogin"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data;
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean;
    userName: string | undefined;
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.c = _data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data;
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.isDefault = _data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data;
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean;
    isDefault!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.displayName = _data["displayName"];
            this.isStatic = _data["isStatic"];
            this.isDefault = _data["isDefault"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean;
    isDefault: boolean;
    creationTime: DateTime;
    id: number;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of _data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number;
}

export class RptProcurementAdjustDto implements IRptProcurementAdjustDto {
    purchasingDocument!: string | undefined;
    isContract!: boolean;
    isAdjust!: boolean;
    dayAdjust!: number;
    remark!: string | undefined;
    id!: string;

    constructor(data?: IRptProcurementAdjustDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchasingDocument = _data["purchasingDocument"];
            this.isContract = _data["isContract"];
            this.isAdjust = _data["isAdjust"];
            this.dayAdjust = _data["dayAdjust"];
            this.remark = _data["remark"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RptProcurementAdjustDto {
        data = typeof data === 'object' ? data : {};
        let result = new RptProcurementAdjustDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchasingDocument"] = this.purchasingDocument;
        data["isContract"] = this.isContract;
        data["isAdjust"] = this.isAdjust;
        data["dayAdjust"] = this.dayAdjust;
        data["remark"] = this.remark;
        data["id"] = this.id;
        return data;
    }
}

export interface IRptProcurementAdjustDto {
    purchasingDocument: string | undefined;
    isContract: boolean;
    isAdjust: boolean;
    dayAdjust: number;
    remark: string | undefined;
    id: string;
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number;
    profit!: number;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.period = _data["period"];
            this.sales = _data["sales"];
            this.profit = _data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data;
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number;
    profit: number;
}

export enum SalesSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class SavePageInput implements ISavePageInput {
    dashboardName!: string | undefined;
    application!: string | undefined;
    pages!: Page[] | undefined;

    constructor(data?: ISavePageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dashboardName = _data["dashboardName"];
            this.application = _data["application"];
            if (Array.isArray(_data["pages"])) {
                this.pages = [] as any;
                for (let item of _data["pages"])
                    this.pages!.push(Page.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SavePageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SavePageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dashboardName"] = this.dashboardName;
        data["application"] = this.application;
        if (Array.isArray(this.pages)) {
            data["pages"] = [];
            for (let item of this.pages)
                data["pages"].push(item.toJSON());
        }
        return data;
    }
}

export interface ISavePageInput {
    dashboardName: string | undefined;
    application: string | undefined;
    pages: Page[] | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser!: boolean;
    useDefaultPasswordComplexitySettings!: boolean;
    passwordComplexity!: PasswordComplexitySetting;
    defaultPasswordComplexity!: PasswordComplexitySetting;
    userLockOut!: UserLockOutSettingsEditDto;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowOneConcurrentLoginPerUser = _data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = _data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = _data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(_data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = _data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(_data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = _data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(_data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = _data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(_data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean;
    useDefaultPasswordComplexitySettings: boolean;
    passwordComplexity: PasswordComplexitySetting;
    defaultPasswordComplexity: PasswordComplexitySetting;
    userLockOut: UserLockOutSettingsEditDto;
    twoFactorLogin: TwoFactorLoginSettingsEditDto;
}

export class SendAndGetDateWithTextInput implements ISendAndGetDateWithTextInput {
    text!: string | undefined;
    date!: DateTime;

    constructor(data?: ISendAndGetDateWithTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.date = _data["date"] ? DateTime.fromISO(_data["date"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): SendAndGetDateWithTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendAndGetDateWithTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["date"] = this.date ? this.date.toString() : <any>undefined;
        return data;
    }
}

export interface ISendAndGetDateWithTextInput {
    text: string | undefined;
    date: DateTime;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.emailAddress = _data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data;
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.provider = _data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data;
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number;
    provider: string;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
    phoneNumber!: string | undefined;

    constructor(data?: ISendVerificationSmsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendVerificationSmsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationSmsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;
}

export class SessionTimeOutSettingsEditDto implements ISessionTimeOutSettingsEditDto {
    isEnabled!: boolean;
    timeOutSecond!: number;
    showTimeOutNotificationSecond!: number;
    showLockScreenWhenTimedOut!: boolean;

    constructor(data?: ISessionTimeOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.timeOutSecond = _data["timeOutSecond"];
            this.showTimeOutNotificationSecond = _data["showTimeOutNotificationSecond"];
            this.showLockScreenWhenTimedOut = _data["showLockScreenWhenTimedOut"];
        }
    }

    static fromJS(data: any): SessionTimeOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionTimeOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["timeOutSecond"] = this.timeOutSecond;
        data["showTimeOutNotificationSecond"] = this.showTimeOutNotificationSecond;
        data["showLockScreenWhenTimedOut"] = this.showLockScreenWhenTimedOut;
        return data;
    }
}

export interface ISessionTimeOutSettingsEditDto {
    isEnabled: boolean;
    timeOutSecond: number;
    showTimeOutNotificationSecond: number;
    showLockScreenWhenTimedOut: boolean;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data;
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class SetNotificationAsReadOutput implements ISetNotificationAsReadOutput {
    success!: boolean;

    constructor(data?: ISetNotificationAsReadOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.success = _data["success"];
        }
    }

    static fromJS(data: any): SetNotificationAsReadOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SetNotificationAsReadOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["success"] = this.success;
        return data;
    }
}

export interface ISetNotificationAsReadOutput {
    success: boolean;
}

export enum SettingScopes {
    Application = 1,
    Tenant = 2,
    User = 4,
    All = 7,
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.output = _data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data;
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.publishableKey = _data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data;
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class StripeCreatePaymentSessionInput implements IStripeCreatePaymentSessionInput {
    paymentId!: number;
    successUrl!: string | undefined;
    cancelUrl!: string | undefined;

    constructor(data?: IStripeCreatePaymentSessionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentId = _data["paymentId"];
            this.successUrl = _data["successUrl"];
            this.cancelUrl = _data["cancelUrl"];
        }
    }

    static fromJS(data: any): StripeCreatePaymentSessionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreatePaymentSessionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["successUrl"] = this.successUrl;
        data["cancelUrl"] = this.cancelUrl;
        return data;
    }
}

export interface IStripeCreatePaymentSessionInput {
    paymentId: number;
    successUrl: string | undefined;
    cancelUrl: string | undefined;
}

export class StripePaymentResultOutput implements IStripePaymentResultOutput {
    paymentDone!: boolean;

    constructor(data?: IStripePaymentResultOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paymentDone = _data["paymentDone"];
        }
    }

    static fromJS(data: any): StripePaymentResultOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StripePaymentResultOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentDone"] = this.paymentDone;
        return data;
    }
}

export interface IStripePaymentResultOutput {
    paymentDone: boolean;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isFree = _data["isFree"];
            this.value = _data["value"];
            this.displayText = _data["displayText"];
            this.isSelected = _data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data;
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean;
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType;
    amount!: number;
    editionId!: number;
    tenantId!: number;
    dayCount!: number;
    paymentPeriodType!: PaymentPeriodType;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number;
    status!: SubscriptionPaymentStatus;
    isRecurring!: boolean;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    editionPaymentType!: EditionPaymentType;
    id!: number;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.description = _data["description"];
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.tenantId = _data["tenantId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.paymentId = _data["paymentId"];
            this.payerId = _data["payerId"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.invoiceNo = _data["invoiceNo"];
            this.status = _data["status"];
            this.isRecurring = _data["isRecurring"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.successUrl = _data["successUrl"];
            this.errorUrl = _data["errorUrl"];
            this.editionPaymentType = _data["editionPaymentType"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["editionPaymentType"] = this.editionPaymentType;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType;
    amount: number;
    editionId: number;
    tenantId: number;
    dayCount: number;
    paymentPeriodType: PaymentPeriodType;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number;
    status: SubscriptionPaymentStatus;
    isRecurring: boolean;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    editionPaymentType: EditionPaymentType;
    id: number;
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1,
    Stripe = 2,
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number;
    editionId!: number;
    dayCount!: number;
    paymentPeriodType!: string | undefined;
    externalPaymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number;
    invoiceNo!: string | undefined;
    lastModificationTime!: DateTime | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: DateTime;
    creatorUserId!: number | undefined;
    id!: number;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.gateway = _data["gateway"];
            this.amount = _data["amount"];
            this.editionId = _data["editionId"];
            this.dayCount = _data["dayCount"];
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.externalPaymentId = _data["externalPaymentId"];
            this.payerId = _data["payerId"];
            this.status = _data["status"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.tenantId = _data["tenantId"];
            this.invoiceNo = _data["invoiceNo"];
            this.lastModificationTime = _data["lastModificationTime"] ? DateTime.fromISO(_data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = _data["lastModifierUserId"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = _data["creatorUserId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["externalPaymentId"] = this.externalPaymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data;
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number;
    editionId: number;
    dayCount: number;
    paymentPeriodType: string | undefined;
    externalPaymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number;
    invoiceNo: string | undefined;
    lastModificationTime: DateTime | undefined;
    lastModifierUserId: number | undefined;
    creationTime: DateTime;
    creatorUserId: number | undefined;
    id: number;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1,
    Paid = 2,
    Failed = 3,
    Cancelled = 4,
    Completed = 5,
}

export enum SubscriptionPaymentType {
    Manual = 0,
    RecurringAutomatic = 1,
    RecurringManual = 2,
}

export enum SubscriptionStartType {
    Free = 1,
    Trial = 2,
    Paid = 3,
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.targetTenantId = _data["targetTenantId"];
            this.targetUserId = _data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data;
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.switchAccountToken = _data["switchAccountToken"];
            this.tenancyName = _data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data;
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.encryptedAccessToken = _data["encryptedAccessToken"];
            this.expireInSeconds = _data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data;
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number;
}

export enum TenantAvailabilityState {
    Available = 1,
    InActive = 2,
    NotFound = 3,
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.legalName = _data["legalName"];
            this.address = _data["address"];
            this.taxVatNo = _data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data;
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.connectionString = _data["connectionString"];
            this.editionId = _data["editionId"];
            this.isActive = _data["isActive"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data;
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean;
    smtpUseDefaultCredentials!: boolean;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useHostDefaultEmailSettings = _data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = _data["defaultFromAddress"];
            this.defaultFromDisplayName = _data["defaultFromDisplayName"];
            this.smtpHost = _data["smtpHost"];
            this.smtpPort = _data["smtpPort"];
            this.smtpUserName = _data["smtpUserName"];
            this.smtpPassword = _data["smtpPassword"];
            this.smtpDomain = _data["smtpDomain"];
            this.smtpEnableSsl = _data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = _data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data;
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean;
    smtpUseDefaultCredentials: boolean;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    subscriptionEndDateUtc!: DateTime | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean;
    id!: number;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.editionDisplayName = _data["editionDisplayName"];
            this.connectionString = _data["connectionString"];
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = _data["editionId"];
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean;
    creationTime: DateTime;
    subscriptionEndDateUtc: DateTime | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean;
    id: number;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    darkLogoId!: string | undefined;
    darkLogoFileType!: string | undefined;
    lightLogoId!: string | undefined;
    lightLogoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: DateTime | undefined;
    isInTrialPeriod!: boolean;
    subscriptionPaymentType!: SubscriptionPaymentType;
    edition!: EditionInfoDto;
    featureValues!: NameValueDto[] | undefined;
    creationTime!: DateTime;
    paymentPeriodType!: PaymentPeriodType;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.name = _data["name"];
            this.darkLogoId = _data["darkLogoId"];
            this.darkLogoFileType = _data["darkLogoFileType"];
            this.lightLogoId = _data["lightLogoId"];
            this.lightLogoFileType = _data["lightLogoFileType"];
            this.customCssId = _data["customCssId"];
            this.subscriptionEndDateUtc = _data["subscriptionEndDateUtc"] ? DateTime.fromISO(_data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = _data["isInTrialPeriod"];
            this.subscriptionPaymentType = _data["subscriptionPaymentType"];
            this.edition = _data["edition"] ? EditionInfoDto.fromJS(_data["edition"]) : <any>undefined;
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = _data["paymentPeriodType"];
            this.subscriptionDateString = _data["subscriptionDateString"];
            this.creationTimeString = _data["creationTimeString"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["darkLogoId"] = this.darkLogoId;
        data["darkLogoFileType"] = this.darkLogoFileType;
        data["lightLogoId"] = this.lightLogoId;
        data["lightLogoFileType"] = this.lightLogoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    darkLogoId: string | undefined;
    darkLogoFileType: string | undefined;
    lightLogoId: string | undefined;
    lightLogoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: DateTime | undefined;
    isInTrialPeriod: boolean;
    subscriptionPaymentType: SubscriptionPaymentType;
    edition: EditionInfoDto;
    featureValues: NameValueDto[] | undefined;
    creationTime: DateTime;
    paymentPeriodType: PaymentPeriodType;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredTenantActiveByDefault!: boolean;
    useCaptchaOnRegistration!: boolean;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = _data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.defaultEditionId = _data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data;
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredTenantActiveByDefault: boolean;
    useCaptchaOnRegistration: boolean;
    defaultEditionId: number | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity;
    creationTime!: DateTime;
    id!: string;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.notificationName = _data["notificationName"];
            this.data = _data["data"] ? NotificationData.fromJS(_data["data"]) : <any>undefined;
            this.entityType = _data["entityType"];
            this.entityTypeName = _data["entityTypeName"];
            this.entityId = _data["entityId"];
            this.severity = _data["severity"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity;
    creationTime: DateTime;
    id: string;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data;
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto;
    ldap!: LdapSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto;
    otherSettings!: TenantOtherSettingsEditDto;
    externalLoginProviderSettings!: ExternalLoginProviderSettingsEditDto;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.general = _data["general"] ? GeneralSettingsEditDto.fromJS(_data["general"]) : <any>undefined;
            this.userManagement = _data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(_data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = _data["email"] ? TenantEmailSettingsEditDto.fromJS(_data["email"]) : <any>undefined;
            this.ldap = _data["ldap"] ? LdapSettingsEditDto.fromJS(_data["ldap"]) : <any>undefined;
            this.security = _data["security"] ? SecuritySettingsEditDto.fromJS(_data["security"]) : new SecuritySettingsEditDto();
            this.billing = _data["billing"] ? TenantBillingSettingsEditDto.fromJS(_data["billing"]) : <any>undefined;
            this.otherSettings = _data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(_data["otherSettings"]) : <any>undefined;
            this.externalLoginProviderSettings = _data["externalLoginProviderSettings"] ? ExternalLoginProviderSettingsEditDto.fromJS(_data["externalLoginProviderSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        data["externalLoginProviderSettings"] = this.externalLoginProviderSettings ? this.externalLoginProviderSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto;
    ldap: LdapSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto;
    otherSettings: TenantOtherSettingsEditDto;
    externalLoginProviderSettings: ExternalLoginProviderSettingsEditDto;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean;
    isNewRegisteredUserActiveByDefault!: boolean;
    isEmailConfirmationRequiredForLogin!: boolean;
    useCaptchaOnRegistration!: boolean;
    useCaptchaOnLogin!: boolean;
    isCookieConsentEnabled!: boolean;
    isQuickThemeSelectEnabled!: boolean;
    allowUsingGravatarProfilePicture!: boolean;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.allowSelfRegistration = _data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = _data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = _data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = _data["useCaptchaOnRegistration"];
            this.useCaptchaOnLogin = _data["useCaptchaOnLogin"];
            this.isCookieConsentEnabled = _data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = _data["isQuickThemeSelectEnabled"];
            this.allowUsingGravatarProfilePicture = _data["allowUsingGravatarProfilePicture"];
            this.sessionTimeOutSettings = _data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(_data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["allowUsingGravatarProfilePicture"] = this.allowUsingGravatarProfilePicture;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean;
    isNewRegisteredUserActiveByDefault: boolean;
    isEmailConfirmationRequiredForLogin: boolean;
    useCaptchaOnRegistration: boolean;
    useCaptchaOnLogin: boolean;
    isCookieConsentEnabled: boolean;
    isQuickThemeSelectEnabled: boolean;
    allowUsingGravatarProfilePicture: boolean;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedFooter = _data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data;
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    readonly desktopFixedHeader!: boolean;
    readonly mobileFixedHeader!: boolean;
    minimizeDesktopHeaderType!: string | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            (<any>this).desktopFixedHeader = _data["desktopFixedHeader"];
            (<any>this).mobileFixedHeader = _data["mobileFixedHeader"];
            this.minimizeDesktopHeaderType = _data["minimizeDesktopHeaderType"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        return data;
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean;
    mobileFixedHeader: boolean;
    minimizeDesktopHeaderType: string | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;
    darkMode!: boolean;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.layoutType = _data["layoutType"];
            this.darkMode = _data["darkMode"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        data["darkMode"] = this.darkMode;
        return data;
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
    darkMode: boolean;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean;
    allowAsideMinimizing!: boolean;
    defaultMinimizedAside!: boolean;
    submenuToggle!: string | undefined;
    searchActive!: boolean;
    enableSecondary!: boolean;
    hoverableAside!: boolean;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.position = _data["position"];
            this.asideSkin = _data["asideSkin"];
            this.fixedAside = _data["fixedAside"];
            this.allowAsideMinimizing = _data["allowAsideMinimizing"];
            this.defaultMinimizedAside = _data["defaultMinimizedAside"];
            this.submenuToggle = _data["submenuToggle"];
            this.searchActive = _data["searchActive"];
            this.enableSecondary = _data["enableSecondary"];
            this.hoverableAside = _data["hoverableAside"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        data["searchActive"] = this.searchActive;
        data["enableSecondary"] = this.enableSecondary;
        data["hoverableAside"] = this.hoverableAside;
        return data;
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean;
    allowAsideMinimizing: boolean;
    defaultMinimizedAside: boolean;
    submenuToggle: string | undefined;
    searchActive: boolean;
    enableSecondary: boolean;
    hoverableAside: boolean;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto;
    header!: ThemeHeaderSettingsDto;
    subHeader!: ThemeSubHeaderSettingsDto;
    menu!: ThemeMenuSettingsDto;
    footer!: ThemeFooterSettingsDto;
    toolbar!: ThemeToolbarSettingsDto;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.theme = _data["theme"];
            this.layout = _data["layout"] ? ThemeLayoutSettingsDto.fromJS(_data["layout"]) : <any>undefined;
            this.header = _data["header"] ? ThemeHeaderSettingsDto.fromJS(_data["header"]) : <any>undefined;
            this.subHeader = _data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(_data["subHeader"]) : <any>undefined;
            this.menu = _data["menu"] ? ThemeMenuSettingsDto.fromJS(_data["menu"]) : <any>undefined;
            this.footer = _data["footer"] ? ThemeFooterSettingsDto.fromJS(_data["footer"]) : <any>undefined;
            this.toolbar = _data["toolbar"] ? ThemeToolbarSettingsDto.fromJS(_data["toolbar"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        data["toolbar"] = this.toolbar ? this.toolbar.toJSON() : <any>undefined;
        return data;
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto;
    header: ThemeHeaderSettingsDto;
    subHeader: ThemeSubHeaderSettingsDto;
    menu: ThemeMenuSettingsDto;
    footer: ThemeFooterSettingsDto;
    toolbar: ThemeToolbarSettingsDto;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean;
    subheaderStyle!: string | undefined;
    subheaderSize!: number;
    titleStyle!: string | undefined;
    containerStyle!: string | undefined;
    subContainerStyle!: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fixedSubHeader = _data["fixedSubHeader"];
            this.subheaderStyle = _data["subheaderStyle"];
            this.subheaderSize = _data["subheaderSize"];
            this.titleStyle = _data["titleStyle"];
            this.containerStyle = _data["containerStyle"];
            this.subContainerStyle = _data["subContainerStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        data["subheaderSize"] = this.subheaderSize;
        data["titleStyle"] = this.titleStyle;
        data["containerStyle"] = this.containerStyle;
        data["subContainerStyle"] = this.subContainerStyle;
        return data;
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean;
    subheaderStyle: string | undefined;
    subheaderSize: number;
    titleStyle: string | undefined;
    containerStyle: string | undefined;
    subContainerStyle: string | undefined;
}

export class ThemeToolbarSettingsDto implements IThemeToolbarSettingsDto {
    desktopFixedToolbar!: boolean;
    mobileFixedToolbar!: boolean;

    constructor(data?: IThemeToolbarSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.desktopFixedToolbar = _data["desktopFixedToolbar"];
            this.mobileFixedToolbar = _data["mobileFixedToolbar"];
        }
    }

    static fromJS(data: any): ThemeToolbarSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeToolbarSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedToolbar"] = this.desktopFixedToolbar;
        data["mobileFixedToolbar"] = this.mobileFixedToolbar;
        return data;
    }
}

export interface IThemeToolbarSettingsDto {
    desktopFixedToolbar: boolean;
    mobileFixedToolbar: boolean;
}

export class TopStatsData implements ITopStatsData {
    newTenantsCount!: number;
    newSubscriptionAmount!: number;
    dashboardPlaceholder1!: number;
    dashboardPlaceholder2!: number;

    constructor(data?: ITopStatsData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.newTenantsCount = _data["newTenantsCount"];
            this.newSubscriptionAmount = _data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = _data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = _data["dashboardPlaceholder2"];
        }
    }

    static fromJS(data: any): TopStatsData {
        data = typeof data === 'object' ? data : {};
        let result = new TopStatsData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        return data;
    }
}

export interface ITopStatsData {
    newTenantsCount: number;
    newSubscriptionAmount: number;
    dashboardPlaceholder1: number;
    dashboardPlaceholder2: number;
}

export class TransferBudgetDto implements ITransferBudgetDto {
    documentNo!: string | undefined;
    department!: string | undefined;
    division!: string | undefined;
    reason!: string | undefined;
    location!: string | undefined;
    id!: string;

    constructor(data?: ITransferBudgetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.documentNo = _data["documentNo"];
            this.department = _data["department"];
            this.division = _data["division"];
            this.reason = _data["reason"];
            this.location = _data["location"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TransferBudgetDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferBudgetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["documentNo"] = this.documentNo;
        data["department"] = this.department;
        data["division"] = this.division;
        data["reason"] = this.reason;
        data["location"] = this.location;
        data["id"] = this.id;
        return data;
    }
}

export interface ITransferBudgetDto {
    documentNo: string | undefined;
    department: string | undefined;
    division: string | undefined;
    reason: string | undefined;
    location: string | undefined;
    id: string;
}

export class TransferBudgetItemCostCenterLookupTableDto implements ITransferBudgetItemCostCenterLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;
    costCenterCode!: string | undefined;
    costCenterName!: string | undefined;
    departmentName!: string | undefined;

    constructor(data?: ITransferBudgetItemCostCenterLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
            this.costCenterCode = _data["costCenterCode"];
            this.costCenterName = _data["costCenterName"];
            this.departmentName = _data["departmentName"];
        }
    }

    static fromJS(data: any): TransferBudgetItemCostCenterLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferBudgetItemCostCenterLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["costCenterCode"] = this.costCenterCode;
        data["costCenterName"] = this.costCenterName;
        data["departmentName"] = this.departmentName;
        return data;
    }
}

export interface ITransferBudgetItemCostCenterLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
    costCenterCode: string | undefined;
    costCenterName: string | undefined;
    departmentName: string | undefined;
}

export class TransferBudgetItemDto implements ITransferBudgetItemDto {
    periodFrom!: string | undefined;
    amountFrom!: number;
    periodTo!: string | undefined;
    amountTo!: number;
    transferBudgetId!: string | undefined;
    costCenterIdFrom!: string | undefined;
    costCenterIdTo!: string | undefined;
    id!: string;

    constructor(data?: ITransferBudgetItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.periodFrom = _data["periodFrom"];
            this.amountFrom = _data["amountFrom"];
            this.periodTo = _data["periodTo"];
            this.amountTo = _data["amountTo"];
            this.transferBudgetId = _data["transferBudgetId"];
            this.costCenterIdFrom = _data["costCenterIdFrom"];
            this.costCenterIdTo = _data["costCenterIdTo"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TransferBudgetItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferBudgetItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["periodFrom"] = this.periodFrom;
        data["amountFrom"] = this.amountFrom;
        data["periodTo"] = this.periodTo;
        data["amountTo"] = this.amountTo;
        data["transferBudgetId"] = this.transferBudgetId;
        data["costCenterIdFrom"] = this.costCenterIdFrom;
        data["costCenterIdTo"] = this.costCenterIdTo;
        data["id"] = this.id;
        return data;
    }
}

export interface ITransferBudgetItemDto {
    periodFrom: string | undefined;
    amountFrom: number;
    periodTo: string | undefined;
    amountTo: number;
    transferBudgetId: string | undefined;
    costCenterIdFrom: string | undefined;
    costCenterIdTo: string | undefined;
    id: string;
}

export class TransferBudgetItemTransferBudgetLookupTableDto implements ITransferBudgetItemTransferBudgetLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: ITransferBudgetItemTransferBudgetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): TransferBudgetItemTransferBudgetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TransferBudgetItemTransferBudgetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITransferBudgetItemTransferBudgetLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class TravelRequestAirportLookupTableDto implements ITravelRequestAirportLookupTableDto {
    id!: string | undefined;
    displayName!: string | undefined;

    constructor(data?: ITravelRequestAirportLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): TravelRequestAirportLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelRequestAirportLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITravelRequestAirportLookupTableDto {
    id: string | undefined;
    displayName: string | undefined;
}

export class TravelRequestDto implements ITravelRequestDto {
    requestNo!: string | undefined;
    travelStatus!: TravelStatus;
    travelType!: TravelType;
    requestDate!: DateTime;
    camp!: string | undefined;
    transportBus!: string | undefined;
    userTravel!: number | undefined;
    airportFrom!: string | undefined;
    airportTo!: string | undefined;
    createdBy!: number | undefined;
    id!: string;

    constructor(data?: ITravelRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestNo = _data["requestNo"];
            this.travelStatus = _data["travelStatus"];
            this.travelType = _data["travelType"];
            this.requestDate = _data["requestDate"] ? DateTime.fromISO(_data["requestDate"].toString()) : <any>undefined;
            this.camp = _data["camp"];
            this.transportBus = _data["transportBus"];
            this.userTravel = _data["userTravel"];
            this.airportFrom = _data["airportFrom"];
            this.airportTo = _data["airportTo"];
            this.createdBy = _data["createdBy"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): TravelRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestNo"] = this.requestNo;
        data["travelStatus"] = this.travelStatus;
        data["travelType"] = this.travelType;
        data["requestDate"] = this.requestDate ? this.requestDate.toString() : <any>undefined;
        data["camp"] = this.camp;
        data["transportBus"] = this.transportBus;
        data["userTravel"] = this.userTravel;
        data["airportFrom"] = this.airportFrom;
        data["airportTo"] = this.airportTo;
        data["createdBy"] = this.createdBy;
        data["id"] = this.id;
        return data;
    }
}

export interface ITravelRequestDto {
    requestNo: string | undefined;
    travelStatus: TravelStatus;
    travelType: TravelType;
    requestDate: DateTime;
    camp: string | undefined;
    transportBus: string | undefined;
    userTravel: number | undefined;
    airportFrom: string | undefined;
    airportTo: string | undefined;
    createdBy: number | undefined;
    id: string;
}

export class TravelRequestUserLookupTableDto implements ITravelRequestUserLookupTableDto {
    id!: number;
    displayName!: string | undefined;

    constructor(data?: ITravelRequestUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): TravelRequestUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new TravelRequestUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface ITravelRequestUserLookupTableDto {
    id: number;
    displayName: string | undefined;
}

export enum TravelStatus {
    New = 0,
    Submitted = 1,
    Booking = 2,
    Scheduled = 3,
    Completed = 4,
}

export enum TravelType {
    OffSite = 0,
    OnSite = 1,
}

export class TwitterExternalLoginProviderSettings implements ITwitterExternalLoginProviderSettings {
    consumerKey!: string | undefined;
    consumerSecret!: string | undefined;

    constructor(data?: ITwitterExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.consumerKey = _data["consumerKey"];
            this.consumerSecret = _data["consumerSecret"];
        }
    }

    static fromJS(data: any): TwitterExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumerKey"] = this.consumerKey;
        data["consumerSecret"] = this.consumerSecret;
        return data;
    }
}

export interface ITwitterExternalLoginProviderSettings {
    consumerKey: string | undefined;
    consumerSecret: string | undefined;
}

export class TwitterGetAccessTokenResponse implements ITwitterGetAccessTokenResponse {
    accessToken!: string | undefined;
    accessTokenSecret!: string | undefined;
    userId!: string | undefined;
    userName!: string | undefined;

    constructor(data?: ITwitterGetAccessTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.accessTokenSecret = _data["accessTokenSecret"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): TwitterGetAccessTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetAccessTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["accessTokenSecret"] = this.accessTokenSecret;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        return data;
    }
}

export interface ITwitterGetAccessTokenResponse {
    accessToken: string | undefined;
    accessTokenSecret: string | undefined;
    userId: string | undefined;
    userName: string | undefined;
}

export class TwitterGetRequestTokenResponse implements ITwitterGetRequestTokenResponse {
    token!: string | undefined;
    secret!: string | undefined;
    confirmed!: boolean;
    redirectUrl!: string | undefined;

    constructor(data?: ITwitterGetRequestTokenResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.token = _data["token"];
            this.secret = _data["secret"];
            this.confirmed = _data["confirmed"];
            this.redirectUrl = _data["redirectUrl"];
        }
    }

    static fromJS(data: any): TwitterGetRequestTokenResponse {
        data = typeof data === 'object' ? data : {};
        let result = new TwitterGetRequestTokenResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["token"] = this.token;
        data["secret"] = this.secret;
        data["confirmed"] = this.confirmed;
        data["redirectUrl"] = this.redirectUrl;
        return data;
    }
}

export interface ITwitterGetRequestTokenResponse {
    token: string | undefined;
    secret: string | undefined;
    confirmed: boolean;
    redirectUrl: string | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean;
    isEnabled!: boolean;
    isEmailProviderEnabled!: boolean;
    isSmsProviderEnabled!: boolean;
    isRememberBrowserEnabled!: boolean;
    isGoogleAuthenticatorEnabled!: boolean;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabledForApplication = _data["isEnabledForApplication"];
            this.isEnabled = _data["isEnabled"];
            this.isEmailProviderEnabled = _data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = _data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = _data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = _data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data;
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean;
    isEnabled: boolean;
    isEmailProviderEnabled: boolean;
    isSmsProviderEnabled: boolean;
    isRememberBrowserEnabled: boolean;
    isGoogleAuthenticatorEnabled: boolean;
}

export class UNSPSCDto implements IUNSPSCDto {
    unspsC_Code!: string | undefined;
    description!: string | undefined;
    accountCode!: string | undefined;
    id!: string;

    constructor(data?: IUNSPSCDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.unspsC_Code = _data["unspsC_Code"];
            this.description = _data["description"];
            this.accountCode = _data["accountCode"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UNSPSCDto {
        data = typeof data === 'object' ? data : {};
        let result = new UNSPSCDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unspsC_Code"] = this.unspsC_Code;
        data["description"] = this.description;
        data["accountCode"] = this.accountCode;
        data["id"] = this.id;
        return data;
    }
}

export interface IUNSPSCDto {
    unspsC_Code: string | undefined;
    description: string | undefined;
    accountCode: string | undefined;
    id: string;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto;
    isLeftMenuUsed!: boolean;
    isTopMenuUsed!: boolean;
    isTabMenuUsed!: boolean;
    allowMenuScroll!: boolean;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseSettings = _data["baseSettings"] ? ThemeSettingsDto.fromJS(_data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = _data["isLeftMenuUsed"];
            this.isTopMenuUsed = _data["isTopMenuUsed"];
            this.isTabMenuUsed = _data["isTabMenuUsed"];
            this.allowMenuScroll = _data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data;
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto;
    isLeftMenuUsed: boolean;
    isTopMenuUsed: boolean;
    isTabMenuUsed: boolean;
    allowMenuScroll: boolean;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.tenantId = _data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data;
    }
}

export interface IUnblockUserInput {
    userId: number;
    tenantId: number | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.edition = _data["edition"] ? EditionEditDto.fromJS(_data["edition"]) : new EditionEditDto();
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class UpdateGoogleAuthenticatorKeyInput implements IUpdateGoogleAuthenticatorKeyInput {
    googleAuthenticatorKey!: string | undefined;
    authenticatorCode!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.googleAuthenticatorKey = _data["googleAuthenticatorKey"];
            this.authenticatorCode = _data["authenticatorCode"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["googleAuthenticatorKey"] = this.googleAuthenticatorKey;
        data["authenticatorCode"] = this.authenticatorCode;
        return data;
    }
}

export interface IUpdateGoogleAuthenticatorKeyInput {
    googleAuthenticatorKey: string | undefined;
    authenticatorCode: string | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    recoveryCodes!: string[] | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["recoveryCodes"])) {
                this.recoveryCodes = [] as any;
                for (let item of _data["recoveryCodes"])
                    this.recoveryCodes!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.recoveryCodes)) {
            data["recoveryCodes"] = [];
            for (let item of this.recoveryCodes)
                data["recoveryCodes"].push(item);
        }
        return data;
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    recoveryCodes: string[] | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.languageName = _data["languageName"];
            this.sourceName = _data["sourceName"];
            this.key = _data["key"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data;
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.receiveNotifications = _data["receiveNotifications"];
            if (Array.isArray(_data["notifications"])) {
                this.notifications = [] as any;
                for (let item of _data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.displayName = _data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data;
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number;
    displayName: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string | undefined;
    useGravatarProfilePicture!: boolean;
    userId!: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fileToken = _data["fileToken"];
            this.useGravatarProfilePicture = _data["useGravatarProfilePicture"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["useGravatarProfilePicture"] = this.useGravatarProfilePicture;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string | undefined;
    useGravatarProfilePicture: boolean;
    userId: number | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of _data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number;
    featureValues: NameValueDto[];
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of _data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data;
    }
}

export interface IUpdateUserPermissionsInput {
    id: number;
    grantedPermissionNames: string[];
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.signInToken = _data["signInToken"];
            this.encodedUserId = _data["encodedUserId"];
            this.encodedTenantId = _data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data;
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class UserDelegationDto implements IUserDelegationDto {
    username!: string | undefined;
    startTime!: DateTime;
    endTime!: DateTime;
    id!: number;

    constructor(data?: IUserDelegationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.startTime = _data["startTime"] ? DateTime.fromISO(_data["startTime"].toString()) : <any>undefined;
            this.endTime = _data["endTime"] ? DateTime.fromISO(_data["endTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserDelegationDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDelegationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["startTime"] = this.startTime ? this.startTime.toString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserDelegationDto {
    username: string | undefined;
    startTime: DateTime;
    endTime: DateTime;
    id: number;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean;
    shouldChangePasswordOnNextLogin!: boolean;
    isTwoFactorEnabled!: boolean;
    isLockoutEnabled!: boolean;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.phoneNumber = _data["phoneNumber"];
            this.password = _data["password"];
            this.isActive = _data["isActive"];
            this.shouldChangePasswordOnNextLogin = _data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = _data["isTwoFactorEnabled"];
            this.isLockoutEnabled = _data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data;
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean;
    shouldChangePasswordOnNextLogin: boolean;
    isTwoFactorEnabled: boolean;
    isLockoutEnabled: boolean;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    lockoutEndDateUtc!: DateTime | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean;
    creationTime!: DateTime;
    id!: number;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.lockoutEndDateUtc = _data["lockoutEndDateUtc"] ? DateTime.fromISO(_data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.phoneNumber = _data["phoneNumber"];
            this.profilePictureId = _data["profilePictureId"];
            this.isEmailConfirmed = _data["isEmailConfirmed"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = _data["isActive"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toString() : <any>undefined;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    lockoutEndDateUtc: DateTime | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean;
    creationTime: DateTime;
    id: number;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data;
    }
}

export interface IUserListRoleDto {
    roleId: number;
    roleName: string | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean;
    maxFailedAccessAttemptsBeforeLockout!: number | undefined;
    defaultAccountLockoutSeconds!: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isEnabled = _data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = _data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = _data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data;
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: DateTime;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenancyName = _data["tenancyName"];
            this.userNameOrEmail = _data["userNameOrEmail"];
            this.clientIpAddress = _data["clientIpAddress"];
            this.clientName = _data["clientName"];
            this.browserInfo = _data["browserInfo"];
            this.result = _data["result"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        return data;
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: DateTime;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    id!: number;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.surname = _data["surname"];
            this.userName = _data["userName"];
            this.emailAddress = _data["emailAddress"];
            this.profilePictureId = _data["profilePictureId"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data;
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number;
    state!: UserNotificationState;
    notification!: TenantNotification;
    targetNotifiers!: string | undefined;
    readonly targetNotifiersList!: string[] | undefined;
    id!: string;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.userId = _data["userId"];
            this.state = _data["state"];
            this.notification = _data["notification"] ? TenantNotification.fromJS(_data["notification"]) : <any>undefined;
            this.targetNotifiers = _data["targetNotifiers"];
            if (Array.isArray(_data["targetNotifiersList"])) {
                (<any>this).targetNotifiersList = [] as any;
                for (let item of _data["targetNotifiersList"])
                    (<any>this).targetNotifiersList!.push(item);
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["targetNotifiers"] = this.targetNotifiers;
        if (Array.isArray(this.targetNotifiersList)) {
            data["targetNotifiersList"] = [];
            for (let item of this.targetNotifiersList)
                data["targetNotifiersList"].push(item);
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number;
    state: UserNotificationState;
    notification: TenantNotification;
    targetNotifiers: string | undefined;
    targetNotifiersList: string[] | undefined;
    id: string;
}

export enum UserNotificationState {
    Unread = 0,
    Read = 1,
}

export class UserPasswordSettingsEditDto implements IUserPasswordSettingsEditDto {
    enableCheckingLastXPasswordWhenPasswordChange!: boolean;
    checkingLastXPasswordCount!: number;
    enablePasswordExpiration!: boolean;
    passwordExpirationDayCount!: number;
    passwordResetCodeExpirationHours!: number;

    constructor(data?: IUserPasswordSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.enableCheckingLastXPasswordWhenPasswordChange = _data["enableCheckingLastXPasswordWhenPasswordChange"];
            this.checkingLastXPasswordCount = _data["checkingLastXPasswordCount"];
            this.enablePasswordExpiration = _data["enablePasswordExpiration"];
            this.passwordExpirationDayCount = _data["passwordExpirationDayCount"];
            this.passwordResetCodeExpirationHours = _data["passwordResetCodeExpirationHours"];
        }
    }

    static fromJS(data: any): UserPasswordSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserPasswordSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["enableCheckingLastXPasswordWhenPasswordChange"] = this.enableCheckingLastXPasswordWhenPasswordChange;
        data["checkingLastXPasswordCount"] = this.checkingLastXPasswordCount;
        data["enablePasswordExpiration"] = this.enablePasswordExpiration;
        data["passwordExpirationDayCount"] = this.passwordExpirationDayCount;
        data["passwordResetCodeExpirationHours"] = this.passwordResetCodeExpirationHours;
        return data;
    }
}

export interface IUserPasswordSettingsEditDto {
    enableCheckingLastXPasswordWhenPasswordChange: boolean;
    checkingLastXPasswordCount: number;
    enablePasswordExpiration: boolean;
    passwordExpirationDayCount: number;
    passwordResetCodeExpirationHours: number;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean;
    inheritedFromOrganizationUnit!: boolean;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleId = _data["roleId"];
            this.roleName = _data["roleName"];
            this.roleDisplayName = _data["roleDisplayName"];
            this.isAssigned = _data["isAssigned"];
            this.inheritedFromOrganizationUnit = _data["inheritedFromOrganizationUnit"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        data["inheritedFromOrganizationUnit"] = this.inheritedFromOrganizationUnit;
        return data;
    }
}

export interface IUserRoleDto {
    roleId: number;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean;
    inheritedFromOrganizationUnit: boolean;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["userIds"])) {
                this.userIds = [] as any;
                for (let item of _data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = _data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data;
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number;
}

export class VerifyAuthenticatorCodeInput implements IVerifyAuthenticatorCodeInput {
    code!: string | undefined;
    googleAuthenticatorKey!: string | undefined;

    constructor(data?: IVerifyAuthenticatorCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.googleAuthenticatorKey = _data["googleAuthenticatorKey"];
        }
    }

    static fromJS(data: any): VerifyAuthenticatorCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new VerifyAuthenticatorCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["googleAuthenticatorKey"] = this.googleAuthenticatorKey;
        return data;
    }
}

export interface IVerifyAuthenticatorCodeInput {
    code: string | undefined;
    googleAuthenticatorKey: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.code = _data["code"];
            this.phoneNumber = _data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data;
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;
}

export class WebhookEvent implements IWebhookEvent {
    webhookName!: string;
    data!: string | undefined;
    creationTime!: DateTime;
    tenantId!: number | undefined;
    isDeleted!: boolean;
    deletionTime!: DateTime | undefined;
    id!: string;

    constructor(data?: IWebhookEvent) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.webhookName = _data["webhookName"];
            this.data = _data["data"];
            this.creationTime = _data["creationTime"] ? DateTime.fromISO(_data["creationTime"].toString()) : <any>undefined;
            this.tenantId = _data["tenantId"];
            this.isDeleted = _data["isDeleted"];
            this.deletionTime = _data["deletionTime"] ? DateTime.fromISO(_data["deletionTime"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookEvent {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookEvent();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webhookName"] = this.webhookName;
        data["data"] = this.data;
        data["creationTime"] = this.creationTime ? this.creationTime.toString() : <any>undefined;
        data["tenantId"] = this.tenantId;
        data["isDeleted"] = this.isDeleted;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IWebhookEvent {
    webhookName: string;
    data: string | undefined;
    creationTime: DateTime;
    tenantId: number | undefined;
    isDeleted: boolean;
    deletionTime: DateTime | undefined;
    id: string;
}

export class WebhookSubscription implements IWebhookSubscription {
    tenantId!: number | undefined;
    webhookUri!: string | undefined;
    secret!: string | undefined;
    isActive!: boolean;
    webhooks!: string[] | undefined;
    headers!: { [key: string]: string; } | undefined;
    id!: string;

    constructor(data?: IWebhookSubscription) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tenantId = _data["tenantId"];
            this.webhookUri = _data["webhookUri"];
            this.secret = _data["secret"];
            this.isActive = _data["isActive"];
            if (Array.isArray(_data["webhooks"])) {
                this.webhooks = [] as any;
                for (let item of _data["webhooks"])
                    this.webhooks!.push(item);
            }
            if (_data["headers"]) {
                this.headers = {} as any;
                for (let key in _data["headers"]) {
                    if (_data["headers"].hasOwnProperty(key))
                        (<any>this.headers)![key] = _data["headers"][key];
                }
            }
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): WebhookSubscription {
        data = typeof data === 'object' ? data : {};
        let result = new WebhookSubscription();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["webhookUri"] = this.webhookUri;
        data["secret"] = this.secret;
        data["isActive"] = this.isActive;
        if (Array.isArray(this.webhooks)) {
            data["webhooks"] = [];
            for (let item of this.webhooks)
                data["webhooks"].push(item);
        }
        if (this.headers) {
            data["headers"] = {};
            for (let key in this.headers) {
                if (this.headers.hasOwnProperty(key))
                    (<any>data["headers"])[key] = (<any>this.headers)[key];
            }
        }
        data["id"] = this.id;
        return data;
    }
}

export interface IWebhookSubscription {
    tenantId: number | undefined;
    webhookUri: string | undefined;
    secret: string | undefined;
    isActive: boolean;
    webhooks: string[] | undefined;
    headers: { [key: string]: string; } | undefined;
    id: string;
}

export class Widget implements IWidget {
    widgetId!: string | undefined;
    height!: number;
    width!: number;
    positionX!: number;
    positionY!: number;

    constructor(data?: IWidget) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.widgetId = _data["widgetId"];
            this.height = _data["height"];
            this.width = _data["width"];
            this.positionX = _data["positionX"];
            this.positionY = _data["positionY"];
        }
    }

    static fromJS(data: any): Widget {
        data = typeof data === 'object' ? data : {};
        let result = new Widget();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["widgetId"] = this.widgetId;
        data["height"] = this.height;
        data["width"] = this.width;
        data["positionX"] = this.positionX;
        data["positionY"] = this.positionY;
        return data;
    }
}

export interface IWidget {
    widgetId: string | undefined;
    height: number;
    width: number;
    positionX: number;
    positionY: number;
}

export class WidgetFilterOutput implements IWidgetFilterOutput {
    id!: string | undefined;
    name!: string | undefined;

    constructor(data?: IWidgetFilterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): WidgetFilterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetFilterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IWidgetFilterOutput {
    id: string | undefined;
    name: string | undefined;
}

export class WidgetOutput implements IWidgetOutput {
    id!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    filters!: WidgetFilterOutput[] | undefined;

    constructor(data?: IWidgetOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["filters"])) {
                this.filters = [] as any;
                for (let item of _data["filters"])
                    this.filters!.push(WidgetFilterOutput.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WidgetOutput {
        data = typeof data === 'object' ? data : {};
        let result = new WidgetOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.filters)) {
            data["filters"] = [];
            for (let item of this.filters)
                data["filters"].push(item.toJSON());
        }
        return data;
    }
}

export interface IWidgetOutput {
    id: string | undefined;
    name: string | undefined;
    description: string | undefined;
    filters: WidgetFilterOutput[] | undefined;
}

export class WsFederationExternalLoginProviderSettings implements IWsFederationExternalLoginProviderSettings {
    clientId!: string | undefined;
    tenant!: string | undefined;
    metaDataAddress!: string | undefined;
    wtrealm!: string | undefined;
    authority!: string | undefined;

    constructor(data?: IWsFederationExternalLoginProviderSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.clientId = _data["clientId"];
            this.tenant = _data["tenant"];
            this.metaDataAddress = _data["metaDataAddress"];
            this.wtrealm = _data["wtrealm"];
            this.authority = _data["authority"];
        }
    }

    static fromJS(data: any): WsFederationExternalLoginProviderSettings {
        data = typeof data === 'object' ? data : {};
        let result = new WsFederationExternalLoginProviderSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["tenant"] = this.tenant;
        data["metaDataAddress"] = this.metaDataAddress;
        data["wtrealm"] = this.wtrealm;
        data["authority"] = this.authority;
        return data;
    }
}

export interface IWsFederationExternalLoginProviderSettings {
    clientId: string | undefined;
    tenant: string | undefined;
    metaDataAddress: string | undefined;
    wtrealm: string | undefined;
    authority: string | undefined;
}

export class ZMM020RDto implements IZMM020RDto {
    purchaseRequisition!: string | undefined;
    documentType!: string | undefined;
    documentTypeText!: string | undefined;
    itemRequisition!: string | undefined;
    processingStatusCode!: string | undefined;
    processingStatus!: string | undefined;
    deletionIndicator!: string | undefined;
    itemCategory!: string | undefined;
    accountAssignment!: string | undefined;
    material!: string | undefined;
    shortText!: string | undefined;
    quantityRequested!: number | undefined;
    unitOfMeasure!: string | undefined;
    serviceItem!: string | undefined;
    service!: string | undefined;
    serviceShortText!: string | undefined;
    quantityService!: number | undefined;
    unitOfMeasureService!: string | undefined;
    deliveryDate!: DateTime | undefined;
    materialGroup!: string | undefined;
    plant!: string | undefined;
    storageLocation!: string | undefined;
    purchaseGroup!: string | undefined;
    requisitioner!: string | undefined;
    requisitionerName!: string | undefined;
    purchasingDocument!: string | undefined;
    purchaseOrderDate!: DateTime | undefined;
    outlineAgreement!: string | undefined;
    princAgreementItem!: string | undefined;
    purchasingInfoRec!: string | undefined;
    status!: string | undefined;
    createdBy!: string | undefined;
    currency!: string | undefined;
    entrySheet!: string | undefined;
    goodsReceipt!: string | undefined;
    supplierCode!: string | undefined;
    supplierName!: string | undefined;
    releaseIndicator!: string | undefined;
    unitPrice!: number | undefined;
    valuationPrice!: number | undefined;
    itemText!: string | undefined;
    longText!: string | undefined;
    firstApprovalDate!: DateTime | undefined;
    firstApprovalName!: string | undefined;
    lastApprovalDate!: DateTime | undefined;
    lastApprovalName!: string | undefined;
    costCenter!: string | undefined;
    costCenterDescription!: string | undefined;
    wbsElement!: string | undefined;
    asset!: string | undefined;
    fundsCenter!: string | undefined;
    remainQuantity!: number | undefined;
    createdDate!: DateTime;
    updatedDate!: DateTime;
    id!: string;

    constructor(data?: IZMM020RDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchaseRequisition = _data["purchaseRequisition"];
            this.documentType = _data["documentType"];
            this.documentTypeText = _data["documentTypeText"];
            this.itemRequisition = _data["itemRequisition"];
            this.processingStatusCode = _data["processingStatusCode"];
            this.processingStatus = _data["processingStatus"];
            this.deletionIndicator = _data["deletionIndicator"];
            this.itemCategory = _data["itemCategory"];
            this.accountAssignment = _data["accountAssignment"];
            this.material = _data["material"];
            this.shortText = _data["shortText"];
            this.quantityRequested = _data["quantityRequested"];
            this.unitOfMeasure = _data["unitOfMeasure"];
            this.serviceItem = _data["serviceItem"];
            this.service = _data["service"];
            this.serviceShortText = _data["serviceShortText"];
            this.quantityService = _data["quantityService"];
            this.unitOfMeasureService = _data["unitOfMeasureService"];
            this.deliveryDate = _data["deliveryDate"] ? DateTime.fromISO(_data["deliveryDate"].toString()) : <any>undefined;
            this.materialGroup = _data["materialGroup"];
            this.plant = _data["plant"];
            this.storageLocation = _data["storageLocation"];
            this.purchaseGroup = _data["purchaseGroup"];
            this.requisitioner = _data["requisitioner"];
            this.requisitionerName = _data["requisitionerName"];
            this.purchasingDocument = _data["purchasingDocument"];
            this.purchaseOrderDate = _data["purchaseOrderDate"] ? DateTime.fromISO(_data["purchaseOrderDate"].toString()) : <any>undefined;
            this.outlineAgreement = _data["outlineAgreement"];
            this.princAgreementItem = _data["princAgreementItem"];
            this.purchasingInfoRec = _data["purchasingInfoRec"];
            this.status = _data["status"];
            this.createdBy = _data["createdBy"];
            this.currency = _data["currency"];
            this.entrySheet = _data["entrySheet"];
            this.goodsReceipt = _data["goodsReceipt"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.releaseIndicator = _data["releaseIndicator"];
            this.unitPrice = _data["unitPrice"];
            this.valuationPrice = _data["valuationPrice"];
            this.itemText = _data["itemText"];
            this.longText = _data["longText"];
            this.firstApprovalDate = _data["firstApprovalDate"] ? DateTime.fromISO(_data["firstApprovalDate"].toString()) : <any>undefined;
            this.firstApprovalName = _data["firstApprovalName"];
            this.lastApprovalDate = _data["lastApprovalDate"] ? DateTime.fromISO(_data["lastApprovalDate"].toString()) : <any>undefined;
            this.lastApprovalName = _data["lastApprovalName"];
            this.costCenter = _data["costCenter"];
            this.costCenterDescription = _data["costCenterDescription"];
            this.wbsElement = _data["wbsElement"];
            this.asset = _data["asset"];
            this.fundsCenter = _data["fundsCenter"];
            this.remainQuantity = _data["remainQuantity"];
            this.createdDate = _data["createdDate"] ? DateTime.fromISO(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? DateTime.fromISO(_data["updatedDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ZMM020RDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZMM020RDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchaseRequisition"] = this.purchaseRequisition;
        data["documentType"] = this.documentType;
        data["documentTypeText"] = this.documentTypeText;
        data["itemRequisition"] = this.itemRequisition;
        data["processingStatusCode"] = this.processingStatusCode;
        data["processingStatus"] = this.processingStatus;
        data["deletionIndicator"] = this.deletionIndicator;
        data["itemCategory"] = this.itemCategory;
        data["accountAssignment"] = this.accountAssignment;
        data["material"] = this.material;
        data["shortText"] = this.shortText;
        data["quantityRequested"] = this.quantityRequested;
        data["unitOfMeasure"] = this.unitOfMeasure;
        data["serviceItem"] = this.serviceItem;
        data["service"] = this.service;
        data["serviceShortText"] = this.serviceShortText;
        data["quantityService"] = this.quantityService;
        data["unitOfMeasureService"] = this.unitOfMeasureService;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toString() : <any>undefined;
        data["materialGroup"] = this.materialGroup;
        data["plant"] = this.plant;
        data["storageLocation"] = this.storageLocation;
        data["purchaseGroup"] = this.purchaseGroup;
        data["requisitioner"] = this.requisitioner;
        data["requisitionerName"] = this.requisitionerName;
        data["purchasingDocument"] = this.purchasingDocument;
        data["purchaseOrderDate"] = this.purchaseOrderDate ? this.purchaseOrderDate.toString() : <any>undefined;
        data["outlineAgreement"] = this.outlineAgreement;
        data["princAgreementItem"] = this.princAgreementItem;
        data["purchasingInfoRec"] = this.purchasingInfoRec;
        data["status"] = this.status;
        data["createdBy"] = this.createdBy;
        data["currency"] = this.currency;
        data["entrySheet"] = this.entrySheet;
        data["goodsReceipt"] = this.goodsReceipt;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["releaseIndicator"] = this.releaseIndicator;
        data["unitPrice"] = this.unitPrice;
        data["valuationPrice"] = this.valuationPrice;
        data["itemText"] = this.itemText;
        data["longText"] = this.longText;
        data["firstApprovalDate"] = this.firstApprovalDate ? this.firstApprovalDate.toString() : <any>undefined;
        data["firstApprovalName"] = this.firstApprovalName;
        data["lastApprovalDate"] = this.lastApprovalDate ? this.lastApprovalDate.toString() : <any>undefined;
        data["lastApprovalName"] = this.lastApprovalName;
        data["costCenter"] = this.costCenter;
        data["costCenterDescription"] = this.costCenterDescription;
        data["wbsElement"] = this.wbsElement;
        data["asset"] = this.asset;
        data["fundsCenter"] = this.fundsCenter;
        data["remainQuantity"] = this.remainQuantity;
        data["createdDate"] = this.createdDate ? this.createdDate.toString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IZMM020RDto {
    purchaseRequisition: string | undefined;
    documentType: string | undefined;
    documentTypeText: string | undefined;
    itemRequisition: string | undefined;
    processingStatusCode: string | undefined;
    processingStatus: string | undefined;
    deletionIndicator: string | undefined;
    itemCategory: string | undefined;
    accountAssignment: string | undefined;
    material: string | undefined;
    shortText: string | undefined;
    quantityRequested: number | undefined;
    unitOfMeasure: string | undefined;
    serviceItem: string | undefined;
    service: string | undefined;
    serviceShortText: string | undefined;
    quantityService: number | undefined;
    unitOfMeasureService: string | undefined;
    deliveryDate: DateTime | undefined;
    materialGroup: string | undefined;
    plant: string | undefined;
    storageLocation: string | undefined;
    purchaseGroup: string | undefined;
    requisitioner: string | undefined;
    requisitionerName: string | undefined;
    purchasingDocument: string | undefined;
    purchaseOrderDate: DateTime | undefined;
    outlineAgreement: string | undefined;
    princAgreementItem: string | undefined;
    purchasingInfoRec: string | undefined;
    status: string | undefined;
    createdBy: string | undefined;
    currency: string | undefined;
    entrySheet: string | undefined;
    goodsReceipt: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    releaseIndicator: string | undefined;
    unitPrice: number | undefined;
    valuationPrice: number | undefined;
    itemText: string | undefined;
    longText: string | undefined;
    firstApprovalDate: DateTime | undefined;
    firstApprovalName: string | undefined;
    lastApprovalDate: DateTime | undefined;
    lastApprovalName: string | undefined;
    costCenter: string | undefined;
    costCenterDescription: string | undefined;
    wbsElement: string | undefined;
    asset: string | undefined;
    fundsCenter: string | undefined;
    remainQuantity: number | undefined;
    createdDate: DateTime;
    updatedDate: DateTime;
    id: string;
}

export class ZMM021RDto implements IZMM021RDto {
    purchasingDocument!: string | undefined;
    purchasingDocType!: string | undefined;
    purchasingDocTypeDescription!: string | undefined;
    item!: string | undefined;
    lineNumber!: string | undefined;
    deletionIndicator!: string | undefined;
    documentDate!: DateTime;
    createdOn!: DateTime;
    purchaseRequisition!: string | undefined;
    itemPR!: string | undefined;
    supplierCode!: string | undefined;
    supplierName!: string | undefined;
    address!: string | undefined;
    itemNo!: string | undefined;
    materialGroup!: string | undefined;
    shortText!: string | undefined;
    orderQuantity!: number | undefined;
    orderUnit!: string | undefined;
    currency!: string | undefined;
    deliveryDate!: DateTime | undefined;
    netPrice!: number | undefined;
    netOrderValue!: number | undefined;
    demurrage!: number | undefined;
    grossPrice!: number | undefined;
    totalDiscount!: number | undefined;
    freightCost!: number | undefined;
    releaseIndicator!: string | undefined;
    plant!: string | undefined;
    purchasingGroup!: string | undefined;
    taxCode!: string | undefined;
    collectiveNumber!: string | undefined;
    itemCategory!: string | undefined;
    accountAssignment!: string | undefined;
    outlineAgreement!: string | undefined;
    rfqNo!: string | undefined;
    qtyPending!: number | undefined;
    materialService!: string | undefined;
    approvalStatus!: string | undefined;
    poStatus!: string | undefined;
    period!: string | undefined;
    commentVendor!: string | undefined;
    itemText!: string | undefined;
    longText!: string | undefined;
    ourReference!: string | undefined;
    prFinalFirstApprovalDate!: DateTime | undefined;
    prFinalLastApprovalDate!: DateTime | undefined;
    poFirstApprovalDate!: DateTime | undefined;
    poLastApprovalDate!: DateTime | undefined;
    poApprovalName!: string | undefined;
    buyerCode!: string | undefined;
    buyerName!: string | undefined;
    picDept!: string | undefined;
    picSect!: string | undefined;
    fuelAllocation!: string | undefined;
    costCenter!: string | undefined;
    costCenterDescription!: string | undefined;
    wbsElement!: string | undefined;
    assetNo!: string | undefined;
    fundCenter!: string | undefined;
    createdDate!: DateTime;
    updatedDate!: DateTime;
    id!: string;

    constructor(data?: IZMM021RDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.purchasingDocument = _data["purchasingDocument"];
            this.purchasingDocType = _data["purchasingDocType"];
            this.purchasingDocTypeDescription = _data["purchasingDocTypeDescription"];
            this.item = _data["item"];
            this.lineNumber = _data["lineNumber"];
            this.deletionIndicator = _data["deletionIndicator"];
            this.documentDate = _data["documentDate"] ? DateTime.fromISO(_data["documentDate"].toString()) : <any>undefined;
            this.createdOn = _data["createdOn"] ? DateTime.fromISO(_data["createdOn"].toString()) : <any>undefined;
            this.purchaseRequisition = _data["purchaseRequisition"];
            this.itemPR = _data["itemPR"];
            this.supplierCode = _data["supplierCode"];
            this.supplierName = _data["supplierName"];
            this.address = _data["address"];
            this.itemNo = _data["itemNo"];
            this.materialGroup = _data["materialGroup"];
            this.shortText = _data["shortText"];
            this.orderQuantity = _data["orderQuantity"];
            this.orderUnit = _data["orderUnit"];
            this.currency = _data["currency"];
            this.deliveryDate = _data["deliveryDate"] ? DateTime.fromISO(_data["deliveryDate"].toString()) : <any>undefined;
            this.netPrice = _data["netPrice"];
            this.netOrderValue = _data["netOrderValue"];
            this.demurrage = _data["demurrage"];
            this.grossPrice = _data["grossPrice"];
            this.totalDiscount = _data["totalDiscount"];
            this.freightCost = _data["freightCost"];
            this.releaseIndicator = _data["releaseIndicator"];
            this.plant = _data["plant"];
            this.purchasingGroup = _data["purchasingGroup"];
            this.taxCode = _data["taxCode"];
            this.collectiveNumber = _data["collectiveNumber"];
            this.itemCategory = _data["itemCategory"];
            this.accountAssignment = _data["accountAssignment"];
            this.outlineAgreement = _data["outlineAgreement"];
            this.rfqNo = _data["rfqNo"];
            this.qtyPending = _data["qtyPending"];
            this.materialService = _data["materialService"];
            this.approvalStatus = _data["approvalStatus"];
            this.poStatus = _data["poStatus"];
            this.period = _data["period"];
            this.commentVendor = _data["commentVendor"];
            this.itemText = _data["itemText"];
            this.longText = _data["longText"];
            this.ourReference = _data["ourReference"];
            this.prFinalFirstApprovalDate = _data["prFinalFirstApprovalDate"] ? DateTime.fromISO(_data["prFinalFirstApprovalDate"].toString()) : <any>undefined;
            this.prFinalLastApprovalDate = _data["prFinalLastApprovalDate"] ? DateTime.fromISO(_data["prFinalLastApprovalDate"].toString()) : <any>undefined;
            this.poFirstApprovalDate = _data["poFirstApprovalDate"] ? DateTime.fromISO(_data["poFirstApprovalDate"].toString()) : <any>undefined;
            this.poLastApprovalDate = _data["poLastApprovalDate"] ? DateTime.fromISO(_data["poLastApprovalDate"].toString()) : <any>undefined;
            this.poApprovalName = _data["poApprovalName"];
            this.buyerCode = _data["buyerCode"];
            this.buyerName = _data["buyerName"];
            this.picDept = _data["picDept"];
            this.picSect = _data["picSect"];
            this.fuelAllocation = _data["fuelAllocation"];
            this.costCenter = _data["costCenter"];
            this.costCenterDescription = _data["costCenterDescription"];
            this.wbsElement = _data["wbsElement"];
            this.assetNo = _data["assetNo"];
            this.fundCenter = _data["fundCenter"];
            this.createdDate = _data["createdDate"] ? DateTime.fromISO(_data["createdDate"].toString()) : <any>undefined;
            this.updatedDate = _data["updatedDate"] ? DateTime.fromISO(_data["updatedDate"].toString()) : <any>undefined;
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): ZMM021RDto {
        data = typeof data === 'object' ? data : {};
        let result = new ZMM021RDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["purchasingDocument"] = this.purchasingDocument;
        data["purchasingDocType"] = this.purchasingDocType;
        data["purchasingDocTypeDescription"] = this.purchasingDocTypeDescription;
        data["item"] = this.item;
        data["lineNumber"] = this.lineNumber;
        data["deletionIndicator"] = this.deletionIndicator;
        data["documentDate"] = this.documentDate ? this.documentDate.toString() : <any>undefined;
        data["createdOn"] = this.createdOn ? this.createdOn.toString() : <any>undefined;
        data["purchaseRequisition"] = this.purchaseRequisition;
        data["itemPR"] = this.itemPR;
        data["supplierCode"] = this.supplierCode;
        data["supplierName"] = this.supplierName;
        data["address"] = this.address;
        data["itemNo"] = this.itemNo;
        data["materialGroup"] = this.materialGroup;
        data["shortText"] = this.shortText;
        data["orderQuantity"] = this.orderQuantity;
        data["orderUnit"] = this.orderUnit;
        data["currency"] = this.currency;
        data["deliveryDate"] = this.deliveryDate ? this.deliveryDate.toString() : <any>undefined;
        data["netPrice"] = this.netPrice;
        data["netOrderValue"] = this.netOrderValue;
        data["demurrage"] = this.demurrage;
        data["grossPrice"] = this.grossPrice;
        data["totalDiscount"] = this.totalDiscount;
        data["freightCost"] = this.freightCost;
        data["releaseIndicator"] = this.releaseIndicator;
        data["plant"] = this.plant;
        data["purchasingGroup"] = this.purchasingGroup;
        data["taxCode"] = this.taxCode;
        data["collectiveNumber"] = this.collectiveNumber;
        data["itemCategory"] = this.itemCategory;
        data["accountAssignment"] = this.accountAssignment;
        data["outlineAgreement"] = this.outlineAgreement;
        data["rfqNo"] = this.rfqNo;
        data["qtyPending"] = this.qtyPending;
        data["materialService"] = this.materialService;
        data["approvalStatus"] = this.approvalStatus;
        data["poStatus"] = this.poStatus;
        data["period"] = this.period;
        data["commentVendor"] = this.commentVendor;
        data["itemText"] = this.itemText;
        data["longText"] = this.longText;
        data["ourReference"] = this.ourReference;
        data["prFinalFirstApprovalDate"] = this.prFinalFirstApprovalDate ? this.prFinalFirstApprovalDate.toString() : <any>undefined;
        data["prFinalLastApprovalDate"] = this.prFinalLastApprovalDate ? this.prFinalLastApprovalDate.toString() : <any>undefined;
        data["poFirstApprovalDate"] = this.poFirstApprovalDate ? this.poFirstApprovalDate.toString() : <any>undefined;
        data["poLastApprovalDate"] = this.poLastApprovalDate ? this.poLastApprovalDate.toString() : <any>undefined;
        data["poApprovalName"] = this.poApprovalName;
        data["buyerCode"] = this.buyerCode;
        data["buyerName"] = this.buyerName;
        data["picDept"] = this.picDept;
        data["picSect"] = this.picSect;
        data["fuelAllocation"] = this.fuelAllocation;
        data["costCenter"] = this.costCenter;
        data["costCenterDescription"] = this.costCenterDescription;
        data["wbsElement"] = this.wbsElement;
        data["assetNo"] = this.assetNo;
        data["fundCenter"] = this.fundCenter;
        data["createdDate"] = this.createdDate ? this.createdDate.toString() : <any>undefined;
        data["updatedDate"] = this.updatedDate ? this.updatedDate.toString() : <any>undefined;
        data["id"] = this.id;
        return data;
    }
}

export interface IZMM021RDto {
    purchasingDocument: string | undefined;
    purchasingDocType: string | undefined;
    purchasingDocTypeDescription: string | undefined;
    item: string | undefined;
    lineNumber: string | undefined;
    deletionIndicator: string | undefined;
    documentDate: DateTime;
    createdOn: DateTime;
    purchaseRequisition: string | undefined;
    itemPR: string | undefined;
    supplierCode: string | undefined;
    supplierName: string | undefined;
    address: string | undefined;
    itemNo: string | undefined;
    materialGroup: string | undefined;
    shortText: string | undefined;
    orderQuantity: number | undefined;
    orderUnit: string | undefined;
    currency: string | undefined;
    deliveryDate: DateTime | undefined;
    netPrice: number | undefined;
    netOrderValue: number | undefined;
    demurrage: number | undefined;
    grossPrice: number | undefined;
    totalDiscount: number | undefined;
    freightCost: number | undefined;
    releaseIndicator: string | undefined;
    plant: string | undefined;
    purchasingGroup: string | undefined;
    taxCode: string | undefined;
    collectiveNumber: string | undefined;
    itemCategory: string | undefined;
    accountAssignment: string | undefined;
    outlineAgreement: string | undefined;
    rfqNo: string | undefined;
    qtyPending: number | undefined;
    materialService: string | undefined;
    approvalStatus: string | undefined;
    poStatus: string | undefined;
    period: string | undefined;
    commentVendor: string | undefined;
    itemText: string | undefined;
    longText: string | undefined;
    ourReference: string | undefined;
    prFinalFirstApprovalDate: DateTime | undefined;
    prFinalLastApprovalDate: DateTime | undefined;
    poFirstApprovalDate: DateTime | undefined;
    poLastApprovalDate: DateTime | undefined;
    poApprovalName: string | undefined;
    buyerCode: string | undefined;
    buyerName: string | undefined;
    picDept: string | undefined;
    picSect: string | undefined;
    fuelAllocation: string | undefined;
    costCenter: string | undefined;
    costCenterDescription: string | undefined;
    wbsElement: string | undefined;
    assetNo: string | undefined;
    fundCenter: string | undefined;
    createdDate: DateTime;
    updatedDate: DateTime;
    id: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}